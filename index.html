<!DOCTYPE html>    
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>スイーツワンダーリーグ</title>
<style>
  :root{
    --leaderChipSize: 21.6px;
    --leaderChipOffset: 22px;
    --actionZoomEffectSize: 18px;
    --helpActionCardW: 90px;
    --helpActionEffectTop: 66%;
    --helpActionEffectPadding: 3px;
    --helpActionEffectSize: 10px;
    --helpActionEffectLineHeight: 1.25;
  }
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:40; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn:disabled{opacity:.45; cursor:not-allowed;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('swtop.jpg'); }
  main.joined{ background-image:url('swmain.jpg'); }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:60;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:62;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

/* ★ プレイヤー円配置用（拡大：直径だいたい400前後） */
.player-circle{
  position:relative;
  width:min(300px, 92vw);
  height:min(400px, 92vw);
  margin:20px auto 0;
  border-radius:50%;
  box-sizing:border-box;
  border:none;
}



  /* ★ 中央：プレイサークル（※スイーツ山札クリックのため pointer-events を有効に） */
  .play-circle{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:120px;height:120px;border-radius:50%;
    background:transparent;
    pointer-events:auto;
border:transparent;
  }
  .required-sweets-tag{
    position:absolute;
    left:50%;
    top:calc(50% + 25px);
    transform:translate(-50%,-50%);
    font-size:12px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,247,224,.92);
    border:2px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
    pointer-events:none;
    z-index:7;
  }
  .play-circle::after{
    content:'PLAY';
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    font-weight:900;font-size:12px;letter-spacing:.08em;opacity:.65;
    pointer-events:none;
display:none;

  }
.play-circle.hint-ok {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* 薄い透明グレー */
}

.play-circle.hint-ng {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* 薄い透明グレー */
}

.play-circle.roundpick-target {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* 薄い透明グレー */
}


  /* =========================
     ★★ 中央：アクション山札（左）＋スイーツ山札（右）
     ========================= */
  .center-decks{
    position:absolute;
    left:50%; top:50%;
  transform:translate(-50%,-50%) translateY(60px); /* ← ここを増やすほど下がる */
    display:flex;
    gap:14px;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }
  .center-decks.hidden{display:none;}

  /* アクション山札（見た目専用） */
  .action-deck{
    position:relative;
    width:28px; height:40px;
    pointer-events:none;
  }
  .action-deck.hidden{display:none;}
  .action-deck .stack{position:absolute; inset:0;}
  .action-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swactionura.jpg') center/cover no-repeat;
    box-shadow:none;
  }
  .action-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
  .action-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
  .action-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
  .action-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
  .action-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
  display:none;
  }

  /* スイーツ山札（クリック可能） */
 .sweets-deck{
    position:relative;
    width:28px; height:40px;
    pointer-events:auto;
    cursor:pointer;
    user-select:none;
    touch-action:none;
  }
 .sweets-deck-wrap{
    position:relative;
    width:28px;
    height:40px;
  }
  .sweets-deck-wrap .sweets-deck{
    position:absolute;
    inset:0;
  }
  .sweets-deck-mover,
  .sweets-excluded-deck-mover{
    position:absolute;
    inset:0;
    transition:transform .65s cubic-bezier(.22,.84,.44,1);
    will-change:transform;
    z-index:4;
  }
  .sweets-deck-mover.relocating,
  .sweets-excluded-deck-mover.relocating{
    z-index:70;
  }
  .sweets-deck.hidden{display:none;}
  .sweets-deck .stack{position:absolute; inset:0;}
  .sweets-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:none;
  }
  .sweets-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
  .sweets-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
  .sweets-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
  .sweets-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
  .sweets-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
   line-height:1.1;
    pointer-events:none;
  }
  .sweets-excluded-deck-mover{
    position:absolute;
    inset:auto;
    right:-43px;
    top:0;
    width:28px;
    height:40px;
  }
  .sweets-exclude-deck{
    position:absolute;
    inset:0;
    width:28px;
    height:40px;
    pointer-events:none;
    user-select:none;
  }
  .sweets-exclude-deck.hidden{display:none;}
  .sweets-exclude-deck .stack{position:absolute; inset:0;}
  .sweets-exclude-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:none;
    transform:rotate(90deg);
    transform-origin:center;
  }
  .sweets-exclude-deck .card.c2{ transform:translate(1px,-1px) rotate(90deg); opacity:.95; }
  .sweets-exclude-deck .card.c3{ transform:translate(2px,-2px) rotate(90deg); opacity:.90; }
  .sweets-exclude-deck .card.c4{ transform:translate(3px,-3px) rotate(90deg); opacity:.86; }
  .sweets-exclude-deck .card.c5{ transform:translate(4px,-4px) rotate(90deg); opacity:.82; }
  .sweets-exclude-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
    pointer-events:none;
  }
/* 除外札全体を少し薄く */
#sweetsExcludedDeckUI{
  opacity: .50;   /* 好みで調整 */
}

/* ✅ 除外デッキ：出現を「傾き＋フェード」で */
.sweets-exclude-deck{
  /* ふわっと出すための基準状態 */
  opacity: 1;
  visibility: visible;
  transform: translateX(0px) rotate(0deg) scale(1);
  will-change: opacity, transform;
  transition:
    opacity .22s ease,
    transform .22s cubic-bezier(.22,.84,.44,1),
    visibility 0s linear 0s;
}

/* ✅ 重要：.hidden を display:none にさせず、アニメ可能な隠し方に上書き */
.sweets-exclude-deck.hidden{
  display: block;                 /* ← これが肝。display:none を殺す */
  opacity: 0;
  visibility: hidden;
  transform: translateX(10px) rotate(-25deg) scale(.85); /* ← “傾く”の正体 */
  transition:
    opacity .18s ease,
    transform .18s ease,
    visibility 0s linear .18s;    /* ← フェード後に不可視へ */
}


  /* ★ 自分のターンだけ「大小アニメ（鼓動）」 */
  @keyframes pulseCard {
    0%{transform:scale(1);}
    50%{transform:scale(1.06);}
    100%{transform:scale(1);}
  }
@keyframes pulseCardStrong {
    0%{transform:scale(1);}
    50%{transform:scale(1.12);}
    100%{transform:scale(1);}
  }
  @keyframes pulseCardAccident {
    0%{transform:scale(1);}
    50%{transform:scale(1.4);}
    100%{transform:scale(1);}
  }
  .my-sweets.advertise-selectable,
  .sweets-wrap.advertise-selectable .sweets-mini{
    animation:pulseSweetsDeck 1.05s ease-in-out infinite;
  }
  .advertise-number-tag{
    position:absolute;
    left:-8px;
    top:-12px;
    width:34px;
    height:34px;
    display:grid;
    place-items:center;
    font-weight:900;
    font-size:13px;
    line-height:1;
    color:#111;
    text-shadow:0 1px 0 rgba(255,255,255,.6);
    pointer-events:none;
  }
  .advertise-number-tag .sweets-number-star{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    z-index:0;
    pointer-events:none;
  }
  .advertise-number-tag .sweets-number-text{
    position:relative;
    z-index:1;
    transform:translateZ(0) translateY(-1px);
  }
  .advertise-eye{
    position:absolute;
    left:76%;
    top:-15%;
    transform:translate(-50%,-50%);
    font-size:20px;
    pointer-events:none;
    z-index:2;
  }
  .sweets-move-card{
    position:fixed;
    left:0;
    top:0;
    width:28px;
    height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.2);
    z-index:70;
    pointer-events:none;
    will-change:transform;
  }

  @keyframes sweetsDecidedMove {
    from{transform:translateY(0);}
    to{transform:translateY(-60px);}
  }
  @keyframes sweetsTagMove {
    from{transform:translate(-50%,0);}
    to{transform:translate(-50%, var(--sweetsTagMoveY));}
  }
  @keyframes sweetsDecidedMoveMy {
    from{transform:translateY(0);}
    to{transform:translateY(-30px);}
  }
/* ✅ スイーツ山札専用：鼓動（例：強め） */
@keyframes pulseSweetsDeck {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.4); } /* ← 強さ（例：1.06〜1.14） */
  100% { transform: scale(1); }
}
  @keyframes pulseSweetsDeckTrial {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.4); }
  100% { transform: scale(1); }
}
@keyframes nametagpuls1 {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.4); }
  100% { transform: scale(1); }
}
  .sweets-deck.pulsing{ animation:pulseSweetsDeck 1.05s ease-in-out infinite; }
  .sweets-deck.trial-pulsing{ animation:pulseSweetsDeckTrial 1.05s ease-in-out infinite; }
  .sweets-deck.pulsing:hover{ animation:none; transform:scale(1.14); }
  .sweets-deck.trial-pulsing:hover{ animation:none; transform:scale(1.14); }
  .sweets-exclude-deck.pulsing{ animation:pulseSweetsDeck 1.05s ease-in-out infinite; }
  .sweets-exclude-deck.pulsing:hover{ animation:none; transform:scale(1.14); }
  .sweets-exclude-deck.selectable{ pointer-events:auto; cursor:pointer; }

  /* ★★ 他プレイヤー：ネームタグ＋カード周りを円で囲む（otherplayerscircle） */
 .otherplayerscircle{
    position:absolute;
    left:0; top:0;
    width:126px; height:126px;
    transform:translate(-50%,-50%);
    border-radius:50%;
    border:2px solid transparent;
    background:transparent;
    display:flex;align-items:center;justify-content:center;
    box-sizing:border-box;
  }
  .otherplayerscircle.hint-ok{ border-color:rgba(34,197,94,.75); }
  .otherplayerscircle.hint-ng{ border-color:rgba(239,68,68,.75); }

  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    display:flex;align-items:center;gap:6px;
  }
  .player-tag .name-pill{
    display:inline-flex;
    align-items:center;
    padding:4px 8px;
    border-radius:999px;
    background:var(--tagFill, #f8f8f8);
    border:1px solid var(--tagBorder, #ddd);
    font-size:12px;
    white-space:nowrap;
    color:var(--tagText, #111);
    font-weight:inherit;
  }
  .player-tag.me{
    transform:translate(-50%,-50%) translateY(45px);
  }
  /* ★ 手番の青枠：ネームタグ輪郭の外側 */
  .player-tag.active-turn{
    outline:none;
  }
  .player-tag .name-pill.active-turn{
    animation:nametagpuls1 1.05s ease-in-out infinite;
    transform-origin:center;
    will-change:transform;
    font-weight:800;
  }

  /* otherplayerscircle 内のタグは「中央配置」扱い */
  .player-tag.in-othercircle{
    position:relative;
    transform:none;
    left:auto; top:auto;
  }

  /* =========================
     ★ ネームタグ&投票チップ デザイン（8種）
     ========================= */
  .tag-chip-style-1{
    --tagFill: linear-gradient(180deg, #e0f2fe 0%, #bae6fd 100%);
    --tagBorder: #ffffff;
    --tagText: #0f172a;
    --voteChipFill: linear-gradient(135deg, #bae6fd 0%, #7dd3fc 100%);
    --voteChipStroke: #ffffff;
  }
  .tag-chip-style-2{
    --tagFill: repeating-linear-gradient(45deg, #f97316 0 6px, #7c2d12 6px 12px);
    --tagBorder: #7c2d12;
    --tagText: #fff7ed;
    --voteChipFill: repeating-linear-gradient(45deg, #f97316 0 4px, #7c2d12 4px 8px);
    --voteChipStroke: #7c2d12;
  }
  .tag-chip-style-3{
    --tagFill: radial-gradient(circle at 20% 30%, #f9a8d4 0 12%, transparent 13%),
      radial-gradient(circle at 80% 70%, #f9a8d4 0 12%, transparent 13%),
      linear-gradient(180deg, #ecfdf5 0%, #d1fae5 100%);
    --tagBorder: #10b981;
    --tagText: #065f46;
    --voteChipFill: radial-gradient(circle at 30% 30%, #f9a8d4 0 18%, transparent 19%),
      linear-gradient(180deg, #d1fae5 0%, #a7f3d0 100%);
    --voteChipStroke: #10b981;
  }
  .tag-chip-style-4{
    --tagFill: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 60%, #c4b5fd 100%);
    --tagBorder: #a78bfa;
    --tagText: #4c1d95;
    --voteChipFill: linear-gradient(135deg, #ddd6fe 0%, #c4b5fd 100%);
    --voteChipStroke: #a78bfa;
  }
  .tag-chip-style-5{
    --tagFill: repeating-linear-gradient(90deg, #fef9c3 0 8px, #fde68a 8px 16px);
    --tagBorder: #f59e0b;
    --tagText: #92400e;
    --voteChipFill: repeating-linear-gradient(90deg, #fef9c3 0 6px, #fde68a 6px 12px);
    --voteChipStroke: #f59e0b;
  }
  .tag-chip-style-6{
    --tagFill: linear-gradient(160deg, #fef2f2 0%, #fecaca 60%, #fca5a5 100%);
    --tagBorder: #ef4444;
    --tagText: #7f1d1d;
    --voteChipFill: linear-gradient(160deg, #fecaca 0%, #fca5a5 100%);
    --voteChipStroke: #ef4444;
  }
  .tag-chip-style-7{
    --tagFill: linear-gradient(135deg, #cffafe 0%, #99f6e4 100%);
    --tagBorder: #14b8a6;
    --tagText: #0f766e;
    --voteChipFill: linear-gradient(135deg, #99f6e4 0%, #5eead4 100%);
    --voteChipStroke: #14b8a6;
  }
  .tag-chip-style-8{
    --tagFill: repeating-linear-gradient(135deg, #fce7f3 0 6px, #fbcfe8 6px 12px);
    --tagBorder: #ec4899;
    --tagText: #9d174d;
    --voteChipFill: repeating-linear-gradient(135deg, #fbcfe8 0 5px, #f472b6 5px 10px);
    --voteChipStroke: #ec4899;
  }

/* ★ リーダーチップ（1.2倍） */
.leader-chip{
  position:absolute;
  right:calc(-1 * var(--leaderChipOffset));
  top:50%;
  width:var(--leaderChipSize);
  height:var(--leaderChipSize);
  transform:translateY(-50%);
  background:url('swleader.png') center/contain no-repeat;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.35));
  pointer-events:none;
}
.leader-chip-fly{
  position:fixed;
  z-index:70;
  pointer-events:none;
}
.leader-chip-hidden{
  opacity:0;
}

@keyframes leaderPickPulse{
  0%{ transform:scale(1); }
  50%{ transform:scale(1.5); }
  100%{ transform:scale(1); }
}
.leader-pick-candidate .name-pill{
  animation:leaderPickPulse 1.1s ease-in-out infinite;
  transform-origin:center;
}
.leader-pick-selectable{
  cursor:pointer;
}

.leader-pick-pop{
  position:fixed;
  left:50%;
  bottom:10px;
  transform:translateX(-50%);
  background:#fde047;
  color:#92400e;
  font-weight:900;
  padding:10px 16px;
  border-radius:14px;
  border:2px solid #f59e0b;
  box-shadow:0 14px 30px rgba(0,0,0,.25);
  z-index:97;
  white-space:nowrap;
}
.leader-pick-pop.hidden{display:none;}
.action-pop{
  display:flex;
  flex-direction:column;
  gap:6px;
  align-items:center;
  text-align:center;
  white-space:normal;
  max-width:min(90vw, 360px);
}
.action-pop .action-pop-actions{
  display:flex;
  gap:8px;
  justify-content:center;
  flex-wrap:wrap;
}
.action-pop .action-pop-text{
  font-weight:900;
}
.scout-reveal-overlay{
  position:fixed;inset:0;
  background:rgba(0,0,0,.55);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:80;
}
.scout-reveal-overlay.hidden{display:none;}
.scout-reveal-grid{
  display:flex;
  flex-wrap:nowrap;
  gap:12px;
  max-width:92vw;
  overflow-x:auto;
  padding:8px 12px;
}
.scout-reveal-grid .action-card{
  position:relative;
  inset:auto;
  transform:none;
  cursor:default;
  width:140px;
  height:210px;
}
.scout-reveal-grid .action-card .card-name{
  font-size:11px;
}
.scout-reveal-grid .action-card .effect-text{
  font-size:10px;
}
.sweets-peek-overlay{
  position:fixed;inset:0;
  background:rgba(0,0,0,.55);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:80;
}
.sweets-peek-overlay.hidden{display:none;}
.sweets-peek-card{
  width:160px;
  height:240px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.18);
  box-shadow:0 16px 36px rgba(0,0,0,.32);
  overflow:hidden;
  cursor:pointer;
  background:#fff;
}
.sweets-peek-card img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}
.discard-action-preview{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%) rotate(-10deg);
  width:140px;
  height:210px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,.18);
  background:#fff;
  box-shadow:0 16px 36px rgba(0,0,0,.28);
  overflow:hidden;
  z-index:88;
}
.discard-action-preview img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}
.mini-hand.scout-selectable{
  animation:scoutPulse 1.1s ease-in-out infinite;
}
@keyframes scoutPulse{
  0%{ transform:translateX(-50%) scale(1); }
  50%{ transform:translateX(-50%) scale(1.6); }
  100%{ transform:translateX(-50%) scale(1); }
}


  /* 他プレイヤー：正体カード（裏） */
.role-mini{
  position:absolute;
  left:-34px; top:50%;
  transform:translateY(-50%);
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  pointer-events:none;
  overflow:visible;
}
.role-mini .role-mini-frame{
  position:absolute;
  inset:0;
  border-radius:inherit;
  overflow:hidden;
}
.role-mini img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}
  .player-tag .other-role-mini.wiretap-selectable{
  pointer-events:auto;
  cursor:pointer;
  animation:pulseRoleMiniWiretap 1.05s ease-in-out infinite;
  transform-origin:center;
}
  .player-tag .other-role-mini.imprison-selectable{
  pointer-events:auto;
  cursor:pointer;
  animation:pulseRoleMiniImprison 1.05s ease-in-out infinite;
  transform-origin:center;
}
@keyframes pulseRoleMini{
  0%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1); }
  50%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1.4); }
  100%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1); }
}
@keyframes pulseRoleMiniImprison{
  0%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1); }
  50%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1.5); }
  100%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1); }
}
@keyframes pulseRoleMiniWiretap{
  0%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1); }
  50%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1.6); }
  100%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1); }
}
.my-role.imprison-selectable{
  cursor:pointer;
  animation:pulseRoleImprison 1.05s ease-in-out infinite;
  transform-origin:center;
}
@keyframes pulseRoleImprison{
  0%{ transform:scale(1); }
  50%{ transform:scale(1.5); }
  100%{ transform:scale(1); }
}
.imprisoned-badge{
  position:absolute;
  left:-6px;
  bottom:-6px;
  width:30px;
  height:42px;
  border-radius:6px;
  border:1px solid rgba(0,0,0,.18);
  box-shadow:0 6px 12px rgba(0,0,0,.25);
  overflow:hidden;
  z-index:3;
  background:#fff;
}

.role-mini .imprisoned-badge{
  left:-10px;
  bottom:-10px;
}
.my-role .imprisoned-badge{
  left:-6px;
  bottom:-6px;
}

.imprisoned-badge img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}
.action-deal-card{
  position:fixed;
  left:0;
  top:0;
  background:url('swactionura.jpg') center/cover no-repeat;
  border:1px solid rgba(0,0,0,.18);
  border-radius:7px;
  box-shadow:0 10px 24px rgba(0,0,0,.18);
  pointer-events:none;
  z-index:70;
  will-change:transform;
}
  /* ★★ 他プレイヤー：ミニスイーツ（裏）＋周りを円で囲む＝swarea */
/* 他プレイヤー：スイーツ枠（山札と同サイズ） */
.sweets-area{
  position:absolute;
  left:-66px; top:50%;
  transform:translateY(-50%);
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:2px solid rgba(0,0,0,.22);
  background:rgba(255,255,255,.10);
  display:flex;
  align-items:center;
  justify-content:center;
  box-sizing:border-box;
  pointer-events:auto;

}
.sweets-area.empty{
  border-style:dashed;
  opacity:.35;
}
.sweets-area.hint-ok{ border-color:rgba(34,197,94,.75); }
.sweets-area.hint-ng{ border-color:rgba(239,68,68,.75); }

.sweets-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swsweetsura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  position:relative;
  overflow:visible;
}
.sweets-mini img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
  border-radius:inherit;
}
.sweets-mini.advertise-revealed{
  background:none;
}
.sweets-mini.hidden{display:none;}

/* 投票チップ（他プレイヤーのスイーツ右側に重ねる） */
.vote-stack{
  position:absolute;
  right:-22px;
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-wrap:wrap;

  width:calc(var(--voteMiniSize) * 2 + 6px); /* 2列 */
  gap:3px;
  justify-content:flex-start;
  align-items:center;
  pointer-events:none;
}

.vote-mini{
  width:var(--voteMiniSize);
  height:var(--voteMiniSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 6px 14px rgba(0,0,0,.18);
}


  /* 他プレイヤーのミニカード（ネームタグの下に扇状） */
.player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:60px;height:30px;pointer-events:none;
  }
 .player-tag .other-role-mini{
    position:absolute;
    left:50%;
    top:100%;
    --roleMiniX: calc(-50% - 40px);
    --roleMiniY: -3px;
    transform:translate(var(--roleMiniX), var(--roleMiniY));
    box-sizing:border-box;
    pointer-events:none;
  }
  .player-tag.right-side .other-role-mini{
    --roleMiniX: calc(-50% + 40px);
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:url('swactionura.jpg') center/cover no-repeat;
  transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }
  .role-mini .received-instruction-stack{
    position:absolute;
    left:-6px;
    top:-6px;
    width:16px;
    height:22px;
    pointer-events:none;
  }
  .role-mini .received-instruction-card{
    position:absolute;
    left:0;
    top:0;
    width:16px;
    height:22px;
    border-radius:4px;
    border:1px solid #bbb;
    background:url('swactionura.jpg') center/cover no-repeat;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }
  .role-mini .other-vote-chip{
    position:absolute;
    right:-6px;
    bottom:-6px;
    width:var(--voteMiniSize);
    height:var(--voteMiniSize);
    border-radius:50%;
    border:2px solid var(--voteChipStroke);
    background:var(--voteChipFill);
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    pointer-events:none;
  }
  .vote-chip-fly{
    position:fixed;
    left:0;
    top:0;
    width:var(--voteMiniSize);
    height:var(--voteMiniSize);
    border-radius:50%;
    border:2px solid var(--voteChipStroke);
    background:var(--voteChipFill);
    box-shadow:0 12px 28px rgba(0,0,0,.25);
    pointer-events:none;
    z-index:75;
    will-change:transform;
  }
  .vote-stack.animating{
    opacity:0;
  }
  .wiretap-arrow{
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:80;
  }
  .wiretap-arrow svg{
    width:100%;
    height:100%;
  }
  .wiretap-arrow line{
    stroke:#111;
    stroke-width:2;
    stroke-dasharray:6 6;
  }
  .wiretap-arrow .wiretap-eye{
    position:fixed;
    transform:translate(-50%,-50%);
    font-size:20px;
  }
  /* 自分の手札表示（大きめ横並び） */
  .my-hand-wrapper{margin-top:40px;text-align:center; position:relative;}
  .my-hand-title{display:none;}
  .my-area{
    display:flex;gap:10px;justify-content:center;align-items:flex-start;
    margin-top:-6px;
  }

  /* ★ 自分の正体カード（自分のアクションカードの左側） */
  .my-role-stack{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
    flex:0 0 auto;
  }
  .my-role{
    width:78px;height:118px;border-radius:12px;border:1px solid #ddd;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    background:#fff;
    overflow:visible;
    position:relative;
    flex:0 0 auto;
  }
  .my-role img{width:100%;height:100%;object-fit:cover;display:block;}
  .my-vote-slots{
    display:grid;
    grid-template-columns:repeat(2, var(--voteChipSize));
    gap:6px;
    align-items:center;
    justify-content:center;
    width:calc(var(--voteChipSize) * 2 + 6px);
    height:var(--voteChipSize);
  }
  .my-vote-slot{
    width:var(--voteChipSize);
    height:var(--voteChipSize);
    background:transparent;
    border:none;
  }

  /* ★★ 自分のスイーツ（正体カードの左／同サイズ） */
  .my-sweets{
    width:78px;height:118px;border-radius:12px;border:1px solid #ddd;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    background:#fff;
    overflow:visible;
    position:relative;
    flex:0 0 auto;
  }
  .my-sweets.collect-hidden{
    opacity:0;
    visibility:hidden;
  }
  .my-sweets.hidden{display:none;}  .my-sweets img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
    border-radius:inherit;
  }
  /* =========================
     ★ 受け取った指示カードスロット（正体カードの左）
     ========================= */
  .my-received-slot{
    flex:0 0 auto;
    display:flex;align-items:flex-start;justify-content:center;gap:8px;flex-wrap:wrap;
  }
  .my-received-slot .action-card{
    cursor:default;
  }
  .my-hand{
    display:flex;justify-content:center;gap:10px;flex-wrap:nowrap;
    min-height:130px;
  }

  /* ★ アクションカード（自分の手札） */
  .action-card{
    position:relative;
    width:90px;height:135px;border-radius:12px;border:1px solid #ddd;background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    overflow:hidden;
    user-select:none;
    touch-action:none;
    cursor:grab;
    transform-origin:center;
  }
  .action-card:active{cursor:grabbing;}
  .action-card.locked{
    animation:none !important;
    cursor:not-allowed;
    filter:grayscale(.25);
    opacity:.72;
  }
  .action-card img.card-img{
    position:absolute;inset:0;width:100%;height:100%;object-fit:cover;
    display:block;
  }
  .action-card .card-name{
    position:absolute;left:8px;top:6px;
    font-weight:900;font-size:14px;
    color:#1d4ed8;
    text-shadow:0 2px 6px rgba(255,255,255,.7);
    pointer-events:none;
    display:none;
  }

  .action-card .effect-frame{
    position:absolute;
    left:0;
    right:0;
    top:70%;
    bottom:0px;
    background:rgb(195,179,237);
    border-top:1px solid rgba(0,0,0,.15);
border-radius:0px;
    padding:2px 2px 2px;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    box-sizing:border-box;
    pointer-events:none;
  }
  .action-card .effect-text{
    width:100%;
    font-weight:800;
    line-height:1.2;
    color:#111;
    font-size:13px;
    word-break:break-word;
    hyphens:auto;
    overflow:hidden;
  }
  .my-turn-free .action-card{ animation:pulseCard 1.05s ease-in-out infinite; }
  .my-turn-free .action-card:hover{ animation:none; transform:scale(1.08); }

  /* ★ 受け取り指示カードがある間：通常手札は無効＆アニメ停止 */
  .my-turn-blocked .my-hand .action-card{
    animation:none !important;
    cursor:not-allowed;
    filter:grayscale(.25);
    opacity:.72;
  }

  /* ★ 指示カードスロット内のカードだけ鼓動させる */
  .my-turn-blocked .my-received-slot .action-card.pulse-only{
    animation:pulseCard 1.05s ease-in-out infinite;
    cursor:grab;
    filter:none;
    opacity:1;
  }
  .my-turn-blocked .my-received-slot .action-card.pulse-only:hover{
    animation:none;
    transform:scale(1.08);
  }

  /* ★ 無視カード：ブロック中でも鼓動＆使用可（手札内） */
  .my-turn-blocked .my-hand .action-card.can-ignore{
    animation:pulseCard 1.05s ease-in-out infinite !important;
    cursor:grab !important;
    filter:none !important;
    opacity:1 !important;
  }
  .my-turn-blocked .my-hand .action-card.can-ignore:hover{
    animation:none !important;
    transform:scale(1.08);
  }
  .my-turn-selecting .action-card{
    animation:none !important;
    cursor:not-allowed;
    filter:grayscale(.25);
    opacity:.72;
  }

  /* ★ ドラッグ中の見た目 */
  .dragging{
    position:fixed !important;
    z-index:85 !important;
    margin:0 !important;
    animation:none !important;
    pointer-events:none;
  }

  /* ★ 追い出し確認ダイアログ */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:70;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン（右下固定） */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:30;
  }
  .host-settings-btn.visible{display:flex;}
  .action-discard-zone{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid rgba(255,255,255,.65);
    background:rgba(255,255,255,.35);
    display:flex;align-items:center;justify-content:center;
    font-size:20px;cursor:grab;z-index:45;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    animation:pulseDiscardZone 1.3s ease-in-out infinite;
    backdrop-filter:blur(4px);
  }
  .action-discard-zone.hidden{display:none;}
  .action-discard-zone.active{
    background:rgba(255,255,255,.6);
    box-shadow:0 10px 24px rgba(0,0,0,.24);
  }
  @keyframes pulseDiscardZone{
    0%{transform:scale(1);}
    50%{transform:scale(1.12);}
    100%{transform:scale(1);}
  }

  /* ★ 設定ポップ（ホスト専用パネル） */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:50;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  /* 詳細情報消す用 */
  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  /* =========================
     ★ 左下「？」ボタン
     ========================= */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:35;
  }
  .help-btn.visible{display:flex;}

  /* ★ ヘルプ一覧ポップ */
  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:70;
    padding:20px 16px 44px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(76vh, 700px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px 12px 36px;overflow:auto;max-height:calc(70vh - 48px);}
  .help-divider{
    height:1px;
    background:#eee;
    margin:12px 0;
  }
  .help-section-title{
    font-weight:900;
    font-size:13px;
    margin:4px 0 10px;
  }
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
  }
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
    overflow:hidden;
  }
  .role-card img{width:100%;height:100%;object-fit:cover;display:block;}
 .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}
  .help-action-grid{
    display:grid;
    grid-template-columns:repeat(4, minmax(0, 1fr));
    gap:10px;
  }
  .help-action-grid .action-card{
    width:100%;
    height:auto;
    aspect-ratio:2 / 3;
    cursor:default;
    touch-action:auto;
  }
  .help-action-grid .action-card .effect-frame{
    top:var(--helpActionEffectTop);
    padding:var(--helpActionEffectPadding);
  }
  .help-action-grid .action-card .effect-text{
    font-size:var(--helpActionEffectSize);
    line-height:var(--helpActionEffectLineHeight);
  }

  /* =========================
     ★ ターン操作バー
     ========================= */
  .turn-bar{
    position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
    z-index:30;
    display:flex; gap:8px; align-items:center; justify-content:center;
    background:rgba(255,255,255,.85);
    border:1px solid #ddd;
    border-radius:999px;
    padding:6px 10px;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    backdrop-filter: blur(6px);
  }
  .turn-bar.hidden{display:none;}
  .turn-badge{
    font-size:12px;font-weight:900;opacity:.85;
    padding:4px 8px;border-radius:999px;border:1px solid #ddd;background:#fff;
  }

  /* =========================
     ★ 全員に見せる「中央拡大」(1秒)
     ========================= */
  .reveal-overlay{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%, calc(-50% - 70px));
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:5;
    pointer-events:none;
  }
  .reveal-overlay.hidden{display:none;}
  .reveal-overlay.pop .reveal-card{
    animation:revealPop 0.28s ease-out;
  }
  .action-zoom-overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.35);
    transform:none;
    z-index:95;
    pointer-events:auto;
  }
 .reveal-card{
    width:var(--helpActionCardW);
    aspect-ratio: 2 / 3;
    border-radius:12px;
    border:none;
    box-shadow:0 10px 22px rgba(0,0,0,.18);
    background:transparent;
    overflow:hidden;
    position:relative;
  }
  .reveal-card{
    transform:rotate(-2deg);
    transform-origin:center;
  }
  .action-zoom-card{
    width:min(calc(var(--myCardW) * 4), 78vw);
    aspect-ratio: 2 / 3;
    border-radius:18px;
    border:none;
    box-shadow:none;
    background:transparent;
    overflow:hidden;
    position:relative;
  }
  @keyframes revealPop{
    0%{ transform:scale(0.95) rotate(-2deg); }
    70%{ transform:scale(1.02) rotate(-2deg); }
    100%{ transform:scale(1) rotate(-2deg); }
  }
  .reveal-card img,
  .action-zoom-card img{width:100%;height:100%;object-fit:cover;display:block;border:none;background:transparent;}
  .reveal-card .label{
    position:absolute; left:10px; top:10px;
    font-weight:900; color:#1d4ed8;
    text-shadow:0 2px 10px rgba(255,255,255,.75);
  }
  .reveal-card .label.hidden{display:none;}
  .reveal-card .effect-frame{
    position:absolute;
    left:0;
    right:0;
    top:var(--helpActionEffectTop);
    bottom:0;
    background:rgb(195,179,237);
    border-top:1px solid rgba(0,0,0,.15);
    padding:var(--helpActionEffectPadding);
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    box-sizing:border-box;
    pointer-events:none;
  }
  .action-zoom-card .effect-frame{
    position:absolute;
    left:0;
    right:0;
    top:70%;
    bottom:0;
    background:rgb(195,179,237);
    border-top:1px solid rgba(0,0,0,.15);
    padding:6px 8px;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    box-sizing:border-box;
    pointer-events:none;
  }
  .reveal-card .effect-frame.hidden,
  .action-zoom-card .effect-frame.hidden{display:none;}
  .reveal-card .effect-text{
    width:100%;
    font-weight:800;
    line-height:var(--helpActionEffectLineHeight);
    color:#111;
    font-size:var(--helpActionEffectSize);
    word-break:break-word;
    hyphens:auto;
    overflow:hidden;
  }
  .action-zoom-card .effect-text{
    width:100%;
    font-weight:800;
    line-height:1.3;
    color:#111;
    font-size:var(--actionZoomEffectSize);
    word-break:break-word;
    hyphens:auto;
    overflow:hidden;
  }

  /* ★ 指示カード移動アニメ用（小さい裏カード） */
 .fly-card{
    position:fixed;
    width:22px;height:32px;border-radius:6px;
    border:1px solid rgba(0,0,0,.2);
    background:url('swactionura.jpg') center/cover no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.25);
    z-index:60;
    pointer-events:none;
  }
  .sweets-fly-card{
    position:fixed;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 10px 24px rgba(0,0,0,.22);
    background:#fff;
    overflow:hidden;
    z-index:65;
    pointer-events:none;
    transform-origin:center center;
  }
  .sweets-fly-card img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }


  /* ★ 自分の手札サイズ統一（60x90） */
  :root{
    --myCardW: 60px;
    --myCardH: 90px;
    --myCardR: 10px;
  }
  .my-role{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }
  .action-card{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }
  .my-sweets{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }

  /* =========================
     ★ スイーツ一覧（ローカル表示）
     ========================= */
  .sweets-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; flex-direction:column;
    align-items:center; justify-content:flex-start;
    z-index:60;
    padding:16px;
    gap:12px;
    overflow:auto;
  }
  .sweets-backdrop.hidden{display:none;}
  .sweets-panel{
    width:min(760px, calc(100% - 32px));
    background:#fff;
    border:1px solid #ddd;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
    position:sticky;
    top:140px;
  }
  .sweets-panel-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .sweets-panel-title{
    font-weight:900;font-size:14px;
  }
  .sweets-panel-body{
    padding:12px;
    overflow:auto;
    max-height:min(70vh, 640px);
  }
  .sweets-grid{
    display:grid;
    gap:10px;
    justify-content:center;
    align-content:center;
  }
  .sweets-pick-card{
    width:90px; height:135px;
    border-radius:12px;
    border:1px solid #ddd;
    background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    overflow:hidden;
    position:relative;
    cursor:grab;
    user-select:none;
    touch-action:none;
    animation:pulseCardStrong 1.05s ease-in-out infinite;
    transform-origin:center;
  }
  .sweets-pick-card.restricted{
    animation:none;
    cursor:not-allowed;
    opacity:.55;
    filter:grayscale(.2);
  }
  .sweets-pick-card:active{cursor:grabbing;}
  .sweets-pick-card:hover{ animation:none; transform:scale(1.12); }
  .sweets-pick-card img{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    display:block;
    touch-action:none;
    pointer-events:none;
  }
  .sweets-pick-card.trial-added{
    border:2px solid #7dd3fc;
    box-shadow:0 10px 24px rgba(125,211,252,.35);
  }
  .sweets-pick-card .trial-added-note{
    position:absolute;
    left:50%;
    bottom:6px;
    transform:translateX(-50%);
    font-size:10px;
    font-weight:800;
    color:#fff;
    background:#38bdf8;
    border:1px solid #7dd3fc;
    border-radius:12px;
    padding:2px 2px;
    text-align:center;
    white-space:normal;
    line-height:1.2;
    max-width:96%;
    min-width:84%;
    overflow-wrap:break-word;
    z-index:2;
  }

  /* ★ スイーツドラッグ中の見た目 */
 .sweets-dragging{
    position:fixed !important;
    z-index:85 !important;
    pointer-events:none;
    animation:none !important;
  }
  .sweets-drop-zone{
    width:min(800px, calc(100% - 32px));
    min-height:200px;
    border:transparent;
    border-radius:14px;
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:transparent;
    text-align:center;
    padding:8px 12px;
    margin-top:130px;
  }
  .sweets-drop-zone.trial{
    border:2px dashed #7dd3fc;
    color:#0ea5e9;
    background:rgba(224,242,254,.65);
    margin-top:75px;
    width:min(220px, calc(100% - 32px));
    justify-content:center;
    text-align:center;
    position:relative;
  }
  .sweets-drop-zone.active{
    border-color:transparent;
    color:transparent;
    background:transparent;
  }
  .sweets-drop-zone.trial.active{
    border-color:#38bdf8;
    color:#0369a1;
    background:rgba(186,230,253,.9);
  }
  .sweets-drop-zone .trial-drop-preview{
    width:90px;
    height:135px;
    border-radius:12px;
    border:2px solid #7dd3fc;
    background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);

  }
  .sweets-drop-zone .trial-drop-preview img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }
  .sweets-backdrop.trial .sweets-panel{
    top:80px;
  }

  /* =========================
     ★ 投票チップ（自分の正体カードの下）
     ========================= */
/* 投票チップ（自分の正体カードの下） */
.vote-chip{
  width:var(--voteChipSize);
  height:var(--voteChipSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 10px 24px rgba(0,0,0,.18);
  flex:0 0 auto;
  cursor:grab;
  user-select:none;
  touch-action:none;
  position:relative;
  transition:transform .2s ease;
}
.vote-chip.bonus{
  margin-left:0;
}
.bonus-vote-active .action-card{
  pointer-events:none;
  animation:none !important;
}
.bonus-vote-active .action-card:hover{
  transform:none !important;
}
.bonus-vote-active .my-sweets,
.bonus-vote-active .sweets-deck,
.bonus-vote-active .sweets-deck-wrap,
.bonus-vote-active .sweets-pick-card,
.bonus-vote-active .vote-chip:not(.bonus){
  pointer-events:none;
}
.bonus-vote-active .sweets-deck{
  animation:none !important;
  transform:none !important;
}
.bonus-vote-active .sweets-deck.pulsing:hover{
  animation:none !important;
  transform:none !important;
}
.bonus-vote-active .vote-chip:not(.bonus){
  animation:none !important;
}
.bonus-vote-active .my-turn-free .action-card{
  animation:none !important;
}
/* ✅ 投票チップ専用：鼓動を弱める */
@keyframes pulseVoteChip {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.5); } /* ← ここが強さ（例：1.04〜1.10） */
  100% { transform: scale(1); }
}

@keyframes pulseRobVoteChip {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.6); }
  100% { transform: scale(1); }
}

.vote-chip.hidden{display:none;}
.vote-chip:active{cursor:grabbing;}
.vote-chip.pulsing{ animation:pulseVoteChip 1.05s ease-in-out infinite; }
.vote-chip.pulsing:hover{ animation:none; transform:scale(1.10); } /* ← hover拡大も投票専用に調整 */

body.rob-active .vote-stack{
  pointer-events:auto;
}
body.rob-active .vote-mini{
  animation:pulseRobVoteChip 1.05s ease-in-out infinite;
  cursor:grab;
}
body.rob-active .vote-mini:active{ cursor:grabbing; }
body.rob-active .vote-mini:hover{
  animation:none;
  transform:none;}


/* 既存の「V」文字は消す（デザイン統一） */
.vote-chip::after{ content:''; }


  .vote-dragging{
    position:fixed !important;
    z-index:85 !important;
    pointer-events:none;
    animation:none !important;
  }

  .roundpick-dragging{
    position:fixed !important;
    z-index:85 !important;
    pointer-events:none;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.35);
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    background:#fff center/cover no-repeat;
  }



  /* =========================
     ★★★ ここから PASS & ラウンド終了演出 ★★★
     ========================= */

  /* 右下：丸いPASSボタン（紫・白字） */
  .pass-round-btn{
    position:fixed;
    right:16px;
    bottom:16px;
    width:64px;
    height:64px;
    border-radius:50%;
    border:1px solid rgba(255,255,255,.25);
    background:#7c3aed;           /* 紫 */
    color:#fff;
    font-weight:900;
    letter-spacing:.06em;
    box-shadow:0 14px 34px rgba(0,0,0,.25);
    cursor:pointer;
    z-index:40;                  /* hostSettingsBtnより上でもOK */
    display:none;
    user-select:none;
  }
  .pass-round-btn.visible{display:grid; place-items:center;}
  .pass-round-btn:active{transform:scale(.98);}
  .pass-round-btn:disabled{opacity:.5; cursor:not-allowed; transform:none;}

  /* 収集アニメ用：中央に集まる裏カード */
  .collect-card{
    position:fixed;
    width:90px;
    height:135px;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.25);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    z-index:65;
    pointer-events:none;
    transform-origin:center;
  }

  /* 最終公開（複数） */
  .roundreveal-overlay{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);
    background:transparent;
    z-index:70;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:6px;
    pointer-events:none;
  }
  .roundreveal-overlay.hidden{display:none;}
  .roundreveal-row{
    display:flex;
    gap:30px;
    align-items:center;
    justify-content:center;
    flex-wrap:nowrap;          /* 折り返しなし */
    overflow:auto;
    padding:6px;
  }
  .roundreveal-card{
    width:min(240px, 32vw);
    aspect-ratio:2/3;
    border-radius:18px;
    border:none;
    box-shadow:none;
    background:transparent;
    overflow:hidden;
    flex:0 0 auto;
    transform:scale(1.02);
  }
  .roundreveal-card img{width:100%;height:100%;object-fit:cover;display:block;}

:root{
  --deckCardW: 28px;
  --deckCardH: 40px;
  --deckCardR: 7px;

  /* 投票チップ（自分/他人 共通） */
  /* 自分（ドラッグ用） */
  --voteChipSize: 22px;

  /* 他プレイヤーに乗る小さいやつ */
  --voteMiniSize: 14px;

  --voteChipFill: rgba(196, 181, 253, .92);
  --voteChipStroke: rgba(255,255,255,.95);
}

/* =========================
   ★★ 他プレイヤー：内側に「正体＋スイーツ」横並び（平行）
   - JSから --inX/--inY/--rotDeg を渡す
   ========================= */
.otherplayerscircle{ --inX:0px; --inY:0px; --outX:0px; --outY:0px; --rotDeg:0deg; }

/* タグ（外側へ） */
.player-tag.in-othercircle{
  position:absolute;
  left:50%; top:50%;
  transform:translate(-50%,-50%) translate(var(--outX), var(--outY));
}

/* 内側カード列（回転して「上が中心を向く」） */
.other-cards-row{
  position:absolute;
  left:50%; top:50%;
  transform:
    translate(-50%,-50%)
    translate(var(--inX), var(--inY))
    rotate(var(--rotDeg));
  display:flex;
  gap:8px;
  align-items:center;
  justify-content:center;
  pointer-events:none; /* 見た目専用（投票などにしたいなら外す） */
}

/* 正体ミニ（裏） */
.role-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swroleura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}

/* スイーツ枠（裏カード＋投票チップ重ね） */
.sweets-wrap{
  position:relative;
  width:calc(var(--deckCardW) + 20px);
  height:calc(var(--deckCardH) + 20px);
  border-radius:calc(var(--deckCardR) + 6px);
  border:transparent;
  background:rgba(255,255,255,.10);
  box-sizing:border-box;
  display:flex; align-items:center; justify-content:center;
  transition:transform .6s ease;
  --decidedMoveX: 0px;
  --decidedMoveY: 0px;
}

.sweets-wrap.empty{
  border-style:solid;
  border-color:transparent;
  background:transparent;
  opacity:1;
}
.my-sweets.empty{
  border-color:transparent;
  background:transparent;
  box-shadow:none;
}
.sweets-wrap.hint-ok{
  border-color:transparent;
  background: rgba(200, 200, 200, 0.3);
}
.sweets-wrap.hint-ng{
  border-color:rgba(239,68,68,.75);
  background: rgba(200, 200, 200, 0.3);
}
.my-sweets.hint-ok{
  border-color:transparent;
  background: rgba(200, 200, 200, 0.3);
}
.my-sweets.hint-ng{
  border-color:rgba(239,68,68,.75);
  background: rgba(200, 200, 200, 0.3);
}
.sweets-wrap.roundpick-candidate{
  animation:pulseSweetsDeck 1.05s ease-in-out infinite;
}
.sweets-wrap.roundpick-selectable{
  cursor:pointer;
}
.sweets-wrap.roundpick-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
@keyframes pulseSweetsPeek{
  0%{ transform:scale(1); }
  50%{ transform:scale(1.5); }
  100%{ transform:scale(1); }
}
.sweets-wrap.peek-selectable{
  cursor:pointer;
}
.sweets-wrap.peek-selectable .sweets-mini{
  animation:pulseSweetsPeek 1.5s ease-in-out infinite;
}
.sweets-wrap.peek-selectable:hover .sweets-mini{
  animation:none;
  transform:scale(1.12);
}
body.imprison-active .sweets-wrap.roundpick-candidate{
  animation:none;
}
body.imprison-active .sweets-wrap.roundpick-selectable:hover{
  animation:none;
  transform:none;
}
.sweets-wrap.swap-selectable{
  animation:pulseCardAccident  1.05s ease-in-out infinite;
  cursor:pointer;
}
.sweets-wrap.swap-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
.sweets-wrap.accident-selectable .sweets-mini{
  animation:pulseCardAccident 1.05s ease-in-out infinite;
  cursor:pointer;
}
.sweets-wrap.accident-selectable:hover .sweets-mini{
  animation:none;
  transform:scale(1.2);
}
 .sweets-wrap.swap-selected{
    border-color:rgba(251,146,60,.95);
    box-shadow:0 0 0 3px rgba(251,146,60,.75);
  }
  .sweets-wrap.swap-hidden,
  .sweets-wrap.swap-hidden .sweets-mini,
  .sweets-wrap.swap-hidden .vote-stack,
  .sweets-wrap.swap-hidden .advertise-number-tag,
  .my-sweets.swap-hidden,
  .my-sweets.swap-hidden img,
  .my-sweets.swap-hidden .advertise-number-tag,
  .selected-sweets-tag.swap-hidden,
  .selected-sweets-tag.swap-hidden .selected-sweets-card,
  .selected-sweets-tag.swap-hidden .sweets-number-tag,
  .selected-sweets-tag.swap-hidden .sweets-number-star,
  .selected-sweets-tag.swap-hidden .advertise-number-tag{
    visibility:hidden;
    opacity:0;
  }
.sweets-wrap.decided-move{
  transform:translate(var(--decidedMoveX), var(--decidedMoveY));
}
.sweets-wrap.decided-move.decided-static{
  transition:none;
}
.sweets-wrap.center-move-host{
  border-color:transparent;
  background:transparent;
}
.sweets-wrap.collect-hidden{
  border-color:transparent;
  background:transparent;
}
.sweets-wrap.collect-hidden .sweets-mini{
  opacity:0;
}

.sweets-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swsweetsura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  --centerMoveX: 0px;
  --centerMoveY: 0px;
}
.sweets-mini.hidden{display:none;}
.sweets-mini.center-move{
  transition:transform .6s ease;
  transform:translate(var(--centerMoveX), var(--centerMoveY));
}
.sweets-mini.center-move.center-static{
  transition:none;
}

.my-sweets.roundpick-candidate{
  animation:pulseCardStrong 1.05s ease-in-out infinite;
}
.my-sweets.roundpick-selectable{
  cursor:pointer;
}
.my-sweets.roundpick-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
body.imprison-active .my-sweets.roundpick-candidate{
  animation:none;
}
body.imprison-active .my-sweets.roundpick-selectable:hover{
  animation:none;
  transform:none;
}
.my-sweets.roundpick-selectable:hover ~ .vote-chip,
.my-sweets.roundpick-selectable:active ~ .vote-chip{
  transform:scale(1.12);
}
.my-sweets.swap-selectable{
  animation:pulseCard 1.05s ease-in-out infinite;
  cursor:pointer;
}
.my-sweets.swap-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
.my-sweets.accident-selectable{
  animation:pulseCardAccident 1.05s ease-in-out infinite;
  cursor:pointer;
}
.my-sweets.accident-selectable:hover{
  animation:none;
  transform:scale(1.2);
}
.my-sweets.swap-selected{
  box-shadow:0 0 0 3px rgba(251,146,60,.75);
}
.my-sweets.decided-move{
  transform:translateY(-30px);
  animation:sweetsDecidedMoveMy .6s ease;
}

/* 投票チップ（スイーツの右側に重ねる） */
.vote-stack{
  position:absolute;
  right:-22px;
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-wrap:wrap;
  width:calc(var(--voteMiniSize) * 2 + 6px); /* 2列 */
  gap:3px;
  justify-content:flex-start;
  align-items:center;
  pointer-events:none;
}

.selected-sweets-tag{
  position:absolute;
  left:50%;
  bottom:100%;
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  overflow:visible;
  --sweetsTagMoveY:-30px;
  transform:translate(-50%, var(--sweetsTagMoveY));
  animation:sweetsTagMove .6s ease;
  pointer-events:none;
}
.selected-sweets-tag.delayed-show{
  opacity:0;
  visibility:hidden;
}
.selected-sweets-tag.decided-static{
  animation:none;
}



.selected-sweets-tag.collect-hidden .selected-sweets-card{
  border-color:transparent;
  background:transparent;
  box-shadow:none;
}
.selected-sweets-tag.collect-hidden img{
  opacity:0;
}
.selected-sweets-tag.collect-hidden .sweets-number-tag{
  opacity:0;
}
.selected-sweets-tag.collect-hidden .advertise-number-tag{
  opacity:0;
}
.selected-sweets-card{
  position:relative;
  width:100%;
  height:100%;
  border-radius:inherit;
  border:1px solid rgba(0,0,0,.18);
  background:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  --centerMoveX: 0px;
  --centerMoveY: 0px;
}
.selected-sweets-card.center-move{
  transition:transform .6s ease;
  transform:translate(var(--centerMoveX), var(--centerMoveY));
}
.selected-sweets-card.center-move.center-static{
  transition:none;
}
.selected-sweets-card img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
  border-radius:inherit;

}
.selected-sweets-card .sweets-number-tag{
  position:absolute;
  right:9px;
  top:-12px;

  /* 少し大きくして余裕を作る */
  width:34px;
  height:34px;

  display:grid;
  place-items:center;

  font-weight:900;
  font-size:13px;
  line-height:1;
  color:#111;

  text-shadow:0 1px 0 rgba(255,255,255,.6);
}
.selected-sweets-card .sweets-number-star{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:0;
  pointer-events:none;
}
.selected-sweets-card .sweets-number-text{
  position:relative;
  z-index:1;
  transform:translateZ(0) translateY(-1px);
}


/* 下の手番バーだけ消して、右下PASSは残す */
#turnBar{
  display:none !important;
}
/* 投票ドロップのため：内側カード列はポインターを通す */
.other-cards-row{ pointer-events:auto; }

/* ドロップ判定したいのはスイーツ枠なので、ここも明示しておく */
.sweets-wrap{ pointer-events:auto; }


/* 自分のスイーツにも投票ミニを重ねるため */
.my-sweets{ position:relative; }

/* 自分スイーツ上の投票（右に重ね） */
.my-sweets .vote-stack{
  right:-22px;                 /* 少しだけ内側に寄せる（好みで調整OK） */
  top:10%;
  transform:translateY(-50%);
}
/* ★ 自分のスイーツ上の投票チップだけ「手元チップと同サイズ」にする */
.my-sweets .vote-stack{
  width:calc(var(--voteChipSize) * 2 + 6px); /* 2列レイアウトも同サイズ基準に */
}

.my-sweets .vote-stack .vote-mini{
  width:var(--voteChipSize);
  height:var(--voteChipSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 10px 24px rgba(0,0,0,.18);
}

/* =========================
   ★★ 選抜スイーツ：回収→シャッフル（中央）
   ========================= */
.sweets-shuffle-stage{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:160px;
  height:220px;
  z-index:70;
  pointer-events:none;
}
.sweets-shuffle-card{
  position:absolute;
  left:50%;
  top:50%;
  width:120px;
  height:170px;
  transform:translate(-50%,-50%);
  border-radius:12px;
  border:1px solid rgba(255,255,255,.25);
  box-shadow:0 16px 44px rgba(0,0,0,.35);
  background:center/cover no-repeat;
  will-change:transform, opacity;
}

/* =========================
   ★ 中央：リーダーボード（長方形 5:3.3）
   ========================= */
.leaderboard-board{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:min(120px, 78vw);
  aspect-ratio: 5 / 3.3;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.18);
  background:rgba(255,255,255,.18);
  box-shadow:0 10px 24px rgba(0,0,0,.12);
  overflow:hidden;
  pointer-events:none;
  z-index:4; /* play-circleより下/上は好みで */
}
.leaderboard-board.hidden{display:none;}
.leaderboard-board img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

/* play-circle を前面に（中央ボードの上に乗せる） */
.play-circle{ z-index:6; }
/* ✅ leaderboardより前面に出したいUIのレイヤーを上げる */
.otherplayerscircle{ z-index: 7; }   /* 他プレイヤーの円ごと前へ */
.player-tag{ z-index: 8; }          /* ネームタグ前へ */
.other-cards-row{ z-index: 8; }     /* 内側カード列も前へ */

/* 選抜スイーツ表示（selected card）をさらに前へ */
.selected-sweets-tag{ z-index: 9; }

/* チップ系も前へ（投票チップ/投票スタック） */
.vote-chip{ z-index: 9; }           /* 自分の投票チップ（念のため） */
.vote-stack{ z-index: 9; }          /* 付随する投票チップ群 */

/* ※ leaderboardは現状のままでもOK（z-index:4） */

/* =========================
   ★ 中央：ラウンドチップ枠（3つ横並び）
   - z-indexに頼らず、DOM順で前面化（leaderboardの後ろに置く）
   ========================= */
.round-chips{
  position:absolute;
  left:50%;
top:calc(50% - 6.5px);  
  transform:translate(-50%,-50%);
  display:flex;
  gap:10.5px;
  align-items:center;
  justify-content:center;
  pointer-events:none; /* クリック不要なら none（必要になったらautoに） */
}

.round-chip-slot{
  width:22px;
  height:22px;
  border-radius:50%;
  border:transparent;
  background:transparent;
  box-shadow:0 6px 14px rgba(0,0,0,.10) inset;
  position:relative;
  overflow:hidden;
}

.round-chip-slot::after{
  /* 今は目印（後で消してOK） */
  content: attr(data-round);
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  font-weight:900;
  font-size:10px;
  opacity:.55;
display:none;

}

.round-chip-img{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
  transform-origin:center;
}

.round-chip-img.hidden{ display:none; }

.round-chip-img.round-chip-pop{
  animation:round-chip-pop 260ms ease-out both;
}

@keyframes round-chip-pop{
  0%{ transform:scale(1.3); opacity:0; }
  55%{ transform:scale(0.94); opacity:1; }
  100%{ transform:scale(1); opacity:1; }
}


</style>
</head>
<body>

<header>
  <h1>スイーツワンダーリーグ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">

  <!-- ★ 中央：リーダーボード（人数で画像切替） -->
<div id="leaderboardBoard" class="leaderboard-board hidden" aria-hidden="true">
  <img id="leaderboardImg" alt="leaderboard" />

  <!-- ★ 中央：ラウンドチップ枠（R1/R2/R3）※leaderboardより後に置く＝前面に描画される -->
  <div id="roundChips" class="round-chips" aria-label="ラウンドチップ">
    <div class="round-chip-slot" data-round="1" aria-label="ラウンド1">
      <img class="round-chip-img hidden" alt="round1" />
    </div>
    <div class="round-chip-slot" data-round="2" aria-label="ラウンド2">
      <img class="round-chip-img hidden" alt="round2" />
    </div>
    <div class="round-chip-slot" data-round="3" aria-label="ラウンド3">
      <img class="round-chip-img hidden" alt="round3" />
    </div>
  </div>
</div>


      <div id="playCircle" class="play-circle">
        <div id="requiredSweetsTag" class="required-sweets-tag hidden">🍰0</div>
        <!-- ★ 中央：アクション山札（左）＋スイーツ山札（右） -->
        <div id="centerDecks" class="center-decks hidden" aria-hidden="false">
          <div id="actionDeckUI" class="action-deck hidden" aria-hidden="true">
            <div class="stack" aria-hidden="true">
              <div class="card c5"></div>
              <div class="card c4"></div>
              <div class="card c3"></div>
              <div class="card c2"></div>
              <div class="card c1"></div>
            </div>
            <div id="actionDeckCount" class="count">0</div>
          </div>

         <div class="sweets-deck-wrap">
            <div id="sweetsDeckMover" class="sweets-deck-mover">
              <div id="sweetsDeckUI" class="sweets-deck hidden" aria-label="スイーツ山札">
                <div class="stack" aria-hidden="true">
                  <div class="card c5"></div>
                  <div class="card c4"></div>
                  <div class="card c3"></div>
                  <div class="card c2"></div>
                  <div class="card c1"></div>
                </div>
                <div id="sweetsDeckCount" class="count">0</div>
              </div>
            </div>
            <div id="sweetsExcludedDeckMover" class="sweets-excluded-deck-mover">
              <div id="sweetsExcludedDeckUI" class="sweets-exclude-deck hidden" aria-label="スイーツ除外山札">
                <div class="stack" aria-hidden="true">
                  <div class="card c5"></div>
                  <div class="card c4"></div>
                  <div class="card c3"></div>
                  <div class="card c2"></div>
                  <div class="card c1"></div>
                </div>
                <div id="sweetsExcludedDeckCount" class="count">0</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>

      <!-- ★ ownarea -->
      <div class="my-area" id="myArea">
        <!-- ★ 受け取った指示カード（正体カードの左） -->
        <div id="myReceived" class="my-received-slot"></div>

        <!-- ★ 自分のスイーツ（正体カードの左・同サイズ） -->
        <div id="mySweets" class="my-sweets hidden"></div>

        <div class="my-role-stack">
          <div id="myRole" class="my-role hidden"></div>
          <div class="my-vote-slots" aria-label="投票チップスロット">
            <div id="myVoteSlotLeft" class="my-vote-slot" data-slot="left"></div>
            <div id="myVoteSlotRight" class="my-vote-slot" data-slot="right"></div>
          </div>
        </div>
        <div id="myHand" class="my-hand"></div>

        <!-- ★ 投票チップ（正体カードの下） -->
        <div id="myVoteChip" class="vote-chip hidden" aria-label="投票チップ"></div>
        <div id="myBonusVoteChip" class="vote-chip bonus hidden" aria-label="激推し投票チップ"></div>
      </div>
    </div>
  </div>
</main>

<!-- ★ 参加者：ホスト人数選択中ポップ -->
<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>
<div id="leaderPickPop" class="leader-pick-pop hidden">最多票の中からリーダーを選んでください。</div>
<div id="actionExplainPop" class="leader-pick-pop action-pop hidden"></div>
<div id="actionConfirmPop" class="leader-pick-pop action-pop hidden">
  <div id="actionConfirmText" class="action-pop-text"></div>
  <div class="action-pop-actions">
    <button id="actionConfirmYes" class="btn primary">はい</button>
    <button id="actionConfirmNo" class="btn">いいえ</button>
  </div>
</div>
<div id="scoutRevealOverlay" class="scout-reveal-overlay hidden">
  <div id="scoutRevealGrid" class="scout-reveal-grid"></div>
</div>
<div id="sweetsPeekOverlay" class="sweets-peek-overlay hidden">
  <div id="sweetsPeekCard" class="sweets-peek-card">
    <img id="sweetsPeekImg" alt="sweets peek" />
  </div>
</div>
<div id="rolePeekOverlay" class="sweets-peek-overlay hidden">
  <div id="rolePeekCard" class="sweets-peek-card">
    <img id="rolePeekImg" alt="role peek" />
  </div>
</div>
<div id="scoutCloseConfirmPop" class="leader-pick-pop action-pop hidden">
  <div class="action-pop-text">閉じてもいいですか。</div>
  <div class="action-pop-actions">
    <button id="scoutCloseYes" class="btn primary">はい</button>
  </div>
</div>
<div id="sweetsPeekCloseConfirmPop" class="leader-pick-pop action-pop hidden">
  <div class="action-pop-text">閉じてもいいですか。</div>
  <div class="action-pop-actions">
    <button id="sweetsPeekCloseYes" class="btn primary">はい</button>
  </div>
</div>
<div id="rolePeekCloseConfirmPop" class="leader-pick-pop action-pop hidden">
  <div class="action-pop-text">閉じてもいいですか。</div>
  <div class="action-pop-actions">
    <button id="rolePeekCloseYes" class="btn primary">はい</button>
  </div>
</div>

<!-- 着席ポップ -->
<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<!-- 既存プレイヤー追い出し確認ポップ -->
<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<!-- ホスト専用 設定ボタン（⚙） -->
<div id="actionDiscardZone" class="action-discard-zone hidden" aria-label="アクションカードを捨てる">🗑️</div>
<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<!-- ★ ヘルプボタン（？） -->
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<!-- ★ ヘルプ一覧ポップ -->
<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード・アクションカード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<!-- 設定ポップ（スタート＋リセット） -->
<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で正体カード＋アクションカード配布＋手番決定。<br>
    「リセット」で人数選択へ戻します（内容は後で）。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ★ ターン操作バー（既存） -->
<div id="turnBar" class="turn-bar hidden">
  <span id="turnBadge" class="turn-badge">TURN</span>
  <button id="btnPass" class="btn">パス</button>
  <button id="btnDrawSweets" class="btn" disabled>スイーツドロー（後で）</button>
  <button id="btnVote" class="btn" disabled>投票（後で）</button>
</div>

<!-- ★ 右下：丸いPASSボタン（ラウンド用） -->
<button id="passRoundBtn" class="pass-round-btn" type="button" aria-label="PASS">PASS</button>

<!-- ★ 中央拡大表示（全員、1秒） -->
<div id="revealOverlay" class="reveal-overlay hidden">
  <div class="reveal-card">
    <img id="revealImg" alt="" />
    <div id="revealLabel" class="label"></div>
    <div id="revealEffectFrame" class="effect-frame hidden">
      <div id="revealEffect" class="effect-text"></div>
    </div>
  </div>
</div>

<!-- ★ 自分のアクションカード拡大（タップで表示） -->
<div id="actionZoomOverlay" class="reveal-overlay action-zoom-overlay hidden">
  <div class="action-zoom-card" role="dialog" aria-modal="true" aria-label="アクションカード">
    <img id="actionZoomImg" alt="" />
    <div id="actionZoomEffectFrame" class="effect-frame hidden">
      <div id="actionZoomEffect" class="effect-text"></div>
    </div>
  </div>
</div>


<!-- ★ スイーツ一覧（ローカル表示） -->
<div id="sweetsBackdrop" class="sweets-backdrop hidden">
  <div class="sweets-panel" role="dialog" aria-modal="true" aria-label="スイーツ一覧">
    <div class="sweets-panel-header">
      <div class="sweets-panel-title">スイーツ（下にドラッグ）</div>
      <button id="btnSweetsClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="sweets-panel-body">
      <div id="sweetsGrid" class="sweets-grid"></div>
    </div>
  </div>
  <div id="sweetsDropZone" class="sweets-drop-zone" aria-label="スイーツ獲得エリア">
    ここにカードを出すと獲得
  </div>
</div>

<!-- ★ ラウンド終了：公開（複数） -->
<div id="roundRevealOverlay" class="roundreveal-overlay hidden" aria-hidden="true">
  <div id="roundRevealRow" class="roundreveal-row"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove,
  push, onChildAdded, serverTimestamp
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* =========================
   Firebase
   ========================= */
const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};
const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

// ★ userId をタブ単位で固定（タブごとに別ID）
const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

/* =========================
   状態
   ========================= */
const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  turnEnding: false,
  passReadyBlockedTurnNo: null,
  lastPassEligible: false,
  prevTurnNo: null,

  room: {},
  hands: {},
  roles: {},
  game: {},
  turn: null,
};
let latestPlayers = [];
const TAG_CHIP_STYLES = [
  'tag-chip-style-1',
  'tag-chip-style-2',
  'tag-chip-style-3',
  'tag-chip-style-4',
  'tag-chip-style-5',
  'tag-chip-style-6',
  'tag-chip-style-7',
  'tag-chip-style-8',
];
const collectedSweetsHidden = new Set();
let miniShuffleRunning = false;
let miniShuffleToken = 0;
let sweetsExcludeAnimating = false;
let sweetsDeckCountOverride = null;
let sweetsExcludedCountOverride = null;
let sweetsOverrideClearTimer = null;
let currentGameSessionId = null;
let eventsSubscribedAt = 0;
let turnBlockedByShuffle = false;
let leaderPickApplyTimer = null;
let leaderPickApplyKey = null;
let lastLeaderSeat = null;
let lastRoundNo = null;
let actionSelection = null;
let sweetsExcludedFocusActive = null;
let sweetsGridCols = 0;
let mySweetsSelectHandlersBound = false;
const ADVERTISE_PULSE_DURATION_MS = 1400;
const advertisedPulseUids = new Set();
const advertisedStarReadyUids = new Set();
const advertisedStarHiddenUids = new Set();
const advertisedPulseTimers = new Map();
const advertisedStarHideTimers = new Map();
const advertisedKeyByUid = new Map();
const activeWiretapArrows = new Map();
/* =========================
   DOM
   ========================= */
const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');
const leaderPickPop = document.getElementById('leaderPickPop');
const actionExplainPop = document.getElementById('actionExplainPop');
const actionConfirmPop = document.getElementById('actionConfirmPop');
const actionConfirmText = document.getElementById('actionConfirmText');
const actionConfirmYes = document.getElementById('actionConfirmYes');
const actionConfirmNo = document.getElementById('actionConfirmNo');
const scoutRevealOverlay = document.getElementById('scoutRevealOverlay');
const scoutRevealGrid = document.getElementById('scoutRevealGrid');
const scoutCloseConfirmPop = document.getElementById('scoutCloseConfirmPop');
const scoutCloseYes = document.getElementById('scoutCloseYes');
const sweetsPeekOverlay = document.getElementById('sweetsPeekOverlay');
const sweetsPeekCard = document.getElementById('sweetsPeekCard');
const sweetsPeekImg = document.getElementById('sweetsPeekImg');
const sweetsPeekCloseConfirmPop = document.getElementById('sweetsPeekCloseConfirmPop');
const sweetsPeekCloseYes = document.getElementById('sweetsPeekCloseYes');
const rolePeekOverlay = document.getElementById('rolePeekOverlay');
const rolePeekCard = document.getElementById('rolePeekCard');
const rolePeekImg = document.getElementById('rolePeekImg');
const rolePeekCloseConfirmPop = document.getElementById('rolePeekCloseConfirmPop');
const rolePeekCloseYes = document.getElementById('rolePeekCloseYes');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const playCircleEl = document.getElementById('playCircle');
const myHandEl = document.getElementById('myHand');
const myRoleEl = document.getElementById('myRole');
const myReceivedEl = document.getElementById('myReceived');
const mySweetsEl = document.getElementById('mySweets');
const myAreaEl = document.getElementById('myArea');
const myVoteChipEl = document.getElementById('myVoteChip');
const myBonusVoteChipEl = document.getElementById('myBonusVoteChip');
const myVoteSlotLeftEl = document.getElementById('myVoteSlotLeft');
const myVoteSlotRightEl = document.getElementById('myVoteSlotRight');
const leaderboardBoardEl = document.getElementById('leaderboardBoard');
const leaderboardImgEl   = document.getElementById('leaderboardImg');
const actionDiscardZone = document.getElementById('actionDiscardZone');

const centerDecksEl = document.getElementById('centerDecks');
const requiredSweetsTagEl = document.getElementById('requiredSweetsTag');

/* ✅ 追加：ラウンドチップ（R1/R2/R3） */
const roundChipsEl = document.getElementById('roundChips');
const roundChipImgEls = Array.from(document.querySelectorAll('#roundChips .round-chip-img'));


/* 中央の山札UI */
const actionDeckUI = document.getElementById('actionDeckUI');
const actionDeckCountEl = document.getElementById('actionDeckCount');
const sweetsDeckMover = document.getElementById('sweetsDeckMover');
const sweetsDeckUI = document.getElementById('sweetsDeckUI');
const sweetsDeckCountEl = document.getElementById('sweetsDeckCount');
const sweetsExcludedDeckMover = document.getElementById('sweetsExcludedDeckMover');
const sweetsExcludedDeckUI = document.getElementById('sweetsExcludedDeckUI');
const sweetsExcludedDeckCountEl = document.getElementById('sweetsExcludedDeckCount');
let sweetsDeckReturnPending = false;
let sweetsDeckReturnRaf = null;
let sweetsExcludedDeckReturnPending = false;
let sweetsExcludedDeckReturnRaf = null;


/* スイーツ一覧（ローカル） */
const sweetsBackdrop = document.getElementById('sweetsBackdrop');
const sweetsDropZone = document.getElementById('sweetsDropZone');
const btnSweetsClose = document.getElementById('btnSweetsClose');
const sweetsGrid = document.getElementById('sweetsGrid');
const sweetsPanelTitleEl = sweetsBackdrop?.querySelector('.sweets-panel-title');
const sweetsPanelBodyEl = sweetsBackdrop?.querySelector('.sweets-panel-body');
const sweetsPanelDefaultTitle = sweetsPanelTitleEl?.textContent?.trim() || 'スイーツ（下にドラッグ）';
const sweetsDropZoneDefaultText = sweetsDropZone?.textContent?.trim() || 'ここにカードを出すと獲得';

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

/* ヘルプ */
const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

/* ターン操作バー */
const turnBar = document.getElementById('turnBar');
const turnBadge = document.getElementById('turnBadge');
const btnPass = document.getElementById('btnPass');
const btnDrawSweets = document.getElementById('btnDrawSweets');
const btnVote = document.getElementById('btnVote');

/* 右下PASS（ラウンド用） */
const passRoundBtn = document.getElementById('passRoundBtn');

/* ラウンド公開（複数） */
const roundRevealOverlay = document.getElementById('roundRevealOverlay');
const roundRevealRow = document.getElementById('roundRevealRow');

/* 中央拡大（単体） */
const revealOverlay = document.getElementById('revealOverlay');
const revealImg = document.getElementById('revealImg');
const revealLabel = document.getElementById('revealLabel');
const revealEffectFrame = document.getElementById('revealEffectFrame');
const revealEffect = document.getElementById('revealEffect');

/* 自分のアクションカード拡大 */
const actionZoomOverlay = document.getElementById('actionZoomOverlay');
const actionZoomImg = document.getElementById('actionZoomImg');
const actionZoomEffectFrame = document.getElementById('actionZoomEffectFrame');
const actionZoomEffect = document.getElementById('actionZoomEffect');

/* =========================
   ユーティリティ
   ========================= */
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}
function shuffle(arr){
  const a = [...arr];
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function now(){ return Date.now(); }

/* ✅ 追加：勝利点テーブル（人数×ラウンド） */
function getRoundWinThreshold(playerCount, roundNo){
  const r = clamp(roundNo ?? 1, 1, 3);
  if(playerCount <= 4)  return [8,10,12][r-1];
  if(playerCount <= 6)  return [12,14,16][r-1];
  return [16,18,20][r-1]; // 7〜8人想定
}

/* ✅ 追加：選ばれたスイーツ合計点（cards配列のvalue合計） */
function calcSweetsTotalPoints(cards){
  const arr = Array.isArray(cards) ? cards : [];
  return arr.reduce((sum, c) => {
    const v =
      (c && typeof c.value === 'number') ? c.value :
      (c && typeof c.name === 'string') ? (parseInt(c.name, 10) || 0) :
      0;
    return sum + v;
  }, 0);
}

/* ✅ 追加：roundchip表示（game.roundChipsを反映） */
function renderRoundChipsFromGame(){
  if(!roundChipImgEls || !roundChipImgEls.length) return;
  const chips = (state.game && typeof state.game === 'object' && state.game.roundChips) ? state.game.roundChips : {};
  roundChipImgEls.forEach((img, idx) => {
    const r = String(idx + 1);
    const src = chips?.[r] || chips?.[idx + 1] || null; // 数字キー/文字キー両対応
    const wasHidden = img.classList.contains('hidden');
    const prevSrc = img.dataset.src || '';
    if(src){
      img.src = src;
      img.classList.remove('hidden');
      img.dataset.src = src;
      if(wasHidden || prevSrc !== src){
        img.classList.remove('round-chip-pop');
        requestAnimationFrame(() => {
          img.classList.add('round-chip-pop');
        });
      }
    }else{
      img.removeAttribute('src');
      img.classList.add('hidden');
      img.classList.remove('round-chip-pop');
      delete img.dataset.src;
    }
  });
}



const roundRevealState = {
  started: false,
  finished: false,
  startedAt: null,
  finishedAt: null,
};

function resetRoundRevealState(){
  roundRevealState.started = false;
  roundRevealState.finished = false;
  roundRevealState.startedAt = null;
  roundRevealState.finishedAt = null;
}

function markRoundRevealStarted(){
  roundRevealState.started = true;
  roundRevealState.startedAt = now();
  roundRevealState.finished = false;
  roundRevealState.finishedAt = null;
}

function markRoundRevealFinished(){
  roundRevealState.finished = true;
  roundRevealState.finishedAt = now();
}

async function waitForRoundRevealCompletion(timeoutMs = 10000){
  const start = now();
  while(true){
    if(roundRevealState.started && roundRevealState.finished) return true;
    if(timeoutMs && now() - start > timeoutMs) return false;
    await sleep(50);
  }
}

function resetLocalGameEffects(){
  stopRoundEndFx();
  resetRoundRevealState();
  resetCollectedSweetsHiddenCache();
  centerMoveOffsetByKey.clear();
  clearAdvertiseLocalState();

  miniShuffleToken += 1;
  miniShuffleRunning = false;
  sweetsExcludeAnimating = false;
  turnBlockedByShuffle = false;

  revealOverlay.classList.add('hidden');
  revealOwnerId = null;

  clearActionSelection();

  if(sweetsOverrideClearTimer){
    clearTimeout(sweetsOverrideClearTimer);
    sweetsOverrideClearTimer = null;
  }
  sweetsDeckCountOverride = null;
  sweetsExcludedCountOverride = null;

  document.querySelectorAll('.sweets-shuffle-stage, .sweets-move-card, .collect-card')
    .forEach(el => el.remove());

  roundRevealRow.innerHTML = '';
  roundRevealOverlay.classList.add('hidden');

  updateActionDeckUI();
  updateSweetsDeckUI();
}


function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function setLeaderboardImageBase(base){
  if(!leaderboardImgEl) return;
  // 既定は .jpg → ダメなら .png → .webp
  leaderboardImgEl.dataset.base = base;
  leaderboardImgEl.dataset.try = 'jpg';
  leaderboardImgEl.src = `${base}.jpg`;
}
if (leaderboardImgEl){
  leaderboardImgEl.addEventListener('error', () => {
    const base = leaderboardImgEl.dataset.base || '';
    const tried = leaderboardImgEl.dataset.try || 'jpg';
    if(!base) return;

    if(tried === 'jpg'){
      leaderboardImgEl.dataset.try = 'png';
      leaderboardImgEl.src = `${base}.png`;
      return;
    }
    if(tried === 'png'){
      leaderboardImgEl.dataset.try = 'webp';
      leaderboardImgEl.src = `${base}.webp`;
      return;
    }
    // ここまで来たら諦めて非表示（無限エラー防止）
    leaderboardBoardEl?.classList.add('hidden');
  });
}

function updateLeaderboardBoardByPlayerCount(n){
  if(!leaderboardBoardEl || !leaderboardImgEl) return;

  let base = null;
  if(n >= 1 && n <= 4) base = 'swleaderboard1';
  else if(n >= 5 && n <= 6) base = 'swleaderboard2';
  else if(n >= 7 && n <= 8) base = 'swleaderboard3';

  if(!base){
    leaderboardBoardEl.classList.add('hidden');
    leaderboardBoardEl.setAttribute('aria-hidden','true');
    return;
  }

  leaderboardBoardEl.classList.remove('hidden');
  leaderboardBoardEl.setAttribute('aria-hidden','false');

  // 同じbaseなら張り替えない
  if(leaderboardImgEl.dataset.base !== base){
    setLeaderboardImageBase(base);
  }
}


/* =========================
   ★ 中央：アクション山札UI
   ========================= */
function updateActionDeckUI(){
  const deck = state.room?.decks?.action;
  const count = Array.isArray(deck) ? deck.length : 0;

  const started = !!state.room?.gameStarted;
  centerDecksEl.classList.toggle('hidden', !started);

  actionDeckUI.classList.toggle('hidden', !started);
  actionDeckCountEl.textContent = String(count);

  const stackN =
    count >= 20 ? 5 :
    count >= 12 ? 4 :
    count >= 6  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = actionDeckUI.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

/* =========================
   ★ 中央：スイーツ山札UI（残り枚数/山札感/鼓動）
   ========================= */
function getMySweetsCard(){
  const myData = state.hands?.[state.userId];
  const arr = myData?.sweets;
  if(Array.isArray(arr) && arr.length) return arr[0];
  return null;
}
function hasSweets(){
  return !!getMySweetsCard();
}
function clearSweetsCountOverridesIfSynced(liveCount, liveExcluded){
  if(sweetsDeckCountOverride === null && sweetsExcludedCountOverride === null) return;
  if(sweetsDeckCountOverride === liveCount && sweetsExcludedCountOverride === liveExcluded){
    sweetsDeckCountOverride = null;
    sweetsExcludedCountOverride = null;
    if(sweetsOverrideClearTimer){
      clearTimeout(sweetsOverrideClearTimer);
      sweetsOverrideClearTimer = null;
    }
  }
}
function setSweetsCountOverrides(deckCount, excludedCount, autoClearMs = 0){
  sweetsDeckCountOverride = deckCount;
  sweetsExcludedCountOverride = excludedCount;
  if(sweetsOverrideClearTimer){
    clearTimeout(sweetsOverrideClearTimer);
    sweetsOverrideClearTimer = null;
  }
  if(autoClearMs > 0){
    sweetsOverrideClearTimer = setTimeout(() => {
      sweetsDeckCountOverride = null;
      sweetsExcludedCountOverride = null;
      sweetsOverrideClearTimer = null;
      updateSweetsDeckUI();
    }, autoClearMs);
  }
}
function updateDeckStackUI(deckEl, count){
  if(!deckEl) return;
  const stackN =
    count >= 10 ? 5 :
    count >= 8  ? 4 :
    count >= 5  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = deckEl.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

function updateSweetsDeckUI(){
  const deck = state.room?.decks?.sweets;
  const excludedDeck = state.room?.decks?.sweetsExcluded;
  const liveCount = Array.isArray(deck) ? deck.length : 0;
  const liveExcluded = Array.isArray(excludedDeck) ? excludedDeck.length : 0;

  clearSweetsCountOverridesIfSynced(liveCount, liveExcluded);

  const count = sweetsDeckCountOverride ?? liveCount;
  const excludedCount = sweetsExcludedCountOverride ?? liveExcluded;


  const started = !!state.room?.gameStarted;
  centerDecksEl.classList.toggle('hidden', !started);

  sweetsDeckUI.classList.toggle('hidden', !started || miniShuffleRunning);
  sweetsExcludedDeckUI.classList.toggle('hidden', !started || miniShuffleRunning || (!sweetsExcludeAnimating && excludedCount <= 0));
  sweetsDeckCountEl.textContent = String(count);

 sweetsExcludedDeckCountEl.textContent = String(excludedCount);

  updateDeckStackUI(sweetsDeckUI, count);
  updateDeckStackUI(sweetsExcludedDeckUI, excludedCount);


  const instructionNames = getActiveInstructionNames();
  const sweetsAllowed = instructionNames.has('応援') || instructionNames.has('脅迫') || instructionNames.size === 0;
  const trialActive = actionSelection?.type === 'trial' && actionSelection.phase === 'draw';
  const pulsing = isMyTurn() && !hasSweets() && sweetsAllowed && !isActionSelectionActive();
  sweetsDeckUI.classList.toggle('pulsing', pulsing && !trialActive);
  sweetsDeckUI.classList.toggle('trial-pulsing', trialActive);
  const inspirationActive = actionSelection?.type === 'inspiration' && actionSelection.phase === 'select';
  const excludedPulse = inspirationActive && excludedCount > 0;
  sweetsExcludedDeckUI.classList.toggle('pulsing', excludedPulse);
  sweetsExcludedDeckUI.classList.toggle('selectable', excludedPulse);
}

function getSweetsDeckFocus(){
  const focus = state.game?.sweetsDeckFocus;
  if(!focus || typeof focus !== 'object') return null;
  if(!focus.uid || !focus.active) return null;
  return focus;
}

function getSweetsExcludedDeckFocus(){
  const focus = state.game?.sweetsExcludedFocus;
  if(!focus || typeof focus !== 'object') return null;
  if(!focus.uid || !focus.active) return null;
  return focus;
}

function updateSweetsDeckRelocation(){
  if(!sweetsDeckMover || !sweetsDeckUI) return;
  const focus = getSweetsDeckFocus();
  const shouldRelocate = !!(focus && focus.uid && focus.uid !== state.userId);
  if(shouldRelocate){
    sweetsDeckReturnPending = false;
    cancelSweetsDeckReturn();
  }
  if(sweetsDeckUI.classList.contains('hidden')){
    sweetsDeckMover.classList.toggle('relocating', shouldRelocate);
    if(!shouldRelocate){
      sweetsDeckReturnPending = true;
    }
    return;
  }
  if(sweetsDeckReturnPending && !shouldRelocate){
    sweetsDeckReturnPending = false;
    sweetsDeckMover.classList.remove('relocating');
    scheduleSweetsDeckReturn();
    return;
  }
  if(!shouldRelocate){
    sweetsDeckMover.classList.remove('relocating');
    scheduleSweetsDeckReturn();
    return;
  }

  const sweetsWrap = document.querySelector(`.sweets-wrap[data-sweets-uid="${focus.uid}"]`);
  const fallbackTag = document.querySelector(`.player-tag[data-uid="${focus.uid}"]`);
  const targetEl = sweetsWrap || fallbackTag;
  if(!targetEl){
    sweetsDeckMover.classList.remove('relocating');
    setSweetsDeckMoverTransform('translate(0px, 0px)');
    return;
  }

  const baseRect = sweetsDeckMover.parentElement?.getBoundingClientRect?.();
  const targetRect = targetEl.getBoundingClientRect();
  if(!baseRect || !baseRect.width || !baseRect.height || !targetRect.width || !targetRect.height) return;

  const targetX = targetRect.left + targetRect.width / 2;
  const targetY = targetRect.top + targetRect.height / 2;
  const deckCenterX = baseRect.left + baseRect.width / 2;
  const deckCenterY = baseRect.top + baseRect.height / 2;

  const moveX = targetX - deckCenterX;
  const moveY = targetY - deckCenterY;

  sweetsDeckMover.classList.add('relocating');
  setSweetsDeckMoverTransform(`translate(${moveX}px, ${moveY}px)`);
}

function updateSweetsExcludedDeckRelocation(){
  if(!sweetsExcludedDeckMover || !sweetsExcludedDeckUI) return;
  const focus = getSweetsExcludedDeckFocus();
  const shouldRelocate = !!(focus && focus.uid && focus.uid !== state.userId);
  if(shouldRelocate){
    sweetsExcludedDeckReturnPending = false;
    cancelSweetsExcludedDeckReturn();
  }
  if(sweetsExcludedDeckUI.classList.contains('hidden')){
    sweetsExcludedDeckMover.classList.toggle('relocating', shouldRelocate);
    if(!shouldRelocate){
      sweetsExcludedDeckReturnPending = true;
    }
    return;
  }
  if(sweetsExcludedDeckReturnPending && !shouldRelocate){
    sweetsExcludedDeckReturnPending = false;
    sweetsExcludedDeckMover.classList.remove('relocating');
    scheduleSweetsExcludedDeckReturn();
    return;
  }
  if(!shouldRelocate){
    sweetsExcludedDeckMover.classList.remove('relocating');
    scheduleSweetsExcludedDeckReturn();
    return;
  }

  const sweetsWrap = document.querySelector(`.sweets-wrap[data-sweets-uid="${focus.uid}"]`);
  if(!sweetsWrap) return;

  const baseRect = getMoverBaseRect(sweetsExcludedDeckMover);
  const targetRect = sweetsWrap.getBoundingClientRect();
  if(!baseRect || !baseRect.width || !baseRect.height || !targetRect.width || !targetRect.height) return;

  const targetX = targetRect.left + targetRect.width / 2;
  const targetY = targetRect.top + targetRect.height / 2;
  const deckCenterX = baseRect.left + baseRect.width / 2;
  const deckCenterY = baseRect.top + baseRect.height / 2;

  const moveX = targetX - deckCenterX;
  const moveY = targetY - deckCenterY;

  sweetsExcludedDeckMover.classList.add('relocating');
  setSweetsExcludedDeckMoverTransform(`translate(${moveX}px, ${moveY}px)`);
}

function getMoverBaseRect(el){
  if(!el) return null;
  const rect = el.getBoundingClientRect();
  if(!rect || !rect.width || !rect.height) return null;
  const { x: offsetX, y: offsetY } = getElementTranslate(el);
  return {
    left: rect.left - offsetX,
    top: rect.top - offsetY,
    right: rect.right - offsetX,
    bottom: rect.bottom - offsetY,
    width: rect.width,
    height: rect.height,
  };
}

function getElementTranslate(el){
  const style = getComputedStyle(el);
  const transform = style.transform;
  if(!transform || transform === 'none') return { x: 0, y: 0 };
  const matrixMatch = transform.match(/matrix3d\(([^)]+)\)/) || transform.match(/matrix\(([^)]+)\)/);
  if(!matrixMatch) return { x: 0, y: 0 };
  const values = matrixMatch[1].split(',').map((value) => parseFloat(value.trim()));
  if(values.length === 16){
    return { x: values[12] || 0, y: values[13] || 0 };
  }
  if(values.length === 6){
    return { x: values[4] || 0, y: values[5] || 0 };
  }
  return { x: 0, y: 0 };
}

function setSweetsDeckMoverTransform(value){
  if(!sweetsDeckMover) return;
  if(sweetsDeckMover.style.transform === value) return;
  requestAnimationFrame(() => {
    if(sweetsDeckMover.style.transform === value) return;
    sweetsDeckMover.style.transform = value;
  });
}

function setSweetsExcludedDeckMoverTransform(value){
  if(!sweetsExcludedDeckMover) return;
  if(sweetsExcludedDeckMover.style.transform === value) return;
  requestAnimationFrame(() => {
    if(sweetsExcludedDeckMover.style.transform === value) return;
    sweetsExcludedDeckMover.style.transform = value;
  });
}

function scheduleSweetsDeckReturn(){
  if(!sweetsDeckMover) return;
  if(sweetsDeckReturnRaf) return;
  sweetsDeckReturnRaf = requestAnimationFrame(() => {
    sweetsDeckReturnRaf = requestAnimationFrame(() => {
      sweetsDeckReturnRaf = null;
      const value = 'translate(0px, 0px)';
      if(sweetsDeckMover.style.transform === value) return;
      sweetsDeckMover.style.transform = value;
    });
  });
}

function scheduleSweetsExcludedDeckReturn(){
  if(!sweetsExcludedDeckMover) return;
  if(sweetsExcludedDeckReturnRaf) return;
  sweetsExcludedDeckReturnRaf = requestAnimationFrame(() => {
    sweetsExcludedDeckReturnRaf = requestAnimationFrame(() => {
      sweetsExcludedDeckReturnRaf = null;
      const value = 'translate(0px, 0px)';
      if(sweetsExcludedDeckMover.style.transform === value) return;
      sweetsExcludedDeckMover.style.transform = value;
    });
  });
}

function cancelSweetsDeckReturn(){
  if(!sweetsDeckReturnRaf) return;
  cancelAnimationFrame(sweetsDeckReturnRaf);
  sweetsDeckReturnRaf = null;
}

function cancelSweetsExcludedDeckReturn(){
  if(!sweetsExcludedDeckReturnRaf) return;
  cancelAnimationFrame(sweetsExcludedDeckReturnRaf);
  sweetsExcludedDeckReturnRaf = null;
}

function getRequiredSweetsCount(){
  const nPlayers = latestPlayers.length;
  if(nPlayers <= 0) return 0;
  const baseNeed = requiredPickCountByPlayers(nPlayers);
  const rp = getRoundPick();
  const remaining = Number(rp?.need ?? NaN);
  if(rp?.phase === 'choose' && Number.isFinite(remaining) && remaining > 0){
    return remaining;
  }
  return baseNeed;
}

function updateRequiredSweetsTag(){
  if(!requiredSweetsTagEl) return;
  const started = !!state.room?.gameStarted;
  const hasPlayers = latestPlayers.length > 0;
  requiredSweetsTagEl.classList.toggle('hidden', !(started && hasPlayers));
  if(!(started && hasPlayers)) return;
  const count = getRequiredSweetsCount();
  requiredSweetsTagEl.textContent = `🍰${count}`;
}


/* =========================
   ヘルプ（正体カード）
   ========================= */
function roleToHelp(role){
  if(role === 'usakoma'){
    return { name:"うさこま", img:"swsweetsurakoma.jpg", text:"（説明は後で）" };
  }
  if(role === 'uragiri'){
    return { name:"裏切り者", img:"swsweetsuragiri.jpg", text:"（説明は後で）" };
  }
  return { name:"不明", img:"swroleura.jpg", text:"" };
}
function renderHelpList(){
  helpBody.innerHTML = '';
  const list = [
    { name:"うさこま", img:"swsweetsurakoma.jpg", text:"（説明は後で）" },
    { name:"裏切り者", img:"swsweetsuragiri.jpg", text:"（説明は後で）" },
  ];
  list.forEach((r) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    const img = document.createElement('img');
    img.src = r.img;
    img.alt = r.name;
    card.appendChild(img);

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;

   row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });

  const divider = document.createElement('div');
  divider.className = 'help-divider';
  helpBody.appendChild(divider);

  const actionTitle = document.createElement('div');
  actionTitle.className = 'help-section-title';
  actionTitle.textContent = 'アクションカード';
  helpBody.appendChild(actionTitle);

  const actionGrid = document.createElement('div');
  actionGrid.className = 'help-action-grid';
  const actionNames = [
    '監禁',
    '盗聴',
    '世代交代',
    '宣伝',
    '強奪',
    '偵察',
    'ひらめき',
    '仕込み',
    '交換',
    '試行錯誤',
    '事故',
    '激推し',
  ];
  actionNames.forEach((name) => {
    const card = document.createElement('div');
    card.className = 'action-card';

    const img = document.createElement('img');
    img.className = 'card-img';
    img.src = cardNameToImg(name);
    img.alt = name;

    const effectFrame = document.createElement('div');
    effectFrame.className = 'effect-frame';

    const effectText = document.createElement('div');
    effectText.className = 'effect-text';
    effectText.textContent = getActionEffectText(name);

    effectFrame.appendChild(effectText);
    card.appendChild(img);
    card.appendChild(effectFrame);
    actionGrid.appendChild(card);
  });
  helpBody.appendChild(actionGrid);
}

function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

/* =========================
   Seat 復元
   ========================= */
async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

/* =========================
   subscribe
   ========================= */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();

    updateActionDeckUI();
    updateSweetsDeckUI();
    updateRequiredSweetsTag();
    renderHands();
    renderMyVoteChip();
renderMySweetsVoteStack();
    updatePassRoundBtn();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex),
        tagChipStyle: t.tagChipStyle || null,
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
updateLeaderboardBoardByPlayerCount(players.length); 
    updatePassRoundBtn();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
    updatePassRoundBtn();
  });
}
function subscribeRoles(){
  const rolesRef = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderHands();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    const prevLeaderSeat = state.turn?.leaderSeat ?? null;
    state.game = snap.val() || {};
    state.turn = state.game.turn || null;
    state.turnEnding = false;
    const nextRoundNo = (typeof state.game?.roundNo === 'number') ? state.game.roundNo : null;
    const nextSessionId = state.game?.sessionId || null;
    const sessionChanged = nextSessionId !== currentGameSessionId;
    if(sessionChanged){
      resetLocalGameEffects();
      currentGameSessionId = nextSessionId;
    } else {
      resetCollectedSweetsHiddenCache();
    }
    if(lastRoundNo !== null && nextRoundNo !== null && lastRoundNo !== nextRoundNo){
      clearAdvertiseLocalState();
    }
    lastRoundNo = nextRoundNo;
    syncPassTurnState();
    updateTurnUI();
    renderMyRole();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    renderRoundChipsFromGame();
    syncAdvertiseEffects();

    // ★ ホスト：全員PASSになったらラウンド終了処理へ
    if(state.isHost){
      maybeHostStartRoundEndFlow().catch(()=>{});
      maybeHostFireRoundRevealAfterLeaderPick().catch(()=>{});
      maybeHostApplyLeaderPick();
    }
    // ★ リーダー選択UI更新（同票解決）
    updateRoundPickUI();
    updateLeaderPickUI();
    updatePassRoundBtn();

    const nextLeaderSeat = state.turn?.leaderSeat ?? null;
    if(prevLeaderSeat !== null && nextLeaderSeat !== null && prevLeaderSeat !== nextLeaderSeat){
      requestAnimationFrame(() => animateLeaderChipMove(prevLeaderSeat, nextLeaderSeat));
    }
    lastLeaderSeat = nextLeaderSeat;
  });
}
function subscribeEvents(){
  const evRef = ref(db, `rooms/${state.roomCode}/events`);
  eventsSubscribedAt = now();
 onChildAdded(evRef, async snap => {
    const key = snap.key;
    const ev = snap.val();
    if(!ev) return;
    const expectedSessionId = state.game?.sessionId || currentGameSessionId || null;
    if(ev.sessionId){
      if(expectedSessionId && ev.sessionId !== expectedSessionId) return;
      if(!currentGameSessionId) currentGameSessionId = ev.sessionId;
    }
    if(!expectedSessionId && !currentGameSessionId) return;
   const isStaleEvent = typeof ev.at === 'number' && eventsSubscribedAt && ev.at < eventsSubscribedAt;
    if(isStaleEvent && ['miniSweetsShuffleStart','roundRevealSweets','revealCard','flyBackCard','wiretapArrow','wiretapArrowStart','wiretapArrowEnd','scoutArrowStart','scoutArrowEnd','sweetsReturn','trialExcludedToSweets','trialSweetsToExcluded','actionDiscardPeek','sweetsPeekArrow','sweetsPeekArrowStart','sweetsPeekArrowEnd'].includes(ev.type)) return;
    if(ev.type === 'revealCard'){
      showReveal(ev.card);
    }
    if(ev.type === 'flyBackCard'){
      animateFlyBackCard(ev.fromSeat, ev.toSeat);
    }
   if(ev.type === 'dealActionCard'){
      const delayMs = (typeof ev.delayMs === 'number') ? ev.delayMs : 0;
      animateActionDealCard(ev.toSeat, delayMs);
    }
    if(ev.type === 'actionDrawToHand'){
      const delayMs = (typeof ev.delayMs === 'number') ? ev.delayMs : 0;
      animateActionDrawToHand(ev.toUid, ev.toSeat, delayMs);
    }
    if(ev.type === 'wiretapArrow'){
      if(ev.fromUid !== state.userId && ev.fromSeat !== null && ev.toSeat !== null){
        showWiretapArrow(ev.fromSeat, ev.toSeat);
      }
    }
    if(ev.type === 'wiretapArrowStart'){
      if(ev.fromUid !== state.userId && ev.fromSeat !== null && ev.targetUid){
        showWiretapRoleArrow(ev.fromSeat, ev.targetUid, { key: ev.arrowId, persist: true });
      }
    }
    if(ev.type === 'wiretapArrowEnd'){
      if(ev.fromUid !== state.userId && ev.arrowId){
        removeWiretapArrow(ev.arrowId);
      }
    }
    if(ev.type === 'scoutArrowStart'){
      if(ev.fromUid !== state.userId && ev.fromSeat !== null && ev.toSeat !== null){
        showScoutArrow(ev.fromSeat, ev.toSeat, { key: ev.arrowId, persist: true });
      }
    }
    if(ev.type === 'scoutArrowEnd'){
      if(ev.fromUid !== state.userId && ev.arrowId){
        removeWiretapArrow(ev.arrowId);
      }
    }
    if(ev.type === 'actionDiscardPeek'){
      if(ev.fromUid !== state.userId){
        showDiscardedActionCard(ev.card);
      }
    }
    if(ev.type === 'sweetsPeekArrow'){
      if(ev.fromUid !== state.userId && ev.fromSeat !== null && ev.targetUid){
        showSweetsPeekArrow(ev.fromSeat, ev.targetUid);
      }
    }
    if(ev.type === 'sweetsPeekArrowStart'){
      if(ev.fromUid !== state.userId && ev.fromSeat !== null && ev.targetUid){
        showSweetsPeekArrow(ev.fromSeat, ev.targetUid, { key: ev.arrowId, persist: true });
      }
    }
    if(ev.type === 'sweetsPeekArrowEnd'){
      if(ev.fromUid !== state.userId && ev.arrowId){
        removeWiretapArrow(ev.arrowId);
      }
    }
    if(ev.type === 'sweetsSwap'){
      animateSweetsSwap(ev);
    }
    if(ev.type === 'sweetsReturn'){
      await animateSweetsReturnToDeck(ev.uid);
    }
    if(ev.type === 'trialExcludedToSweets'){
      if(ev.byUid !== state.userId){
        await animateTrialExcludedToSweets();
      }
    }
    if(ev.type === 'trialSweetsToExcluded'){
      await animateTrialSweetsToExcluded();
    }

    // ★ ラウンド終了演出（全員）
    if(ev.type === 'roundRevealSweets'){
      // ev.cards: 表にするカード配列（スイーツカード）
      await animateRoundEndReveal(ev.cards || [], ev.selectedUids || []);
  await animateReturnAllFieldSweetsToDeck();
  // ✅ その直後：除外札を「縦になって」山札へ回収
  await animateReturnExcludedDeckToSweetsDeck();
  await hostFinalizeReturnSweetsToDeck(ev.cards || []);

    }
    if(ev.type === 'miniSweetsShuffleStart'){
      await runMiniSweetsShuffleAtStart(ev);
    }

    if(state.isHost){
      maybeHostStartRoundEndFlow().catch(()=>{});
    }
  });
}

function normalizeTagChipStyle(styleClass){
  return TAG_CHIP_STYLES.includes(styleClass) ? styleClass : null;
}
function applyTagChipStyle(el, styleClass){
  if(!el) return;
  TAG_CHIP_STYLES.forEach(style => el.classList.remove(style));
  const normalized = normalizeTagChipStyle(styleClass);
  if(normalized) el.classList.add(normalized);
}
function getTagChipStyleByUid(uid){
  if(!uid) return null;
  const tables = state.room?.tables;
  if(!tables || typeof tables !== 'object') return null;
  const entry = Object.values(tables).find(t => t && t.playerId === uid);
  return normalizeTagChipStyle(entry?.tagChipStyle);
}
function pickRandomTagChipStyle(tables){
  const used = new Set();
  Object.values(tables || {}).forEach((t) => {
    if(t && normalizeTagChipStyle(t.tagChipStyle)){
      used.add(t.tagChipStyle);
    }
  });
  const available = TAG_CHIP_STYLES.filter(style => !used.has(style));
  const pool = available.length ? available : TAG_CHIP_STYLES;
  return pool[Math.floor(Math.random() * pool.length)];
}

/* =========================
   ターン管理（PASS対応：passした人は飛ばす）
   ========================= */
function getSeatedSeatOrder(){
  return latestPlayers.map(p => p.seatIndex).sort((a,b)=>a-b);
}
function getPlayerBySeat(seatIndex){
  return latestPlayers.find(p => p.seatIndex === seatIndex) || null;
}
function getPlayerByUid(uid){
  return latestPlayers.find(p => p.id === uid) || null;
}
function getSeatByUid(uid){
  const fromPlayers = getPlayerByUid(uid);
  if(fromPlayers) return fromPlayers.seatIndex;
  const tables = state.room?.tables;
  if(tables && typeof tables === 'object'){
    const entry = Object.entries(tables).find(([, t]) => t && t.playerId === uid);
    if(entry){
      return Number(entry[0]);
    }
  }
  return null;
}
function getPassedMap(){
  const p = state.game?.passes;
  return (p && typeof p === 'object') ? p : {};
}
function isPassedPlayerId(uid){
  const pm = getPassedMap();
  return !!pm?.[uid];
}
function isTurnBlocked(){
  return !!turnBlockedByShuffle;
}

async function hostGrantTurnAfterMiniShuffle(){
  if(!state.isHost || !state.roomCode) return;
  if(state.game?.turn) return;
  const seats = getSeatedSeatOrder();
  if(!seats.length) return;
  const leaderSeat = seats[Math.floor(Math.random() * seats.length)];
  const leaderIdx = seats.indexOf(leaderSeat);
  const nextSeat = seats[(leaderIdx + 1) % seats.length];
  const player = getPlayerBySeat(nextSeat);
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await set(turnRef, {
    activeSeat: nextSeat,
    activePlayerId: player?.id ?? null,
    startSeat: nextSeat,
    leaderSeat: leaderSeat,
   turnNo: 1,
    updatedAt: serverTimestamp(),
  });
}

async function hostRestartTurnAfterActionDeal(leaderSeat){
  if(!state.isHost || !state.roomCode) return;
  if(leaderSeat == null) return;

  const base = `rooms/${state.roomCode}/game`;
  const gameSnap = await get(ref(db, base));
  const gameNow = gameSnap.val() || {};
  const seatOrder = Array.isArray(gameNow.seatOrder) && gameNow.seatOrder.length
    ? gameNow.seatOrder
    : getSeatedSeatOrder();
  if(!seatOrder.length) return;

  const leaderIdx = seatOrder.indexOf(leaderSeat);
  const nextSeat = (leaderIdx === -1)
    ? seatOrder[0]
    : seatOrder[(leaderIdx + 1) % seatOrder.length];
  const nextPlayer = getPlayerBySeat(nextSeat);

  await update(ref(db, base), {
    passes: {},
    roundEnding: false,
    roundPick: null,
    leaderPick: null,
    turn: {
      activeSeat: nextSeat,
      activePlayerId: nextPlayer?.id ?? null,
      startSeat: nextSeat,
      leaderSeat: leaderSeat,
      turnNo: 1,
      updatedAt: serverTimestamp(),
    },
  });
}

function getNextOccupiedSeatSkippingPassed(currentSeat){
  const seats = getSeatedSeatOrder();
  if(!seats.length) return null;

  const startIdx = seats.indexOf(currentSeat);
  const begin = (startIdx === -1) ? 0 : startIdx;

  for(let step=1; step<=seats.length; step++){
    const s = seats[(begin + step) % seats.length];
    const p = getPlayerBySeat(s);
    if(!p) continue;
    if(!isPassedPlayerId(p.id)) return s;
  }
  // 全員pass済みなら、通常はここに来ない（ラウンド終了に入る）
  return seats[(begin + 1) % seats.length];
}
function isMyTurn(){
  if(!state.turn) return false;
  if(isTurnBlocked()) return false;
  if(state.game?.roundEnding) return false;
  if(allSeatedPlayersPassed()) return false;
  return (state.turn.activePlayerId === state.userId);
}

async function endTurn(reason){
  if(!state.roomCode || !state.turn) return;
  if(!isMyTurn()) return;

  state.turnEnding = true;
  updatePassRoundBtn();

  await clearBonusVoteChipsForTurn();
  await discardReceivedInstructionsForTurn();

  const nextSeat = getNextOccupiedSeatSkippingPassed(state.turn.activeSeat);
  if(nextSeat == null) return;

  const nextP = getPlayerBySeat(nextSeat);
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await update(turnRef, {
    activeSeat: nextSeat,
    activePlayerId: nextP?.id || null,
    lastEndReason: reason,
    updatedAt: serverTimestamp(),
    turnNo: (state.turn.turnNo || 1) + 1,
  });
}

async function clearBonusVoteChipsForTurn(){
  if(!state.roomCode) return;
  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const bonusChips = (typeof myData.bonusVoteChips === 'number') ? myData.bonusVoteChips : 0;
  if(bonusChips <= 0) return;
  await update(myRef, { bonusVoteChips: 0 });
}

/* =========================
   デッキ構築（アクションカード）
   ========================= */
const ACTION_COUNTS_BASE = [
  { name:'監禁', count:1, kind:'normal' },
  { name:'盗聴', count:1, kind:'normal' },
  { name:'世代交代', count:1, kind:'normal' },
  { name:'宣伝', count:1, kind:'normal' },

  { name:'強奪', count:2, kind:'normal' },
  { name:'偵察', count:2, kind:'normal' },
  { name:'ひらめき', count:2, kind:'normal' },
  { name:'仕込み', count:2, kind:'normal' },
  { name:'交換', count:2, kind:'normal' },
  { name:'試行錯誤',     count:2, kind:'normal' },
  { name:'事故',     count:2, kind:'normal' },
  { name:'激推し',     count:4, kind:'normal' },
  { name:'無視', count:2, kind:'instruction' },


  { name:'応援', count:4, kind:'instruction' },
  { name:'賄賂', count:4, kind:'instruction' },
  { name:'脅迫', count:4, kind:'instruction' },

];
const ACTION_COUNTS_7P = [
  { name:'強奪', count:1, kind:'normal' },
  { name:'偵察', count:1, kind:'normal' },
  { name:'ひらめき', count:1, kind:'normal' },
  { name:'仕込み', count:1, kind:'normal' },
  { name:'交換', count:1, kind:'normal' },
  { name:'試行錯誤',     count:1, kind:'normal' },
  { name:'事故',     count:1, kind:'normal' },
  { name:'激推し',     count:1, kind:'normal' },
  { name:'無視', count:1, kind:'instruction' },


  { name:'応援', count:1, kind:'instruction' },
  { name:'賄賂', count:1, kind:'instruction' },
  { name:'脅迫', count:1, kind:'instruction' },
];
const INSTRUCTION_NEED_TARGET = new Set(['応援','脅迫','賄賂','無視']);
const INSTRUCTION_CAN_SELF = new Set(['無視']);

function cardNameToImg(name){
  if(name === '') return 'blank.jpg';
  return `${name}.jpg`;
}
function buildActionDeck(playerCount){
  const list = [];
  const counts = [...ACTION_COUNTS_BASE, ...(playerCount >= 7 ? ACTION_COUNTS_7P : [])];
  counts.forEach(def => {
    for(let i=0;i<def.count;i++){
      list.push({
        id: crypto.randomUUID(),
        name: def.name,
        kind: def.kind,
        img: cardNameToImg(def.name),
        backImg: `swactionura.jpg`,
        effectText: getActionEffectText(def.name),
      });
    }
  });
  return shuffle(list);
}
function getActionEffectText(cardName){
  const map = {
    '監禁': '選んだプレイヤーへの投票はこのラウンド中、数値上0として扱う。',
    '盗聴': '選んだプレイヤーの正体カードを見る。',
    '世代交代': 'リーダーになる。',
    '宣伝': '選んだプレイヤーのスイーツを公開する。',
    '強奪': '置かれている任意の投票チップを1つ移動させる。',
    '偵察': '選んだプレイヤーのアクションカードを見る。',
    'ひらめき': '除外山札からスイーツを作る。既にスイーツを持っていてもレシピに戻してよい。',
    '仕込み': 'アクションカードを1枚ひく。',
    '交換': '選んだプレイヤーとスイーツを交換する。',
    '試行錯誤': '一番上にある除外したカードをレシピに加えた後、レシピから1枚選んで除外する。',
    '激推し': '投票チップを新しく獲得する。このターン中は新しいチップだけが鼓動し、他プレイヤーのスイーツに投票したら手番終了。',
    '事故': '選んだプレイヤーのスイーツをレシピに戻す。',
    '応援': '渡されたら、次の手番で一番数字が大きいスイーツを作る。',
    '脅迫': '渡されたら、次の手番で一番数字が小さいスイーツを作る。',
    '賄賂': '渡されたら、次の手番で受け取った相手のスイーツに投票する。',
    '無視': '渡られたら、他の指示を無視できる。自分で使ったら、手番が終わる。',
  };
  return map[cardName] ?? '（効果は後で）';
}

/* =========================
   ★ スイーツデッキ構築
   ========================= */
const SWEETS_BACK_IMG = 'swsweetsura.jpg';

function buildSweetsPool(){
  const base = [
    { value:0, img:'sw0.jpg', fallback:'sw1.jpg' },
    { value:1, img:'sw1.jpg' },
    { value:2, img:'sw2.jpg' },
    { value:3, img:'sw3.jpg' },
    { value:3, img:'sw3(2).jpg' },
    { value:4, img:'sw4.jpg' },
    { value:4, img:'sw4(2).jpg' },
    { value:5, img:'sw5.jpg' },
    { value:5, img:'sw5(2).jpg' },
    { value:6, img:'sw6.jpg' },
    { value:7, img:'sw7.jpg' },
    { value:8, img:'sw8.jpg' },
  ];
  return base.map(b => ({
    id: crypto.randomUUID(),
    kind: 'sweets',
    value: b.value,
    name: String(b.value),
    img: b.img,
    backImg: SWEETS_BACK_IMG,
    fallback: b.fallback || null,
  }));
}
function buildSweetsDeck(playerCount){
  const pool = buildSweetsPool();
  return shuffle(pool);
}
function splitSweetsDeck(deck, playerCount){
  const total = Array.isArray(deck) ? deck.length : 0;
  const keepCount = clamp(playerCount + 2, 0, total);
  if(!Array.isArray(deck) || total <= keepCount){
    return { sweets: Array.isArray(deck) ? deck : [], excluded: [] };
  }
  const shuffled = shuffle([...deck]);
  return {
    sweets: shuffled.slice(0, keepCount),
    excluded: shuffled.slice(keepCount),
  };
}

/* =========================
   正体カード配布
   ========================= */
function buildRolePool(n){
  const usakoma = Math.ceil(n/2);
  const uragiri = Math.floor(n/2);
  const pool = [];
  for(let i=0;i<usakoma;i++) pool.push('usakoma');
  for(let i=0;i<uragiri;i++) pool.push('uragiri');
  return shuffle(pool);
}

/* =========================
   ゲーム開始（ホストのみ）
   ========================= */
async function hostGameStart(){
  if(!state.isHost || !state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? {
      id: t.playerId,
      name: t.playerName || '名無し',
      seatIndex: Number(seatIndex)
    } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex-b.seatIndex);

  if(players.length === 0) return;

  const seats = players.map(p=>p.seatIndex).sort((a,b)=>a-b);

  let actionDeck = buildActionDeck(players.length);
  const sweetsDeck = buildSweetsDeck(players.length);

  const hands = {};
  players.forEach(p => {
    hands[p.id] = {
      action: actionDeck.splice(0, 3),
      sweets: [],
      received: [],
      voteChips: 1,
      bonusVoteChips: 0,
    };
  });

  const pool = buildRolePool(players.length);
 const roles = {};
  players.forEach((p, i) => { roles[p.id] = pool[i]; });

  const base = `rooms/${state.roomCode}`;
  const gameSessionId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  await update(ref(db, `${base}/game`), { turn: null });
  await update(ref(db, `${base}`), { gameStarted: true });
  await remove(ref(db, `${base}/events`));
  await set(ref(db, `${base}/hands`), {});
  await set(ref(db, `${base}/roles`), {});
  await set(ref(db, `${base}/discard`), { action: [] });

  await set(ref(db, `${base}/decks`), { action: actionDeck, sweets: sweetsDeck, sweetsExcluded: [] });



  await Promise.all([
    set(ref(db, `${base}/hands`), hands),
    set(ref(db, `${base}/roles`), roles),
  ]);

  await set(ref(db, `${base}/votes`), {});
  await set(ref(db, `${base}/game`), {
    status: 'playing',
    startedAt: serverTimestamp(),
    sessionId: gameSessionId,
    seatOrder: seats,
    passes: {},               // ★ ラウンドPASS
    roundEnding: false,       // ★ ラウンド終了中フラグ
    roundPick: null,          // ★ 同票解決状態
    leaderPick: null,         // ★ リーダー移行状態
    actionDealKey: null,      // ★ リーダー配布の重複防止
    imprisoned: null,
    advertisedSweets: {},
    roundNo: 1,
    roundChips: {},
    turn: null

  });

  await emitEvent({ type: 'miniSweetsShuffleStart', reason: 'gameStart', sessionId: gameSessionId });

  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   イベント（全員演出用）
   ========================= */
async function emitEvent(payload){
  if(!state.roomCode) return;
  const evRef = ref(db, `rooms/${state.roomCode}/events`);
  const sessionId = payload.sessionId ?? currentGameSessionId ?? state.game?.sessionId ?? null;
  const eventPayload = { ...payload, at: now() };
  if(sessionId) eventPayload.sessionId = sessionId;
  await push(evRef, eventPayload);
}


/* =========================
   中央拡大（全員1秒）
   ========================= */
let revealOwnerId = null;
function showReveal(card){
  if(!card) return;
  revealImg.src = card.img || '';
  revealLabel.textContent = card.name || '';
  const isActionCard = card.kind === 'normal' || card.kind === 'instruction';
  revealLabel.classList.toggle('hidden', isActionCard || !card.name);
  const effectText = card.effectText || card.text || '';
  revealEffect.textContent = effectText;
  revealEffectFrame.classList.toggle('hidden', !effectText);
  revealOverlay.classList.remove('hidden');
  revealOverlay.classList.remove('pop');
  void revealOverlay.offsetHeight;
  revealOverlay.classList.add('pop');
  revealOwnerId = state.turn?.activePlayerId ?? null;
}

function openActionZoom(card){
  if(!card || !actionZoomOverlay) return;
  actionZoomImg.src = card.img || '';
  actionZoomImg.alt = card.name || '';
  const effectText = card.effectText || card.text || '';
  actionZoomEffect.textContent = effectText;
  actionZoomEffectFrame.classList.toggle('hidden', !effectText);
  actionZoomOverlay.classList.remove('hidden');
}

function closeActionZoom(){
  actionZoomOverlay?.classList.add('hidden');
}

if(actionZoomOverlay){
  actionZoomOverlay.addEventListener('click', (e) => {
    if(e.target === actionZoomOverlay) closeActionZoom();
  });
}







/* =========================
   指示カード：裏カード移動アニメ（全員）
   ========================= */
function animateFlyBackCard(fromSeat, toSeat){
  const fromEl = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  const toEl   = document.querySelector(`.player-tag[data-seat="${toSeat}"]`);
  if(!fromEl || !toEl) return;

  const fr = fromEl.getBoundingClientRect();
  const tr = toEl.getBoundingClientRect();

  const fly = document.createElement('div');
  fly.className = 'fly-card';
  fly.style.left = `${fr.right + 6}px`;
  fly.style.top  = `${fr.top + fr.height/2 - 16}px`;
  document.body.appendChild(fly);

  const toX = (tr.right + 6) - (fr.right + 6);
  const toY = (tr.top + tr.height/2 - 16) - (fr.top + fr.height/2 - 16);

  fly.animate([
    { transform:`translate(0px,0px) scale(1)`, opacity:1 },
    { transform:`translate(${toX}px,${toY}px) scale(1.05)`, opacity:1 }
  ], {
    duration: 520,
    easing: 'cubic-bezier(.22,.84,.44,1)'
  }).onfinish = () => fly.remove();
}

/* =========================
   文字を枠内に収める
   ========================= */
function fitEffectText(el){
  if(!el) return;
  const box = el.parentElement;
  if(!box) return;

  const styles = getComputedStyle(box);
  const paddingTop = parseFloat(styles.paddingTop) || 0;
  const paddingBottom = parseFloat(styles.paddingBottom) || 0;
  const availableHeight = box.clientHeight - paddingTop - paddingBottom;

  const maxSize = 13;
  const minSize = 6;
  let size = maxSize;
  el.style.fontSize = size + 'px';

  while(size > minSize && el.scrollHeight > availableHeight){
    size -= 1;
    el.style.fontSize = size + 'px';
  }
}

/* =========================
   ★ 受け取り指示カード
   ========================= */
function getMyReceivedCards(){
  const myData = state.hands?.[state.userId];
  const rec = myData?.received;
  return Array.isArray(rec) ? rec : [];
}
function hasReceivedInstruction(){
  return getMyReceivedCards().length > 0;
}
function hasReceivedIgnoreCard(cards = getMyReceivedCards()){
  return cards.some(card => card?.name === '無視');
}
function getActiveInstructionCards(){
  const cards = getMyReceivedCards();
  if(!cards.length) return [];
  if(hasReceivedIgnoreCard(cards)) return [];
  const active = [];
  const sweetsMissing = !hasSweets();
  const canBribe = getMyTotalVoteChips() > 0;
  cards.forEach(card => {
    if(card?.name === '応援' || card?.name === '脅迫'){
      if(sweetsMissing) active.push(card);
    } else if(card?.name === '賄賂'){
      if(canBribe) active.push(card);
    }
  });
  return active;
}
function isInstructionTurnBlocked(){
  return isMyTurn() && getActiveInstructionCards().length > 0 && !isActionSelectionActive();
}
function getActiveInstructionNames(){
  return new Set(getActiveInstructionCards().map(card => card?.name));
}
function getActiveBribeTargetUids(){
  return getActiveInstructionCards()
    .filter(c => c?.name === '賄賂')
    .map((card) => {
      if(card?.fromUid) return card.fromUid;
      if(card?.fromSeat != null){
        const p = getPlayerBySeat(card.fromSeat);
        return p?.id ?? null;
      }
      return null;
    })
    .filter(Boolean);
}


/* =========================
   ★ スイーツ回収（拡大表示終了後）
   - 場のスイーツ（selected / 非selected）を山札へ
   - その直後、除外札は縦になって山札へ
   ========================= */

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

async function waitUntilHidden(el, timeoutMs = 4500){
  const start = Date.now();
  while(Date.now() - start < timeoutMs){
    if(!el || el.classList.contains('hidden')) return;
    await sleep(50);
  }
}

function isVisibleRect(el){
  if(!el) return false;
  const r = el.getBoundingClientRect();
  return !!(r.width && r.height);
}

function isFieldElement(el){
  if(!el) return false;
  // オーバーレイ中のカードは対象外
  if(el.closest('#roundRevealOverlay')) return false;
  if(el.closest('#revealOverlay')) return false;
  if(el.closest('#sweetsBackdrop')) return false;
  return isVisibleRect(el);
}

function getSweetsDeckTargetRect(){
  if(!sweetsDeckUI) return null;
  const r = sweetsDeckUI.getBoundingClientRect();
  if(!r.width || !r.height) return null;
  return {
    x: r.left + r.width/2,
    y: r.top + r.height/2,
    w: r.width,
    h: r.height,
    raw: r
  };
}

function getCollectAnimationSnapshot(el){
  if(!el) return null;
  const rect = el.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  const width = el.offsetWidth || rect.width;
  const height = el.offsetHeight || rect.height;
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  const hostCircle = el.closest('.otherplayerscircle');
  const rotValue = hostCircle ? getComputedStyle(hostCircle).getPropertyValue('--rotDeg').trim() : '0deg';
  const rotateDeg = parseRotationDegrees(rotValue);

  return {
    left: centerX - width / 2,
    top: centerY - height / 2,
    width,
    height,
    rotateDeg,
  };
}

function normalizeRotationDegrees(fromDeg, toDeg){
  const from = Number.isFinite(fromDeg) ? fromDeg : 0;
  const to = Number.isFinite(toDeg) ? toDeg : 0;
  const diff = ((from - to + 540) % 360) - 180;
  return to + diff;
}

function animateOneCardToDeck(srcRect, target, { delay = 0, rotateFrom = 0, rotateTo = 0 } = {}){
  if(!srcRect || !srcRect.width || !srcRect.height || !target) return Promise.resolve();

  const fly = document.createElement('div');
  fly.className = 'collect-card';
  fly.style.left = `${srcRect.left}px`;
  fly.style.top  = `${srcRect.top}px`;
  fly.style.width  = `${srcRect.width}px`;
  fly.style.height = `${srcRect.height}px`;
  fly.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  fly.style.zIndex = '999999';
  document.body.appendChild(fly);

  const dx = target.x - (srcRect.left + srcRect.width/2);
  const dy = target.y - (srcRect.top  + srcRect.height/2);

  const scaleX = target.w / srcRect.width;
  const scaleY = target.h / srcRect.height;
  const scale  = Math.min(scaleX, scaleY);

  const normalizedRotateFrom = normalizeRotationDegrees(rotateFrom, rotateTo);

  return new Promise(resolve => {
    fly.animate([
      { transform:`translate(0px,0px) rotate(${normalizedRotateFrom}deg) scale(1)`, opacity:1 },
      { transform:`translate(0px,0px) rotate(${rotateTo}deg) scale(1)`, opacity:1, offset:0.55 },
      { transform:`translate(${dx}px,${dy}px) rotate(${rotateTo}deg) scale(${scale})`, opacity:0.92 },
    ],{
      duration: 780,
      delay,
      easing: 'cubic-bezier(.22,.84,.44,1)',
      fill: 'forwards'
    }).onfinish = () => {
      fly.remove();
      resolve();
    };
  });
}

async function animateReturnAllFieldSweetsToDeck(){

  // 「拡大公開が実行済み & 終了済み」を待つ
  const revealDone = await waitForRoundRevealCompletion();
  if(!revealDone) return;
  await sleep(800);

  const target = getSweetsDeckTargetRect();
  if(!target) return;

  const sources = [];

  // 1) selected（ネームタグ上の selected-sweets-card）
  document.querySelectorAll('.selected-sweets-card').forEach(cardEl => {
    if(!isFieldElement(cardEl)) return;
    sources.push({
      el: cardEl,
      host: cardEl.closest('.selected-sweets-tag') || cardEl,
      uid: (cardEl.closest('.selected-sweets-tag')?.dataset?.sweetsUid) || null
    });
  });

  // 2) 非selected（他プレイヤーの sweets-wrap 内 sweets-mini）
  document.querySelectorAll('.sweets-wrap .sweets-mini').forEach(miniEl => {
    if(!isFieldElement(miniEl)) return;
    sources.push({
      el: miniEl,
      host: miniEl.closest('.sweets-wrap') || miniEl,
      uid: (miniEl.closest('.sweets-wrap')?.dataset?.sweetsUid) || null
    });
  });

  // 3) 自分のスイーツ（手元表示が残っている場合も回収）
  const myImg = mySweetsEl?.querySelector('img');
  if(myImg && isFieldElement(myImg)){
    sources.push({
      el: myImg,
      host: mySweetsEl,
      uid: state.userId || null
    });
  }

  if(!sources.length) return;

  // フリッカー防止：render側でも消えるように（既存キャッシュを利用）
  sources.forEach(s => { if(s.uid) collectedSweetsHidden.add(s.uid); });

  // 元DOMを先に不可視化（回収中に二重に見えないように）
  sources.forEach(s => {
    if(s.host?.classList) s.host.classList.add('collect-hidden');
    else if(s.el) s.el.style.visibility = 'hidden';
  });

  // 回収アニメ（少しだけズラして気持ちよく）
  const tasks = sources.map((s, i) => {
    const snapshot = getCollectAnimationSnapshot(s.el);
    if(!snapshot) return Promise.resolve();
    return animateOneCardToDeck(snapshot, target, { delay: i * 35, rotateFrom: snapshot.rotateDeg, rotateTo: 0 });
  });

  await Promise.all(tasks);
}

async function animateReturnExcludedDeckToSweetsDeck(){
  // 「その直後」
  await sleep(30);

  // 除外が無いなら何もしない
  const excludedDeck = state.room?.decks?.sweetsExcluded;
  const liveExcluded = Array.isArray(excludedDeck) ? excludedDeck.length : 0;
  const excludedCount = (sweetsExcludedCountOverride ?? liveExcluded);
  if(excludedCount <= 0) return;

  const target = getSweetsDeckTargetRect();
  if(!target) return;

  if(!sweetsExcludedDeckUI || !isVisibleRect(sweetsExcludedDeckUI)) return;
  const exRect = sweetsExcludedDeckUI.getBoundingClientRect();

  // UIを一瞬隠して「飛ぶ1枚」だけ見せる（見た目重複防止）
  const prevVis = sweetsExcludedDeckUI.style.visibility;
  sweetsExcludedDeckUI.style.visibility = 'hidden';

  // 横(90deg) → 縦(0deg) になりつつ山札へ
  await animateOneCardToDeck(exRect, target, { delay: 0, rotateFrom: 90, rotateTo: 0 });

  sweetsExcludedDeckUI.style.visibility = prevVis;
}

// ✅ ホストだけ：ラウンド終了後に「全スイーツ（selected/非selected/手元）＋除外」をDB上で山札へ戻す
async function hostFinalizeReturnSweetsToDeck(revealedCards = []){
  if(!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;

  // 最新を取り直す（stateのズレ対策）
  const [handsSnap, decksSnap, votesSnap, tablesSnap, gameSnap] = await Promise.all([
    get(ref(db, `${base}/hands`)),
    get(ref(db, `${base}/decks`)),
    get(ref(db, `${base}/votes`)),
    get(ref(db, `${base}/tables`)),
    get(ref(db, `${base}/game`)),
  ]);

  const gameNow = gameSnap.val() || {};


  const hands = handsSnap.val() || {};
  const decks = decksSnap.val() || {};
  const votes = votesSnap.val() || {};
  const tables = tablesSnap.val() || {};
  const deckSweets = Array.isArray(decks.sweets) ? decks.sweets : [];
  const excluded   = Array.isArray(decks.sweetsExcluded) ? decks.sweetsExcluded : [];

  // 返すカードを「id」でユニーク化（重複防止）
  const returned = new Map();
  const add = (c) => {
    if(!c || !c.id) return;
    if(!returned.has(c.id)) returned.set(c.id, c);
  };

  // ① イベントで公開されたカード（selected/非selectedの実体になっている想定）
  (Array.isArray(revealedCards) ? revealedCards : []).forEach(add);

  // ② hands に残っているスイーツ（手元含む）も全部回収（これが枚数不足の主因）
  Object.values(hands).forEach(h => {
    const arr = h?.sweets;
    if(Array.isArray(arr)) arr.forEach(add);
  });

  // ③ 除外も山札へ戻す（今回の仕様）
  excluded.forEach(add);

  const returnedIds = new Set(returned.keys());

  // 既に山札に紛れ込んでいた場合でも二重化しないよう、先に除去してから足す
  const baseDeck = deckSweets.filter(c => !(c && c.id && returnedIds.has(c.id)));
  const newDeck  = shuffle([...baseDeck, ...Array.from(returned.values())]);

  // hands の sweets を全員ぶん空にする
  for(const uid of Object.keys(hands)){
    if(hands[uid] && Array.isArray(hands[uid].sweets)){
      hands[uid].sweets = [];
    }
  }

  // DB反映（decksは部分更新でOK）
  const leaderSeatNow = gameNow.turn?.leaderSeat ?? null;
  const leaderId = leaderSeatNow != null ? (tables?.[leaderSeatNow]?.playerId ?? null) : null;
  const imprisonedUid = gameNow.imprisoned?.uid ?? null;
  const voteCounts = Object.entries(votes)
    .map(([uid, voters]) => ({
      uid,
      count: (imprisonedUid && imprisonedUid === uid)
        ? 0
        : Object.values(voters || {}).reduce((sum, count) => {
          if(typeof count !== 'number') return sum + 1;
          return sum + count;
        }, 0),
    }))
    .filter(entry => entry.count > 0);
  const maxVotes = voteCounts.length ? Math.max(...voteCounts.map(v => v.count)) : 0;
  const topVoteUids = voteCounts.filter(v => v.count === maxVotes).map(v => v.uid);
  const leaderPickStartAt = Date.now();
  let leaderPickPayload = null;
  if(topVoteUids.length === 1){
    leaderPickPayload = {
      phase: 'auto',
      decidedId: topVoteUids[0],
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }else if(topVoteUids.length === 2 && leaderId && topVoteUids.includes(leaderId)){
    const nextLeaderId = topVoteUids.find(uid => uid !== leaderId);
    leaderPickPayload = {
      phase: 'auto',
      decidedId: nextLeaderId || null,
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }else if(topVoteUids.length >= 2){
    leaderPickPayload = {
      phase: 'choose',
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }

  await update(ref(db, base), {
    'hands': hands,
    'decks/sweets': newDeck,
    'decks/sweetsExcluded': [],   // 除外は空に
    'game/leaderPick': leaderPickPayload,
    'game/actionDealKey': null,
    'game/imprisoned': null,
    'game/advertisedSweets': {},
    /* ✅ 追加：ここから勝敗判定→roundchip→round+1 */
    ...( (() => {
      const playerCount = Array.isArray(gameNow.seatOrder) ? gameNow.seatOrder.length : (latestPlayers?.length || 0);
      const currentRound = (typeof gameNow.roundNo === 'number') ? gameNow.roundNo : 1;

      const pts = calcSweetsTotalPoints(revealedCards);          // 選ばれたスイーツ合計点
      const th  = getRoundWinThreshold(playerCount || 1, currentRound);
      const win = pts >= th;

      // roundchipは1〜3のスロットにのみ描画（キーは "1","2","3" で持つ）
      const prev = (gameNow.roundChips && typeof gameNow.roundChips === 'object') ? gameNow.roundChips : {};
      const nextChips = { ...prev };
      if(currentRound >= 1 && currentRound <= 3){
        nextChips[String(currentRound)] = win ? 'winchip.png' : 'losechip.png';
      }

      return {
        'game/roundChips': nextChips,
        'game/roundNo': currentRound + 1,          // 処理が終わった後で +1
        'game/lastRoundPoints': pts,               // （任意：デバッグ用。不要なら消してOK）
        'game/lastRoundThreshold': th,             // （任意：デバッグ用）
      };
    })() )

  });

  if(!leaderPickPayload){
    await set(ref(db, `${base}/votes`), {});
  }
}


/* =========================
   ★ 投票（チップ表示＆条件）
   ========================= */
function getMyVoteChips(){
  const myData = state.hands?.[state.userId] || {};
  const v = myData.voteChips;
  return (typeof v === 'number') ? v : 1;
}
function getMyBonusVoteChips(){
  const myData = state.hands?.[state.userId] || {};
  const v = myData.bonusVoteChips;
  return (typeof v === 'number') ? v : 0;
}
function getPlayerVoteChips(uid){
  const data = state.hands?.[uid] || {};
  const v = data.voteChips;
  return (typeof v === 'number') ? v : 1;
}
function getPlayerBonusVoteChips(uid){
  const data = state.hands?.[uid] || {};
  const v = data.bonusVoteChips;
  return (typeof v === 'number') ? v : 0;
}
function getPlayerTotalVoteChips(uid){
  return getPlayerVoteChips(uid) + getPlayerBonusVoteChips(uid);
}
function getMyTotalVoteChips(){
  return getPlayerTotalVoteChips(state.userId);
}
function hasBonusVoteChips(uid = state.userId){
  return getPlayerBonusVoteChips(uid) > 0;
}
function getSweetsOwners(){
  return latestPlayers
    .filter(p => {
      const hd = state.hands?.[p.id];
      return !!(hd && Array.isArray(hd.sweets) && hd.sweets.length);
    })
    .map(p => p.id);
}
function canVoteNow(options = {}){
  const { useBonus = false } = options;
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(isActionSelectionActive()) return false;
  const bonusChips = getMyBonusVoteChips();
  const normalChips = getMyVoteChips();
  if(useBonus){
    if(bonusChips <= 0) return false;
  }else{
    if(bonusChips > 0) return false;
    if(normalChips <= 0) return false;
  }
  const activeInstructions = getActiveInstructionCards();
  const bribeTargetUids = getActiveBribeTargetUids();
  if(activeInstructions.length && bribeTargetUids.length === 0) return false;
  if(bribeTargetUids.length){
    return bribeTargetUids.some((uid) => {
      if(uid === state.userId) return false;
      const targetData = state.hands?.[uid];
      return !!(targetData && Array.isArray(targetData.sweets) && targetData.sweets.length);
    });
  }
  const owners = getSweetsOwners();
  if(useBonus){
    return owners.some(uid => uid !== state.userId);
  }
  return owners.length >= 1;
}

function getTotalVoteChipsOnField(votesObj = state.room?.votes){
  if(!votesObj || typeof votesObj !== 'object') return 0;
  return Object.values(votesObj).reduce((sum, voters) => {
    if(!voters || typeof voters !== 'object') return sum;
    const total = Object.values(voters).reduce((innerSum, count) => {
      if(typeof count !== 'number') return innerSum + 1;
      return innerSum + count;
    }, 0);
    return sum + total;
  }, 0);
}
function renderMyVoteChip(){
  const started = !!state.room?.gameStarted;
  applyTagChipStyle(myVoteChipEl, getTagChipStyleByUid(state.userId));
  applyTagChipStyle(myBonusVoteChipEl, getTagChipStyleByUid(state.userId));
  if(!started){
    myVoteChipEl.classList.add('hidden');
    myVoteChipEl.classList.remove('pulsing');
    myBonusVoteChipEl.classList.add('hidden');
    myBonusVoteChipEl.classList.remove('pulsing');
    document.body.classList.remove('bonus-vote-active');
    placeMyVoteChips();
    return;
  }

  const chips = getMyVoteChips();
  const bonusChips = getMyBonusVoteChips();
  document.body.classList.toggle('bonus-vote-active', bonusChips > 0);
  myVoteChipEl.classList.toggle('hidden', chips <= 0);
  myVoteChipEl.classList.toggle('pulsing', bonusChips <= 0 && canVoteNow({ useBonus: false }));
  myBonusVoteChipEl.classList.toggle('hidden', bonusChips <= 0);
  myBonusVoteChipEl.classList.toggle('pulsing', bonusChips > 0 && canVoteNow({ useBonus: true }));
  placeMyVoteChips();
}

function placeMyVoteChips(){
  if(!myVoteSlotLeftEl || !myVoteSlotRightEl) return;
  const hasNormal = !myVoteChipEl.classList.contains('hidden');
  const hasBonus = !myBonusVoteChipEl.classList.contains('hidden');

  if(hasNormal && hasBonus){
    myVoteSlotLeftEl.appendChild(myVoteChipEl);
    myVoteSlotRightEl.appendChild(myBonusVoteChipEl);
    return;
  }
  if(hasNormal){
    myVoteSlotRightEl.appendChild(myVoteChipEl);
    myVoteSlotLeftEl.appendChild(myBonusVoteChipEl);
    return;
  }
  if(hasBonus){
    myVoteSlotRightEl.appendChild(myBonusVoteChipEl);
    myVoteSlotLeftEl.appendChild(myVoteChipEl);
    return;
  }
  myVoteSlotLeftEl.appendChild(myVoteChipEl);
  myVoteSlotRightEl.appendChild(myBonusVoteChipEl);
}

let lastVoteSnapshot = null;
const VOTE_CHIP_MOVE_DURATION = 600;
const movingVoteChips = new Map();

function getVoteSnapshot(votesObj){
  const snapshot = new Map();
  const votes = votesObj && typeof votesObj === 'object' ? votesObj : {};
  Object.entries(votes).forEach(([targetUid, voters]) => {
    if(!voters || typeof voters !== 'object') return;
    const voterMap = new Map();
    Object.entries(voters).forEach(([voterUid, count]) => {
      const total = (typeof count === 'number') ? count : 1;
      voterMap.set(voterUid, total);
    });
    snapshot.set(targetUid, voterMap);
  });
  return snapshot;
}
function getVoteAnimations(prev, next){
  const moves = [];
  const additions = [];
  if(!prev) return { moves, additions };

  const voterDeltas = new Map();
  const targetUids = new Set([...prev.keys(), ...next.keys()]);

  targetUids.forEach((targetUid) => {
    const prevMap = prev.get(targetUid) || new Map();
    const nextMap = next.get(targetUid) || new Map();
    const voterUids = new Set([...prevMap.keys(), ...nextMap.keys()]);
    voterUids.forEach((voterUid) => {
      const prevCount = prevMap.get(voterUid) ?? 0;
      const nextCount = nextMap.get(voterUid) ?? 0;
      const diff = nextCount - prevCount;
      if(!diff) return;
      if(!voterDeltas.has(voterUid)){
        voterDeltas.set(voterUid, { from: [], to: [] });
      }
      const entry = voterDeltas.get(voterUid);
      if(diff > 0){
        entry.to.push({ targetUid, count: diff });
      }else{
        entry.from.push({ targetUid, count: Math.abs(diff) });
      }
    });
  });

  voterDeltas.forEach((entry, voterUid) => {
    let fromIndex = 0;
    let toIndex = 0;
    while(fromIndex < entry.from.length && toIndex < entry.to.length){
      const from = entry.from[fromIndex];
      const to = entry.to[toIndex];
      const moveCount = Math.min(from.count, to.count);
      for(let i = 0; i < moveCount; i++){
        moves.push({ voterUid, fromTargetUid: from.targetUid, toTargetUid: to.targetUid });
      }
      from.count -= moveCount;
      to.count -= moveCount;
      if(from.count === 0) fromIndex += 1;
      if(to.count === 0) toIndex += 1;
    }
    entry.to.forEach((to) => {
      for(let i = 0; i < to.count; i++){
        additions.push({ voterUid, targetUid: to.targetUid });
      }
    });
  });

  return { moves, additions };
}
function getVoteChipSizePx(){
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--voteMiniSize'));
  return Number.isFinite(size) ? size : 14;
}
function buildVoteStackEl(targetUid){
  const voterIds = getVoteVoterIds(targetUid);
  if(!voterIds.length) return null;
  const voteStack = document.createElement('div');
  voteStack.className = 'vote-stack';
  voteStack.dataset.targetUid = targetUid;
  const moveCounts = new Map();
  voterIds.forEach((voterUid) => {
    const key = `${voterUid}:${targetUid}`;
    if(!moveCounts.has(key)){
      moveCounts.set(key, movingVoteChips.get(key) || 0);
    }
    const skipCount = moveCounts.get(key) || 0;
    if(skipCount > 0){
      moveCounts.set(key, skipCount - 1);
      return;
    }
    const v = document.createElement('div');
    v.className = 'vote-mini';
    v.dataset.voterUid = voterUid;
    v.dataset.targetUid = targetUid;
    applyTagChipStyle(v, getTagChipStyleByUid(voterUid));
    if(shouldEnableRobVoteDrag()){
      v.classList.add('rob-selectable');
      v.addEventListener('pointerdown', (e) => startRobVoteDrag(e, v));
    }
    voteStack.appendChild(v);
  });
  return voteStack;
}
function getVoteChipSourceRect(voterUid){
  const tag = document.querySelector(`.player-tag[data-uid="${voterUid}"]`);
  if(!tag) return null;
  const chip = tag.querySelector(`.other-vote-chip[data-voter-uid="${voterUid}"]`);
  if(chip){
    const rect = chip.getBoundingClientRect();
    return {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
    };
  }
  const roleMini = tag.querySelector('.role-mini');
  const size = getVoteChipSizePx();
  if(roleMini){
    const rect = roleMini.getBoundingClientRect();
    return {
      left: rect.right - 6 - size,
      top: rect.bottom - 6 - size,
      width: size,
      height: size,
    };
  }
  return null;
}
function getVoteChipTargetInfo(targetUid){
  const stack = document.querySelector(`.vote-stack[data-target-uid="${targetUid}"]`);
  if(!stack) return null;
  const rect = stack.getBoundingClientRect();
  const size = getVoteChipSizePx();
  return {
    stack,
    rect: {
      left: rect.left + (rect.width - size) / 2,
      top: rect.top + (rect.height - size) / 2,
      width: size,
      height: size,
    },
  };
}
function animateVoteChipFly(voterUid, targetUid){
  if(voterUid === state.userId) return;
  const source = getVoteChipSourceRect(voterUid);
  const targetInfo = getVoteChipTargetInfo(targetUid);
  if(!source || !targetInfo) return;
  const { stack, rect: target } = targetInfo;

  const fly = document.createElement('div');
  fly.className = 'vote-chip-fly';
  applyTagChipStyle(fly, getTagChipStyleByUid(voterUid));
  fly.style.left = `${source.left}px`;
  fly.style.top = `${source.top}px`;
  fly.style.width = `${source.width}px`;
  fly.style.height = `${source.height}px`;
  document.body.appendChild(fly);

  const dx = target.left - source.left;
  const dy = target.top - source.top;
  stack.classList.add('animating');
  fly.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: 600,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    fly.remove();
    stack.classList.remove('animating');
  };
}
function scheduleVoteChipAnimations(){
  const current = getVoteSnapshot(state.room?.votes || {});
  if(!lastVoteSnapshot){
    lastVoteSnapshot = current;
    return;
  }
  const { moves, additions } = getVoteAnimations(lastVoteSnapshot, current);
  lastVoteSnapshot = current;
  if(!moves.length && !additions.length) return;
  requestAnimationFrame(() => {
    moves.forEach(({ voterUid, fromTargetUid, toTargetUid }) => {
      moveVoteChipElement({ voterUid, fromTargetUid, toTargetUid });
    });
    additions.forEach(({ voterUid, targetUid }) => {
      animateVoteChipFly(voterUid, targetUid);
    });
  });
}

const VOTE_STACK_OFFSET_PX = 22;
function getVoteChipTargetRectForMove(targetUid){
  const info = getVoteChipTargetInfo(targetUid);
  if(info) return info.rect;
  const size = getVoteChipSizePx();
  let wrap = document.querySelector(`.sweets-wrap[data-sweets-uid="${targetUid}"]`);
  if(!wrap && targetUid === state.userId){
    wrap = mySweetsEl;
  }
  if(!wrap) return null;
  const rect = wrap.getBoundingClientRect();
  return {
    left: rect.right - VOTE_STACK_OFFSET_PX - size,
    top: rect.top + rect.height / 2 - size / 2,
    width: size,
    height: size,
  };
}
function getVoteChipSourceRectForMove(voterUid, targetUid){
  const el = document.querySelector(`.vote-mini[data-voter-uid="${voterUid}"][data-target-uid="${targetUid}"]`);
  if(!el) return null;
  const rect = el.getBoundingClientRect();
  return {
    left: rect.left,
    top: rect.top,
    width: rect.width,
    height: rect.height,
  };
}
function animateVoteChipRelocate({ voterUid, sourceRect, targetUid }){
  const source = sourceRect;
  const target = getVoteChipTargetRectForMove(targetUid);
  if(!source || !target) return;

  const fly = document.createElement('div');
  fly.className = 'vote-chip-fly';
  applyTagChipStyle(fly, getTagChipStyleByUid(voterUid));
  fly.style.left = `${source.left}px`;
  fly.style.top = `${source.top}px`;
  fly.style.width = `${source.width}px`;
  fly.style.height = `${source.height}px`;
  document.body.appendChild(fly);

  const dx = target.left - source.left;
  const dy = target.top - source.top;
  fly.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: VOTE_CHIP_MOVE_DURATION,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    fly.remove();
  };
}
function addMovingVoteChip(key){
  const count = movingVoteChips.get(key) || 0;
  movingVoteChips.set(key, count + 1);
}
function removeMovingVoteChip(key){
  const count = movingVoteChips.get(key) || 0;
  if(count <= 1){
    movingVoteChips.delete(key);
    return;
  }
  movingVoteChips.set(key, count - 1);
}
function moveVoteChipElement({ voterUid, fromTargetUid, toTargetUid, sourceRect, attempt = 0 }){
  const movingKey = `${voterUid}:${toTargetUid}`;
  const sourceEl = document.querySelector(
    `.vote-mini[data-voter-uid="${voterUid}"][data-target-uid="${fromTargetUid}"]`
  );
  const moveSourceRect = sourceRect
    || sourceEl?.getBoundingClientRect()
    || getVoteChipSourceRectForMove(voterUid, fromTargetUid)
    || getVoteChipTargetRectForMove(fromTargetUid);
  const targetRect = getVoteChipTargetRectForMove(toTargetUid);
  if(!moveSourceRect || !targetRect){
    if(attempt < 3){
      if(latestPlayers.length) renderPlayerCircle(latestPlayers);
      renderMySweetsVoteStack();
      requestAnimationFrame(() => {
        moveVoteChipElement({ voterUid, fromTargetUid, toTargetUid, sourceRect, attempt: attempt + 1 });
      });
    }
    return;
  }


  addMovingVoteChip(movingKey);
  const existingTargetStack = document.querySelector(`.vote-stack[data-target-uid="${toTargetUid}"]`);
  if(existingTargetStack){
    const duplicate = existingTargetStack.querySelector(`.vote-mini[data-voter-uid="${voterUid}"]`);
    duplicate?.remove();
  }

  if(!sourceEl){
    animateVoteChipRelocate({ voterUid, sourceRect: moveSourceRect, targetUid: toTargetUid });
    setTimeout(() => {
      removeMovingVoteChip(movingKey);
      if(latestPlayers.length) renderPlayerCircle(latestPlayers);
      renderMySweetsVoteStack();
    }, VOTE_CHIP_MOVE_DURATION);
    return;
  }

  const flyEl = sourceEl.cloneNode(true);
  flyEl.style.position = 'fixed';
  flyEl.style.left = `${moveSourceRect.left}px`;
  flyEl.style.top = `${moveSourceRect.top}px`;
  flyEl.style.width = `${moveSourceRect.width}px`;
  flyEl.style.height = `${moveSourceRect.height}px`;
  flyEl.style.margin = '0';
  flyEl.style.zIndex = '999';
  flyEl.style.pointerEvents = 'none';
  flyEl.style.willChange = 'transform';
  document.body.appendChild(flyEl);
  sourceEl.remove();

  const dx = targetRect.left - moveSourceRect.left;
  const dy = targetRect.top - moveSourceRect.top;
  flyEl.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: VOTE_CHIP_MOVE_DURATION,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    const targetStack = document.querySelector(`.vote-stack[data-target-uid="${toTargetUid}"]`);
    if(targetStack){
      sourceEl.dataset.targetUid = toTargetUid;
      targetStack.appendChild(sourceEl);
    } else {
      if(latestPlayers.length) renderPlayerCircle(latestPlayers);
      renderMySweetsVoteStack();
    }
    flyEl.remove();
    removeMovingVoteChip(movingKey);

    if(!targetStack){
      if(latestPlayers.length) renderPlayerCircle(latestPlayers);
      renderMySweetsVoteStack();
    }
  };
}
async function moveVoteChipBetweenTargets(fromTargetUid, toTargetUid, voterUid, options = {}){
  if(!state.roomCode) return false;
  if(!fromTargetUid || !toTargetUid || !voterUid) return false;
  if(fromTargetUid === toTargetUid) return false;

  const base = `rooms/${state.roomCode}/votes`;
  const [fromSnap, toSnap] = await Promise.all([
    get(ref(db, `${base}/${fromTargetUid}/${voterUid}`)),
    get(ref(db, `${base}/${toTargetUid}/${voterUid}`)),
  ]);
  const fromCount = (typeof fromSnap.val() === 'number') ? fromSnap.val() : (fromSnap.exists() ? 1 : 0);
  if(fromCount <= 0) return false;
  const toCount = (typeof toSnap.val() === 'number') ? toSnap.val() : (toSnap.exists() ? 1 : 0);

  const updates = {};
  updates[`${fromTargetUid}/${voterUid}`] = (fromCount > 1) ? (fromCount - 1) : null;
  updates[`${toTargetUid}/${voterUid}`] = toCount + 1;
  await update(ref(db, base), updates);
  return true;
}



/* =========================
   ★★★ PASSボタン表示条件（ラウンド用）
   - 自分の手番
   - 自分がスイーツ獲得済み
   - 自分の投票が済み（voteChips <= 0）
   - 受け取り指示なし
   - まだ自分がPASSしていない
   ========================= */
function myDoneSweetsAndVote(){
  return hasSweets() && (getMyTotalVoteChips() <= 0);
}
function syncPassTurnState(){
  const turnNo = state.turn?.turnNo ?? null;
  if(turnNo !== state.prevTurnNo){
    state.prevTurnNo = turnNo;
    state.passReadyBlockedTurnNo = null;
    state.lastPassEligible = false;
    if(isMyTurn()){
      state.lastPassEligible = myDoneSweetsAndVote() && getActiveInstructionCards().length === 0;
    }
  }
}
function updatePassRoundBtn(){
  const started = !!state.room?.gameStarted;
  const mine = isMyTurn();
  const passed = isPassedPlayerId(state.userId);
  const ending = !!state.game?.roundEnding;
  const eligible = myDoneSweetsAndVote() && getActiveInstructionCards().length === 0;
  if(mine){
    if(!state.lastPassEligible && eligible){
      state.passReadyBlockedTurnNo = state.turn?.turnNo ?? null;
    }
    state.lastPassEligible = eligible;
  } else {
    state.lastPassEligible = false;
  }
  const show = started && mine && !ending && !passed && !state.turnEnding && eligible && state.passReadyBlockedTurnNo !== state.turn?.turnNo;
  passRoundBtn.classList.toggle('visible', show);
  passRoundBtn.disabled = !show;
}

/* =========================
   手札レンダー
   ========================= */
function renderMyRole(){
  const started = !!state.room?.gameStarted;
  if(!started){
    myRoleEl.classList.add('hidden');
    myRoleEl.innerHTML = '';
    return;
  }

  const myRole = state.roles?.[state.userId];
  if(!myRole){
    myRoleEl.classList.add('hidden');
    myRoleEl.innerHTML = '';
    return;
  }
  const info = roleToHelp(myRole);
  myRoleEl.classList.remove('hidden');
  myRoleEl.innerHTML = '';
  myRoleEl.classList.remove('imprison-selectable');
  myRoleEl.onclick = null;
  myRoleEl.onpointerdown = null;
  const img = document.createElement('img');
  img.src = info.img;
  img.alt = info.name;
  myRoleEl.appendChild(img);

  const imprisonedUid = getImprisonedUid();
  if(imprisonedUid && imprisonedUid === state.userId){
    const badge = document.createElement('div');
    badge.className = 'imprisoned-badge';
    const badgeImg = document.createElement('img');
    badgeImg.src = '監禁.jpg';
    badgeImg.alt = '監禁';
    badge.appendChild(badgeImg);
    myRoleEl.appendChild(badge);
  }

  const imprisonSelectable = actionSelection?.type === 'imprison'
    && actionSelection.phase === 'select';
  if(imprisonSelectable){
    const onImprison = (e) => {
      e.stopPropagation();
      handleImprisonCandidate(state.userId);
    };
    myRoleEl.classList.add('imprison-selectable');
    myRoleEl.onpointerdown = onImprison;
    myRoleEl.onclick = onImprison;
  }
}

function renderMySweets(){
  if(!mySweetsSelectHandlersBound){
    mySweetsSelectHandlersBound = true;
    const handleSelect = (e) => {
      if(!actionSelection) return;
      if(actionSelection.type === 'exchange' && actionSelection.phase === 'select'){
        e.stopPropagation();
        handleExchangeCandidate(state.userId);
        return;
      }
      if(actionSelection.type === 'advertise' && actionSelection.phase === 'select'){
        e.stopPropagation();
        handleAdvertiseCandidate(state.userId);
        return;
      }
      if(actionSelection.type === 'accident' && actionSelection.phase === 'select'){
        e.stopPropagation();
        handleAccidentCandidate(state.userId);
      }
    };
    mySweetsEl.addEventListener('pointerdown', handleSelect);
    mySweetsEl.addEventListener('click', handleSelect);
  }

  mySweetsEl.innerHTML = '';
  applyTagChipStyle(mySweetsEl, getTagChipStyleByUid(state.userId));
  mySweetsEl.style.cursor = '';
  mySweetsEl.classList.remove('swap-selectable','swap-selected','advertise-selectable','accident-selectable');

  const c = getMySweetsCard();
  const decidedUids = getDecidedSweetsUids();
  const hasVotes = getVoteVoterIds(state.userId).length > 0;
  const shouldHideCard = !c || collectedSweetsHidden.has(state.userId);

  if(decidedUids.includes(state.userId)){
    mySweetsEl.classList.add('hidden');
    mySweetsEl.innerHTML = '';
    updateRoundPickUI();
    return;
  }

  if(shouldHideCard){
    if(hasVotes){
      mySweetsEl.classList.remove('hidden');
      mySweetsEl.classList.add('empty');
      mySweetsEl.style.visibility = '';
      mySweetsEl.innerHTML = '';
      renderMySweetsVoteStack({ forceEmptySlot: true });
      updateRoundPickUI();
      lastMySweetsSnapshot = null;
      mySweetsFlyAnimatedFor = null;
      return;
    }
    mySweetsEl.classList.add('hidden');
    mySweetsEl.innerHTML = '';
    updateRoundPickUI();
    lastMySweetsSnapshot = null;
    mySweetsFlyAnimatedFor = null;
    return;
  }

  mySweetsFlyAnimatedFor = null;
  mySweetsEl.classList.remove('hidden');
  mySweetsEl.classList.remove('empty');
  mySweetsEl.classList.toggle('swap-hidden', swapHiddenUids.has(state.userId));
  mySweetsEl.dataset.sweetsUid = state.userId;
  const img = document.createElement('img');
  img.src = c.img;
  img.alt = `sweets ${c.value ?? ''}`;
  img.onerror = () => { if(c.fallback) img.src = c.fallback; };
  img.style.pointerEvents = 'none';
  mySweetsEl.appendChild(img);


  const exchangeSelection = actionSelection?.type === 'exchange'
    ? actionSelection
    : null;
  if(exchangeSelection){
    const isSelectable = exchangeSelection.phase === 'select';
    mySweetsEl.classList.toggle('swap-selectable', isSelectable);
    mySweetsEl.classList.toggle(
      'swap-selected',
      Array.isArray(exchangeSelection.selectedUids)
        && exchangeSelection.selectedUids.includes(state.userId)
    );
    if(isSelectable){
      mySweetsEl.style.cursor = 'pointer';
    }
  }

  const advertiseSelection = actionSelection?.type === 'advertise'
    ? actionSelection
    : null;
  if(advertiseSelection){
    const isSelectable = advertiseSelection.phase === 'select';
    mySweetsEl.classList.toggle('advertise-selectable', isSelectable);
    if(isSelectable){
      mySweetsEl.style.cursor = 'pointer';
    }
  }
  const accidentSelection = actionSelection?.type === 'accident'
    ? actionSelection
    : null;
  if(accidentSelection){
    const isSelectable = accidentSelection.phase === 'select';
    mySweetsEl.classList.toggle('accident-selectable', isSelectable);
    if(isSelectable){
      mySweetsEl.style.cursor = 'pointer';
    }
  }


  const advertised = isAdvertised(state.userId);
  if(advertised && shouldPulseAdvertise(state.userId)){
  }
  if(advertised && shouldShowAdvertiseStar(state.userId)){
    const tag = buildAdvertiseNumberTag(c.value);
    if(tag) mySweetsEl.appendChild(tag);
  }
  if(advertised){
    appendAdvertiseEye(mySweetsEl);
  }

  cacheSweetsRectFromElement(state.userId, mySweetsEl);

  // ★ 追加：自分スイーツにも投票ミニを重ねる
  renderMySweetsVoteStack();

  updateRoundPickUI();
  requestAnimationFrame(cacheMySweetsSnapshot);
}

/* ★ カードDOMを作る共通 */
function buildCardEl(cardObj, { extraClass='' } = {}){
  const card = document.createElement('div');
  card.className = 'action-card' + (extraClass ? ` ${extraClass}` : '');
  card.dataset.cardId = cardObj.id;

  const img = document.createElement('img');
  img.className = 'card-img';
  img.src = cardObj.img;
  img.alt = cardObj.name;

  const name = document.createElement('div');
  name.className = 'card-name';
  name.textContent = cardObj.name;

  const frame = document.createElement('div');
  frame.className = 'effect-frame';

  const txt = document.createElement('div');
  txt.className = 'effect-text';
  txt.textContent = cardObj.effectText || '';
  frame.appendChild(txt);

  card.appendChild(img);
  card.appendChild(name);
  card.appendChild(frame);

  requestAnimationFrame(()=> fitEffectText(txt));
  return card;
}

const ACTION_CARD_DRAG_THRESHOLD = 6;
function attachActionCardGesture(cardEl, cardObj, { allowDrag = false } = {}){
  let pointerId = null;
  let startX = 0;
  let startY = 0;
  let moved = false;

  const cleanup = () => {
    cardEl.removeEventListener('pointermove', onPointerMove);
    cardEl.removeEventListener('pointerup', onPointerUp);
    cardEl.removeEventListener('pointercancel', onPointerCancel);
    pointerId = null;
  };

  const onPointerMove = (e) => {
    if(pointerId !== e.pointerId) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    if(!moved && Math.hypot(dx, dy) >= ACTION_CARD_DRAG_THRESHOLD){
      moved = true;
      if(allowDrag && canStartUseCard(cardObj)){
        cleanup();
        startDragCard(e, cardObj, cardEl);
      }
    }
  };

  const onPointerUp = (e) => {
    if(pointerId !== e.pointerId) return;
    cleanup();
    if(!moved){
      openActionZoom(cardObj);
    }
  };

  const onPointerCancel = () => {
    cleanup();
  };

  cardEl.addEventListener('pointerdown', (e) => {
    if(drag.active) return;
    if(e.button !== 0) return;
    pointerId = e.pointerId;
    startX = e.clientX;
    startY = e.clientY;
    moved = false;
    if(allowDrag && canStartUseCard(cardObj)){
      e.preventDefault();
    }
    cardEl.setPointerCapture(e.pointerId);
    cardEl.addEventListener('pointermove', onPointerMove);
    cardEl.addEventListener('pointerup', onPointerUp);
    cardEl.addEventListener('pointercancel', onPointerCancel);
  });
}

function renderMyReceived(){
  myReceivedEl.innerHTML = '';
  const recCards = getMyReceivedCards();
  if(!recCards.length) return;

  const activeIds = new Set(getActiveInstructionCards().map(card => card.id));
  recCards.forEach(rec => {
    const pulse = activeIds.has(rec.id) && rec.name !== '賄賂';
    const shouldLock =
      ((rec.name === '応援' || rec.name === '脅迫') && hasSweets()) ||
      (rec.name === '賄賂' && getMyTotalVoteChips() <= 0);
    const cardEl = buildCardEl(rec, { extraClass: pulse ? 'pulse-only' : '' });
    if(shouldLock) cardEl.classList.add('locked');
    attachActionCardGesture(cardEl, rec);
    myReceivedEl.appendChild(cardEl);
  });
}

function renderMyHand(){
  myHandEl.innerHTML = '';

  const myData = state.hands?.[state.userId];
  if(!myData || !Array.isArray(myData.action)) return;

  const turnBlocked = isInstructionTurnBlocked();

  myData.action.forEach(cardObj => {
    const allowThisCard =
      !turnBlocked || (cardObj.kind === 'instruction' && cardObj.name === '無視');

    const cardEl = buildCardEl(cardObj);
    if(turnBlocked && cardObj.kind === 'instruction' && cardObj.name === '無視'){
      cardEl.classList.add('can-ignore');
    }

    attachActionCardGesture(cardEl, cardObj, { allowDrag: allowThisCard });

    myHandEl.appendChild(cardEl);
  });
}

function applyMyTurnClasses(){
  const wrap = document.querySelector('.my-hand-wrapper');
  if(!wrap) return;

  const mine = isMyTurn();
  const turnBlocked = isInstructionTurnBlocked();
  const roundPickActive = getRoundPick()?.phase === 'choose';

  wrap.classList.remove('my-turn-free','my-turn-blocked','my-turn-selecting');
  if(!mine || roundPickActive) return;

  if(isActionSelectionActive()){
    wrap.classList.add('my-turn-selecting');
    return;
  }

  if(turnBlocked){
    wrap.classList.add('my-turn-blocked');
  }else{
    wrap.classList.add('my-turn-free');
  }
}

function renderHands(){
  renderMyRole();
  renderMySweets();
  renderMyReceived();
  renderMyHand();
  applyMyTurnClasses();
  updateSweetsDeckUI();
  renderMyVoteChip();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  updatePassRoundBtn();
  syncActionDiscardZoneVisibility();
}

function isActionSelectionActive(){
  return !!actionSelection;
}

function updateActionSelectionUI(){
  if(actionExplainPop) actionExplainPop.classList.add('hidden');
  if(actionConfirmPop) actionConfirmPop.classList.add('hidden');
  if(!actionSelection) return;
  if(actionSelection.type === 'imprison'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = '監禁：出品を禁止したいプレイヤーを選択してください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.targetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」の出品を禁止しますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'wiretap'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = '盗聴：見たいプレイヤーの正体カードを選んでください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.targetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」の正体を見ますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'scout'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = '偵察：アクションカードを見たいプレイヤーを選択してください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.targetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」のアクションカードを見ますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'sweetsPeek'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = 'カードを捨てました。見たいスイーツを選んでください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.targetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」のスイーツを見ますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'exchange'){
    const selectedUids = Array.isArray(actionSelection.selectedUids)
      ? actionSelection.selectedUids
      : [];
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = `交換：入れ替えたいスイーツを2枚選んでください。（${selectedUids.length}/2）`;
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const [firstUid, secondUid] = selectedUids;
      const firstName = getPlayerByUid(firstUid)?.name ?? 'プレイヤー';
      const secondName = getPlayerByUid(secondUid)?.name ?? 'プレイヤー';
      if(actionConfirmText){
        actionConfirmText.textContent = `「${firstName}」と「${secondName}」のスイーツを交換しますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'advertise'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = '宣伝：公開したいスイーツを選択してください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.targetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」のスイーツを公開しますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'accident'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = '事故：戻したいスイーツを選択してください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.targetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」のスイーツを戻しますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'rob'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = '強奪：動かす投票チップをドラッグしてください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.toTargetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」のスイーツへ置き換えますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'inspiration'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = 'ひらめき：除外山札からスイーツを選んでください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
  }
  if(actionSelection.type === 'trial'){
    if(actionSelection.phase === 'draw'){
      if(actionExplainPop){
        actionExplainPop.textContent = '試行錯誤：スイーツ山札をクリックして除外山札から1枚戻してください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'select'){
    }
    if(actionSelection.phase === 'confirm'){
      if(actionConfirmText){
        actionConfirmText.textContent = 'このカードを除外しますか。';
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
}

let actionBlockedTimer = null;
function showActionBlockedMessage(message){
  if(!actionExplainPop) return;
  if(actionConfirmPop) actionConfirmPop.classList.add('hidden');
  actionExplainPop.textContent = message;
  actionExplainPop.classList.remove('hidden');
  if(actionBlockedTimer){
    clearTimeout(actionBlockedTimer);
  }
  actionBlockedTimer = setTimeout(() => {
    if(!isActionSelectionActive()){
      actionExplainPop.classList.add('hidden');
    }
    actionBlockedTimer = null;
  }, 1600);
}

function setActionSelection(next){
  actionSelection = next;
  document.body.classList.toggle('rob-active', actionSelection?.type === 'rob' && actionSelection.phase === 'select');
  syncSweetsExcludedFocus();
  updateActionSelectionUI();
  applyMyTurnClasses();
  renderMyRole();
  renderMySweets();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
  if(latestPlayers.length) renderPlayerCircle(latestPlayers);
}

function syncSweetsExcludedFocus(){
  const shouldClear = !(actionSelection?.type === 'inspiration' && actionSelection.phase === 'select');
  if(!shouldClear) return;
  if(!sweetsExcludedFocusActive) return;
  sweetsExcludedFocusActive = false;
  setSweetsExcludedDeckFocus(false);
}

function clearActionSelection(){
  setActionSelection(null);
}

function beginWiretapSelection(){
  const candidates = latestPlayers.filter(p => p.id !== state.userId);
  if(!candidates.length) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'wiretap',
      phase:'select',
      targetUid:null,
      resolve,
    });
  });
}

function beginImprisonSelection(){
  const candidates = latestPlayers;
  if(!candidates.length) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'imprison',
      phase:'select',
      targetUid:null,
      resolve,
    });
  });
}

function beginScoutSelection(){
  const candidates = latestPlayers.filter(p => p.id !== state.userId);
  if(!candidates.length) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'scout',
      phase:'select',
      targetUid:null,
      resolve,
    });
  });
}

function beginExchangeSelection(){
  const candidates = getSweetsOwners();
  if(candidates.length < 2) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'exchange',
      phase:'select',
      selectedUids: [],
      resolve,
    });
  });
}
function beginAdvertiseSelection(){
  const candidates = getSweetsOwners();
  if(candidates.length < 1) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'advertise',
      phase:'select',
      targetUid:null,
      resolve,
    });
  });
}
function beginAccidentSelection(){
  const candidates = getSweetsOwners();
  if(candidates.length < 1) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'accident',
      phase:'select',
      targetUid:null,
      resolve,
    });
  });
}
function beginRobSelection(){
  const candidates = getSweetsOwners();
  if(candidates.length < 2) return Promise.resolve(true);
  const hasVotes = candidates.some(uid => getVoteCountFor(uid) > 0);
  if(!hasVotes) return Promise.resolve(true);
  return new Promise(resolve => {
    setActionSelection({
      type:'rob',
      phase:'select',
      fromTargetUid:null,
      toTargetUid:null,
      voterUid:null,
      sourceRect:null,
      resolve,
    });
  });
}
function beginInspirationSelection(){
  const excluded = state.room?.decks?.sweetsExcluded;
  if(!Array.isArray(excluded) || !excluded.length) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'inspiration',
      phase:'select',
      resolve,
    });
  });
}

function beginTrialSelection(){
  return new Promise(resolve => {
    setActionSelection({
      type:'trial',
      phase:'draw',
      addedIds: [],
      resolve,
    });
  });
}

function handleWiretapCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'wiretap') return;
  if(actionSelection.phase !== 'select') return;
  actionSelection.phase = 'confirm';
  actionSelection.targetUid = uid;
  updateActionSelectionUI();
  if(latestPlayers.length) renderPlayerCircle(latestPlayers);
}

function handleImprisonCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'imprison') return;
  if(actionSelection.phase !== 'select') return;
  actionSelection.phase = 'confirm';
  actionSelection.targetUid = uid;
  updateActionSelectionUI();
  if(latestPlayers.length) renderPlayerCircle(latestPlayers);
  renderMyRole();
}

function handleScoutCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'scout') return;
  if(actionSelection.phase !== 'select') return;
  actionSelection.phase = 'confirm';
  actionSelection.targetUid = uid;
  updateActionSelectionUI();
  if(latestPlayers.length) renderPlayerCircle(latestPlayers);
}

function handleExchangeCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'exchange') return;
  if(actionSelection.phase !== 'select') return;
  if(!getSweetsCardByUid(uid)) return;

  const selected = Array.isArray(actionSelection.selectedUids)
    ? actionSelection.selectedUids
    : [];
  const alreadySelected = selected.includes(uid);
  if(alreadySelected){
    const nextSelected = selected.filter(id => id !== uid);
    setActionSelection({
      ...actionSelection,
      selectedUids: nextSelected,
      phase:'select',
    });
    return;
  }
  if(selected.length >= 2) return;
  const nextSelected = [...selected, uid];
  const nextPhase = (nextSelected.length === 2) ? 'confirm' : 'select';
  setActionSelection({
    ...actionSelection,
    selectedUids: nextSelected,
    phase: nextPhase,
  });
}
function handleAdvertiseCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'advertise') return;
  if(actionSelection.phase !== 'select') return;
  if(!getSweetsCardByUid(uid)) return;
  setActionSelection({
    ...actionSelection,
    phase: 'confirm',
    targetUid: uid,
  });
}
function handleAccidentCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'accident') return;
  if(actionSelection.phase !== 'select') return;
  if(!getSweetsCardByUid(uid)) return;
  setActionSelection({
    ...actionSelection,
    phase: 'confirm',
    targetUid: uid,
  });
}

function handleSweetsPeekCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'sweetsPeek') return;
  if(actionSelection.phase !== 'select') return;
  if(uid === state.userId) return;
  const sweetsCard = getSweetsCardByUid(uid);
  if(!sweetsCard) return;

  setActionSelection({
    ...actionSelection,
    phase: 'confirm',
    targetUid: uid,
  });
}

function removeWiretapArrow(key){
  if(!key) return;
  const existing = activeWiretapArrows.get(key);
  if(!existing) return;
  existing.remove();
  activeWiretapArrows.delete(key);
}

function createWiretapArrow(fromRect, toRect, options = {}){
  if(!fromRect || !toRect) return null;
  const { key = null, duration = 1500, persist = false } = options;
  const x1 = fromRect.left + fromRect.width / 2;
  const y1 = fromRect.top + fromRect.height / 2;
  const x2 = toRect.left + toRect.width / 2;
  const y2 = toRect.top + toRect.height / 2;

  const wrap = document.createElement('div');
  wrap.className = 'wiretap-arrow';

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
  marker.setAttribute('id', 'wiretapArrowHead');
  marker.setAttribute('markerWidth', '10');
  marker.setAttribute('markerHeight', '10');
  marker.setAttribute('refX', '10');
  marker.setAttribute('refY', '5');
  marker.setAttribute('orient', 'auto');
  marker.setAttribute('markerUnits', 'strokeWidth');
  const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
  arrowPath.setAttribute('fill', '#111');
  marker.appendChild(arrowPath);
  defs.appendChild(marker);
  svg.appendChild(defs);
  svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  line.setAttribute('x1', String(x1));
  line.setAttribute('y1', String(y1));
  line.setAttribute('x2', String(x2));
  line.setAttribute('y2', String(y2));
  line.setAttribute('marker-end', 'url(#wiretapArrowHead)');
  svg.appendChild(line);
  wrap.appendChild(svg);

  const eye = document.createElement('div');
  eye.className = 'wiretap-eye';
  eye.textContent = '👀';
  eye.style.left = `${(x1 + x2) / 2}px`;
  eye.style.top = `${(y1 + y2) / 2}px`;
  wrap.appendChild(eye);

  if(key){
    removeWiretapArrow(key);
    activeWiretapArrows.set(key, wrap);
  }

  document.body.appendChild(wrap);
  if(!persist){
    setTimeout(() => {
      if(key && activeWiretapArrows.get(key) !== wrap) return;
      wrap.remove();
      if(key) activeWiretapArrows.delete(key);
    }, duration);
  }
  return () => {
    wrap.remove();
    if(key) activeWiretapArrows.delete(key);
  };
}

function showWiretapArrow(fromSeat, toSeat, options = {}){
  const fromTag = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  const toTag = document.querySelector(`.player-tag[data-seat="${toSeat}"]`);
  if(!fromTag || !toTag) return null;

  const fromRect = fromTag.getBoundingClientRect();
  const toRect = toTag.getBoundingClientRect();
  return createWiretapArrow(fromRect, toRect, options);
}

function showWiretapRoleArrow(fromSeat, targetUid, options = {}){
  const fromTag = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  const roleEl = (targetUid === state.userId)
    ? myRoleEl
    : document.querySelector(`.role-mini[data-uid="${targetUid}"]`);
  if(!fromTag || !roleEl) return null;

  const fromRect = fromTag.getBoundingClientRect();
  const toRect = roleEl.getBoundingClientRect();
  return createWiretapArrow(fromRect, toRect, options);
}

function showScoutArrow(fromSeat, toSeat, options = {}){
  const fromTag = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  if(!fromTag || toSeat === null) return null;

  const mySeat = getSeatByUid(state.userId) ?? state.seatedTable ?? null;
  let targetEl = null;

  if(mySeat !== null && toSeat === mySeat){
    targetEl = myHandEl || document.querySelector('.my-hand');
  }else{
    const toTag = document.querySelector(`.player-tag[data-seat="${toSeat}"]`);
    targetEl = toTag?.querySelector('.mini-hand') || toTag;
  }

  if(!targetEl) return null;
  const fromRect = fromTag.getBoundingClientRect();
  const toRect = targetEl.getBoundingClientRect();
  return createWiretapArrow(fromRect, toRect, options);
}

function showSweetsPeekArrow(fromSeat, targetUid, options = {}){
  const fromTag = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  const sweetsMini = (targetUid === state.userId)
    ? mySweetsEl
    : document.querySelector(`.sweets-wrap[data-sweets-uid="${targetUid}"] .sweets-mini`);
  if(!fromTag || !sweetsMini) return;

  const fromRect = fromTag.getBoundingClientRect();
  const toRect = sweetsMini.getBoundingClientRect();
  createWiretapArrow(fromRect, toRect, { duration: 1500, ...options });
}

function showDiscardedActionCard(cardObj){
  const preview = document.createElement('div');
  preview.className = 'discard-action-preview';
  const img = document.createElement('img');
  img.src = 'swactionura.jpg';
  img.alt = 'action back';
  preview.appendChild(img);
  document.body.appendChild(preview);
  setTimeout(() => {
    preview.remove();
  }, 2000);
}

if(actionConfirmYes){
  actionConfirmYes.addEventListener('click', async () => {
    if(!actionSelection) return;
    if(actionSelection.phase !== 'confirm') return;
    const targetUid = actionSelection.targetUid;
    const resolve = actionSelection.resolve;
    if(actionSelection.type === 'exchange'){
      const selectedUids = Array.isArray(actionSelection.selectedUids)
        ? actionSelection.selectedUids
        : [];
      if(selectedUids.length < 2) return;
      clearActionSelection();
      if(resolve) resolve(selectedUids);
      return;
    }
    if(actionSelection.type === 'rob'){
      const { fromTargetUid, toTargetUid, voterUid, sourceRect } = actionSelection;
      if(!fromTargetUid || !toTargetUid || !voterUid || fromTargetUid === toTargetUid) return;
      clearActionSelection();
      await moveVoteChipBetweenTargets(fromTargetUid, toTargetUid, voterUid, { sourceRect });
      if(resolve) resolve(true);
      return;
    }
    if(actionSelection.type === 'trial'){
      const pendingCard = actionSelection.pendingCard;
      if(!pendingCard || !state.roomCode) return;
      const base = `rooms/${state.roomCode}/decks`;
      const [sweetsSnap, excludedSnap] = await Promise.all([
        get(ref(db, `${base}/sweets`)),
        get(ref(db, `${base}/sweetsExcluded`)),
      ]);
      const sweets = Array.isArray(sweetsSnap.val()) ? sweetsSnap.val() : [];
      const excluded = Array.isArray(excludedSnap.val()) ? excludedSnap.val() : [];
      const nextSweets = sweets.filter(card => card.id !== pendingCard.id);
      const nextExcluded = [...excluded, pendingCard];

      await Promise.all([
        set(ref(db, `${base}/sweets`), nextSweets),
        set(ref(db, `${base}/sweetsExcluded`), nextExcluded),
      ]);

      updateSweetsDeckUI();

      clearTrialDropPreview({ restoreSource: false });
      sweetsPanelLocked = false;
      btnSweetsClose.disabled = false;
      sweetsBackdrop.classList.add('hidden');
      setSweetsPanelMode(SWEETS_PANEL_MODE.PICK);

      await new Promise(resolve => requestAnimationFrame(() => resolve()));
      await emitEvent({ type:'trialSweetsToExcluded' });

      clearActionSelection();
      if(resolve) resolve(true);
      return;
    }
    if(actionSelection.type === 'sweetsPeek'){
      const targetUid = actionSelection.targetUid;
      if(!targetUid) return;
      const sweetsCard = getSweetsCardByUid(targetUid);
      if(!sweetsCard) return;
      setActionSelection({
        ...actionSelection,
        phase: 'reveal',
      });
      const fromSeat = state.turn?.activeSeat ?? state.seatedTable ?? null;
      const arrowId = `sweetsPeek-${state.userId}-${Date.now()}`;
      if(fromSeat !== null){
        await emitEvent({
          type:'sweetsPeekArrowStart',
          fromSeat,
          targetUid,
          fromUid: state.userId,
          arrowId,
        });
      }
      const shouldEnd = await showSweetsPeekReveal(sweetsCard);
      if(fromSeat !== null){
        await emitEvent({
          type:'sweetsPeekArrowEnd',
          fromUid: state.userId,
          arrowId,
        });
      }
      if(shouldEnd){
        clearActionSelection();
        await endTurn('sweetsPeek');
        updateActionDeckUI();
        updateSweetsDeckUI();
        renderMyVoteChip();
        updatePassRoundBtn();
      }
      return;
    }
    clearActionSelection();
    if(resolve) resolve(targetUid);
  });
}
if(actionConfirmNo){
  actionConfirmNo.addEventListener('click', () => {
    if(!actionSelection) return;
    if(actionSelection.phase !== 'confirm') return;
    if(actionSelection.type === 'exchange'){
      setActionSelection({
        ...actionSelection,
        phase:'select',
        selectedUids: [],
      });
      return;
    }
    if(actionSelection.type === 'rob'){
      setActionSelection({
        ...actionSelection,
        phase:'select',
        fromTargetUid:null,
        toTargetUid:null,
        voterUid:null,
        sourceRect:null,
      });
      return;
    }
    if(actionSelection.type === 'trial'){
      clearTrialDropPreview();
      setActionSelection({
        ...actionSelection,
        phase:'select',
        pendingCard: null,
        sourceRect: null,
      });
      openTrialSweetsPicker();
      return;
    }
    if(actionSelection.type === 'sweetsPeek'){
      setActionSelection({
        ...actionSelection,
        phase:'select',
        targetUid: null,
      });
      return;
    }
    actionSelection.phase = 'select';
    actionSelection.targetUid = null;
    updateActionSelectionUI();
    if(latestPlayers.length) renderPlayerCircle(latestPlayers);
    renderMySweets();
  });
}

/* =========================
   プレイヤー円レンダー
   ========================= */
let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;

function renderMySweetsVoteStack({ forceEmptySlot = false } = {}){
  const old = mySweetsEl.querySelector('.vote-stack');
  if(old) old.remove();

  const voterIds = getVoteVoterIds(state.userId);
  if(!voterIds.length) return;

  const c = getMySweetsCard();
  if(!c || forceEmptySlot){
    mySweetsEl.classList.remove('hidden');
    mySweetsEl.classList.add('empty');
    mySweetsEl.style.visibility = '';
    mySweetsEl.innerHTML = '';
  }

  const voteStack = document.createElement('div');
  voteStack.className = 'vote-stack';
  voteStack.dataset.targetUid = state.userId;
  const moveCounts = new Map();

  voterIds.forEach((voterUid) => {
    const key = `${voterUid}:${state.userId}`;
    if(!moveCounts.has(key)){
      moveCounts.set(key, movingVoteChips.get(key) || 0);
    }
    const skipCount = moveCounts.get(key) || 0;
    if(skipCount > 0){
      moveCounts.set(key, skipCount - 1);
      return;
    }
    const v = document.createElement('div');
    v.className = 'vote-mini';
    v.dataset.voterUid = voterUid;
    v.dataset.targetUid = state.userId;
    applyTagChipStyle(v, getTagChipStyleByUid(voterUid));
    if(shouldEnableRobVoteDrag()){
      v.classList.add('rob-selectable');
      v.addEventListener('pointerdown', (e) => startRobVoteDrag(e, v));
    }
    voteStack.appendChild(v);
  });
  mySweetsEl.appendChild(voteStack);
}


function getVoteCountFor(targetUid){
  const obj = state.room?.votes?.[targetUid] || {};
  return Object.values(obj).reduce((sum, count) => {
    if(typeof count !== 'number') return sum + 1;
    return sum + count;
  }, 0);
}
function getImprisonedUid(){
  return state.game?.imprisoned?.uid ?? null;
}
function getEffectiveVoteCountFor(targetUid, votesObj = state.room?.votes){
  const imprisonedUid = getImprisonedUid();
  if(imprisonedUid && imprisonedUid === targetUid) return 0;
  const obj = votesObj?.[targetUid] || {};
  return Object.values(obj).reduce((sum, count) => {
    if(typeof count !== 'number') return sum + 1;
    return sum + count;
  }, 0);
}
function getVoteVoterIds(targetUid){
  const obj = state.room?.votes?.[targetUid] || {};
  const ids = [];
  Object.entries(obj).forEach(([voterUid, count]) => {
    const total = (typeof count === 'number') ? count : 1;
    for(let i = 0; i < total; i++){
      ids.push(voterUid);
    }
  });
  return ids;
}

function roundedStarPath({R=45, r2=20, round=14, k=0.65, points=5}){
  const pts = [];
  for(let i=0;i<points*2;i++){
    const ang = -Math.PI/2 + i*Math.PI/points;
    const rad = (i%2===0) ? R : r2;
    pts.push({x: Math.cos(ang)*rad, y: Math.sin(ang)*rad, outer: i%2===0});
  }

  const prev0 = pts[pts.length-1], cur0 = pts[0];
  const A0 = insetPoint(prev0, cur0, round);
  let d = `M ${A0.x.toFixed(2)} ${A0.y.toFixed(2)} `;

  for(let i=0;i<pts.length;i++){
    const prev = pts[(i-1+pts.length)%pts.length];
    const cur  = pts[i];
    const next = pts[(i+1)%pts.length];

    if(!cur.outer){
      d += `L ${cur.x.toFixed(2)} ${cur.y.toFixed(2)} `;
      continue;
    }

    const A = insetPoint(prev, cur, round);
    const B = insetPoint(next, cur, round);

    d += `L ${A.x.toFixed(2)} ${A.y.toFixed(2)} `;

    const C1 = { x: A.x + (cur.x - A.x)*k, y: A.y + (cur.y - A.y)*k };
    const C2 = { x: B.x + (cur.x - B.x)*k, y: B.y + (cur.y - B.y)*k };

    d += `C ${C1.x.toFixed(2)} ${C1.y.toFixed(2)} `
      +  `${C2.x.toFixed(2)} ${C2.y.toFixed(2)} `
      +  `${B.x.toFixed(2)} ${B.y.toFixed(2)} `;
  }

  d += "Z";
  return d;

  function insetPoint(target, cur, dist){
    const vx = target.x - cur.x, vy = target.y - cur.y;
    const n = Math.hypot(vx, vy) || 1;
    return { x: cur.x + (vx/n)*dist, y: cur.y + (vy/n)*dist };
  }
}

function createRoundedStarSvg(){
  const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
  svg.setAttribute("class","sweets-number-star");
  svg.setAttribute("viewBox","-60 -60 120 120");
  svg.setAttribute("aria-hidden","true");

  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d", roundedStarPath({R:45, r2:20, round:30, k:0.88}));
  path.setAttribute("fill", "#fde047");
  path.setAttribute("stroke", "#111");
  path.setAttribute("stroke-width", "3");
  path.setAttribute("stroke-linejoin", "round");
  path.setAttribute("stroke-linecap", "round");

  svg.appendChild(path);
  return svg;
}
function buildAdvertiseNumberTag(value){
  if(typeof value === 'undefined') return null;
  const tag = document.createElement('div');
  tag.className = 'advertise-number-tag';
  const star = createRoundedStarSvg();
  const valueText = document.createElement('span');
  valueText.className = 'sweets-number-text';
  valueText.textContent = String(value);
  tag.appendChild(star);
  tag.appendChild(valueText);
  return tag;
}
function appendAdvertiseEye(targetEl){
  if(!targetEl) return;
  const eye = document.createElement('div');
  eye.className = 'advertise-eye';
  eye.textContent = '👀';
  targetEl.appendChild(eye);
}
function getAdvertisedSweetsMap(){
  const advertised = state.game?.advertisedSweets;
  return (advertised && typeof advertised === 'object') ? advertised : {};
}
function getAdvertisedEntry(uid){
  if(!uid) return null;
  const advertised = getAdvertisedSweetsMap();
  return advertised?.[uid] ?? null;
}
function isAdvertised(uid){
  return !!getAdvertisedEntry(uid);
}
function shouldPulseAdvertise(uid){
  return advertisedPulseUids.has(uid);
}
function shouldShowAdvertiseStar(uid){
  if(!isAdvertised(uid)) return false;
  if(advertisedStarHiddenUids.has(uid)) return false;
  return advertisedStarReadyUids.has(uid);
}
function clearAdvertiseStateForUid(uid){
  advertisedPulseUids.delete(uid);
  advertisedStarReadyUids.delete(uid);
  advertisedStarHiddenUids.delete(uid);
  advertisedKeyByUid.delete(uid);
  const pulseTimer = advertisedPulseTimers.get(uid);
  if(pulseTimer){
    clearTimeout(pulseTimer);
    advertisedPulseTimers.delete(uid);
  }
  const hideTimer = advertisedStarHideTimers.get(uid);
  if(hideTimer){
    clearTimeout(hideTimer);
    advertisedStarHideTimers.delete(uid);
  }
}
function clearAdvertiseLocalState(){
  [...advertisedKeyByUid.keys()].forEach(uid => clearAdvertiseStateForUid(uid));
  advertisedPulseUids.clear();
  advertisedStarReadyUids.clear();
  advertisedStarHiddenUids.clear();
  advertisedPulseTimers.clear();
  advertisedStarHideTimers.clear();
  advertisedKeyByUid.clear();
}
function startAdvertisePulse(uid, revealedAt){
  advertisedStarHiddenUids.delete(uid);
  advertisedStarReadyUids.delete(uid);
  const pulseTimer = advertisedPulseTimers.get(uid);
  if(pulseTimer){
    clearTimeout(pulseTimer);
    advertisedPulseTimers.delete(uid);
  }
  const nowTime = Date.now();
  const remaining = (typeof revealedAt === 'number')
    ? Math.max(0, ADVERTISE_PULSE_DURATION_MS - (nowTime - revealedAt))
    : ADVERTISE_PULSE_DURATION_MS;
  if(remaining <= 0){
    advertisedPulseUids.delete(uid);
    advertisedStarReadyUids.add(uid);
    return;
  }
  advertisedPulseUids.add(uid);
  const timer = setTimeout(() => {
    advertisedPulseUids.delete(uid);
    advertisedStarReadyUids.add(uid);
    advertisedPulseTimers.delete(uid);
    renderHands();
  }, remaining);
  advertisedPulseTimers.set(uid, timer);
}
function syncAdvertiseEffects(){
  const advertised = getAdvertisedSweetsMap();
  const activeUids = new Set(Object.keys(advertised));
  let shouldRender = false;

  [...advertisedKeyByUid.keys()].forEach(uid => {
    if(!activeUids.has(uid)){
      clearAdvertiseStateForUid(uid);
      shouldRender = true;
    }
  });

  activeUids.forEach(uid => {
    const entry = advertised?.[uid] || {};
    const revealedAt = (typeof entry.revealedAt === 'number') ? entry.revealedAt : null;
    const key = `${uid}:${revealedAt ?? ''}`;
    if(advertisedKeyByUid.get(uid) !== key){
      advertisedKeyByUid.set(uid, key);
      startAdvertisePulse(uid, revealedAt);
      shouldRender = true;
      return;
    }
    if(!advertisedStarReadyUids.has(uid) && typeof revealedAt === 'number'){
      if(Date.now() - revealedAt >= ADVERTISE_PULSE_DURATION_MS){
        advertisedStarReadyUids.add(uid);
        shouldRender = true;
      }
    }
  });

  if(shouldRender) renderHands();
}
function scheduleAdvertiseStarHide(uid){
  if(!isAdvertised(uid)) return;
  if(advertisedStarHiddenUids.has(uid)) return;
  if(advertisedStarHideTimers.has(uid)) return;
  const timer = setTimeout(() => {
    advertisedStarHiddenUids.add(uid);
    advertisedStarHideTimers.delete(uid);
    renderHands();
  }, DECIDED_CENTER_MOVE_DURATION_MS + 20);
  advertisedStarHideTimers.set(uid, timer);
}
const decidedSweetsAnimated = new Map();
const DECIDED_MOVE_DURATION_MS = 650;
const DECIDED_CENTER_DELAY_MS = DECIDED_MOVE_DURATION_MS + 1800;
const DECIDED_CENTER_MOVE_DURATION_MS = 650;
const decidedCenterMoveAnimated = new Map();
const decidedCenterMoveTimers = new Map();
const centerMoveOffsetByKey = new Map();
let centerMoveBatchTimerId = null;
let centerMoveBatchKey = null;
let decidedRoundKey = null;
let decidedRoundStartAt = null;
let lastMySweetsSnapshot = null;
let mySweetsFlyAnimatedFor = null;

function hasCompletedDecidedMove(uid){
  const ts = decidedSweetsAnimated.get(uid);
  if(typeof ts !== 'number') return false;
  return (Date.now() - ts) > DECIDED_MOVE_DURATION_MS;
}

function applyDecidedSweetsMove(items){
  if(!Array.isArray(items) || !items.length) return;
  const playRect = playCircleEl?.getBoundingClientRect?.();
  if(!playRect || !playRect.width || !playRect.height) return;
  const decidedStartAt = getDecidedStartAtForUids(items.map(item => item.uid).filter(Boolean));

  const playCenter = {
    x: playRect.left + playRect.width / 2,
    y: playRect.top + playRect.height / 2,
  };
  const decidedMoveDistance = 80;

  items.forEach(({ uid, sweetsWrap, circle, rotDeg, skipMove }) => {
    if(!sweetsWrap || !circle) return;
    const alreadyAnimated = uid && decidedSweetsAnimated.has(uid);
    const circleRect = circle.getBoundingClientRect();
    const sweetsRect = sweetsWrap.getBoundingClientRect();
    if(!circleRect.width || !circleRect.height || !sweetsRect.width || !sweetsRect.height) return;

    const circleCenter = {
      x: circleRect.left + circleRect.width / 2,
      y: circleRect.top + circleRect.height / 2,
    };
    const sweetsCenter = {
      x: sweetsRect.left + sweetsRect.width / 2,
      y: sweetsRect.top + sweetsRect.height / 2,
    };

    const dx = playCenter.x - circleCenter.x;
    const dy = playCenter.y - circleCenter.y;
    const len = Math.hypot(dx, dy) || 1;
    const targetX = circleCenter.x + (dx / len) * decidedMoveDistance;
    const targetY = circleCenter.y + (dy / len) * decidedMoveDistance;
    const moveX = targetX - sweetsCenter.x;
    const moveY = targetY - sweetsCenter.y;
    const rotRad = (typeof rotDeg === 'number' ? rotDeg : 0) * Math.PI / 180;
    const localMoveX = moveX * Math.cos(-rotRad) - moveY * Math.sin(-rotRad);
    const localMoveY = moveX * Math.sin(-rotRad) + moveY * Math.cos(-rotRad);

    if(skipMove || alreadyAnimated){
      sweetsWrap.classList.add('decided-static');
    }else{
      sweetsWrap.classList.remove('decided-static');
    }
    sweetsWrap.style.setProperty('--decidedMoveX', `${localMoveX}px`);
    sweetsWrap.style.setProperty('--decidedMoveY', `${localMoveY}px`);
    sweetsWrap.classList.add('decided-move');
    if(uid && !decidedSweetsAnimated.has(uid)){
      decidedSweetsAnimated.set(uid, decidedStartAt);
    }

  });
}

function parseRotationDegrees(value){
  if(!value) return 0;
  const num = parseFloat(value);
  return Number.isFinite(num) ? num : 0;
}

function getCenterMoveOffsetKey(uid, slot){
  if(!uid || !slot) return null;
  return `${uid}:${slot}`;
}

function computeCenterMoveOffset(cardEl, rotDeg){
  if(!cardEl || !playerCircle) return null;
  const circleRect = playerCircle.getBoundingClientRect();
  const cardRect = cardEl.getBoundingClientRect();
  if(!circleRect.width || !circleRect.height || !cardRect.width || !cardRect.height) return null;

  const circleCenter = {
    x: circleRect.left + circleRect.width / 2,
    y: circleRect.top + circleRect.height / 2,
  };
  const cardCenter = {
    x: cardRect.left + cardRect.width / 2,
    y: cardRect.top + cardRect.height / 2,
  };
  let moveX = circleCenter.x - cardCenter.x;
  let moveY = circleCenter.y - cardCenter.y;

  if(rotDeg){
    const rotRad = rotDeg * Math.PI / 180;
    const localMoveX = moveX * Math.cos(-rotRad) - moveY * Math.sin(-rotRad);
    const localMoveY = moveX * Math.sin(-rotRad) + moveY * Math.cos(-rotRad);
    moveX = localMoveX;
    moveY = localMoveY;
  }
  return { x: moveX, y: moveY };
}

function applyCenterMoveToCard(cardEl, hostEl, rotDeg, startedAt, offsetKey){
  if(!cardEl || !playerCircle) return;
  let offset = null;
  if(offsetKey && centerMoveOffsetByKey.has(offsetKey)){
    offset = centerMoveOffsetByKey.get(offsetKey);
  }else{
    offset = computeCenterMoveOffset(cardEl, rotDeg);
    if(!offset) return;
    if(offsetKey) centerMoveOffsetByKey.set(offsetKey, offset);
  }

  cardEl.style.setProperty('--centerMoveX', `${offset.x}px`);
  cardEl.style.setProperty('--centerMoveY', `${offset.y}px`);
  cardEl.classList.add('center-move');
  if(hostEl){
    hostEl.classList.add('center-move-host');
  }

  if(typeof startedAt === 'number' && (Date.now() - startedAt) > DECIDED_CENTER_MOVE_DURATION_MS){
    cardEl.classList.add('center-static');
  }else{
    cardEl.classList.remove('center-static');
  }
}

function applyCenterMoveForUid(uid){
  const startedAt = decidedCenterMoveAnimated.get(uid);
  const tagEl = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"]`);
  if(tagEl){
    const cardEl = tagEl.querySelector('.selected-sweets-card');
    const offsetKey = getCenterMoveOffsetKey(uid, 'tag');
    applyCenterMoveToCard(cardEl, tagEl, 0, startedAt, offsetKey);
  }

  const wrapEl = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"]`);
  if(wrapEl){
    const cardEl = wrapEl.querySelector('.sweets-mini');
    const circle = wrapEl.closest('.otherplayerscircle');
    const rotDeg = circle
      ? parseRotationDegrees(getComputedStyle(circle).getPropertyValue('--rotDeg').trim())
      : 0;
    const offsetKey = getCenterMoveOffsetKey(uid, 'wrap');
    applyCenterMoveToCard(cardEl, wrapEl, rotDeg, startedAt, offsetKey);
  }
  scheduleAdvertiseStarHide(uid);
}

function getLatestDecidedAt(uids){
  const list = Array.isArray(uids) ? uids : [];
  const key = [...list].sort().join(',');
  if(decidedRoundStartAt && key === decidedRoundKey){
    return decidedRoundStartAt;
  }
  const times = list
    .map(uid => decidedSweetsAnimated.get(uid))
    .filter(ts => typeof ts === 'number');
  return times.length ? Math.max(...times) : Date.now();
}
function getLatestAppliedDecidedAt(uids){
  const list = Array.isArray(uids) ? uids : [];
  const times = list
    .map(uid => decidedSweetsAnimated.get(uid))
    .filter(ts => typeof ts === 'number');
  return times.length ? Math.max(...times) : Date.now();
}

function waitForDecidedTimestamps(uids, timeoutMs = 1200){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return Promise.resolve();
  const start = Date.now();
  return new Promise(resolve => {
    const tick = () => {
      const missing = list.some(uid => !decidedSweetsAnimated.has(uid));
      if(!missing || (Date.now() - start) >= timeoutMs){
        resolve();
        return;
      }
      setTimeout(tick, 50);
    };
    tick();
  });
}


function scheduleCenterMovesForUids(uids){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return;
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'done') return;
  const allCentered = list.every(uid => decidedCenterMoveAnimated.has(uid));
  if(allCentered) return;
  const key = [...list].sort().join(',');
  if(centerMoveBatchTimerId && centerMoveBatchKey === key) return;
  if(centerMoveBatchTimerId){
    clearTimeout(centerMoveBatchTimerId);
    centerMoveBatchTimerId = null;
  }
  centerMoveBatchKey = key;

  const latestDecidedAt = getLatestDecidedAt(list);
  const delay = Math.max(0, latestDecidedAt + DECIDED_CENTER_DELAY_MS - Date.now());

  centerMoveBatchTimerId = setTimeout(() => {
    centerMoveBatchTimerId = null;
    const startedAt = Date.now();
    list.forEach(uid => {
      if(decidedCenterMoveAnimated.has(uid)) return;
      decidedCenterMoveAnimated.set(uid, startedAt);
      applyCenterMoveForUid(uid);
    });
  }, delay);
}

function ensureDecidedRoundStart(uids){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return;
  const key = [...list].sort().join(',');
  if(decidedRoundKey === key) return;
  decidedRoundKey = key;
  decidedRoundStartAt = Date.now();
}

function getDecidedStartAtForUids(uids){
  const list = Array.isArray(uids) ? uids : [];
  const key = [...list].sort().join(',');
  if(decidedRoundStartAt && key === decidedRoundKey){
    return decidedRoundStartAt;
  }
  return Date.now();
}

function cacheMySweetsSnapshot(){
  const card = getMySweetsCard();
  if(!card || mySweetsEl.classList.contains('hidden')) return;
  const rect = mySweetsEl.getBoundingClientRect();
  if(!rect.width || !rect.height) return;
  lastMySweetsSnapshot = {
    rect,
    cardId: card.id,
  };
}

function animateMySweetsToTag(targetEl, card){
  if(!targetEl || !card || !lastMySweetsSnapshot) return;
  if(mySweetsFlyAnimatedFor === card.id) return;
  const srcRect = lastMySweetsSnapshot.rect;
  const tagEl = targetEl.classList.contains('selected-sweets-tag')
    ? targetEl
    : targetEl.closest('.selected-sweets-tag');
  const dstRect = targetEl.getBoundingClientRect();
  if(!srcRect.width || !srcRect.height || !dstRect.width || !dstRect.height) return;
  let moveYAdjust = 0;
  if(tagEl){
    const moveYValue = getComputedStyle(tagEl).getPropertyValue('--sweetsTagMoveY').trim();
    const parsedMoveY = parseFloat(moveYValue);
    if(Number.isFinite(parsedMoveY)){
      moveYAdjust = parsedMoveY;
    }
  }

  const fly = document.createElement('div');
  fly.className = 'sweets-fly-card';
  fly.style.left = `${srcRect.left}px`;
  fly.style.top = `${srcRect.top}px`;
  fly.style.width = `${srcRect.width}px`;
  fly.style.height = `${srcRect.height}px`;

  const img = document.createElement('img');
  img.src = card.img;
  img.alt = `sweets ${card.value ?? ''}`;
  img.onerror = () => { if(card.fallback) img.src = card.fallback; };
  fly.appendChild(img);

  document.body.appendChild(fly);

  const dx = dstRect.left - srcRect.left;
  const dy = (dstRect.top + moveYAdjust) - srcRect.top;
  const scale = dstRect.width / srcRect.width;

  fly.animate([
    { transform:`translate(0px, 0px) scale(1)` },
    { transform:`translate(${dx}px, ${dy}px) scale(${scale})` },
  ], {
    duration: DECIDED_MOVE_DURATION_MS,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => fly.remove();

  mySweetsFlyAnimatedFor = card.id;
}

const SWAP_MOVE_DURATION_MS = 650;
const swapHiddenUids = new Set();

function getSwapRotationDeg(el){
  if(!el) return 0;
  const rowEl = el.closest('.other-cards-row');
  if(!rowEl) return 0;
  const rotValue = getComputedStyle(rowEl).getPropertyValue('--rotDeg').trim();
  const rotDeg = parseFloat(rotValue);
  return Number.isFinite(rotDeg) ? rotDeg : 0;
}

function getSwapBorderRadius(el){
  if(!el) return '12px';
  const radius = getComputedStyle(el).borderRadius;
  return radius && radius !== '0px' ? radius : '12px';
}

function getSwapSweetsTarget(uid){
  const candidates = [];
  if(uid === state.userId && mySweetsEl){
    candidates.push(mySweetsEl);
  }
  const miniEl = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"] .sweets-mini`);
  if(miniEl) candidates.push(miniEl);
  const decidedEl = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"] .selected-sweets-card`);
  if(decidedEl) candidates.push(decidedEl);

  for(const el of candidates){
    if(!el || el.classList.contains('hidden')) continue;
    const rect = el.getBoundingClientRect();
    const width = el.offsetWidth || rect.width;
    const height = el.offsetHeight || rect.height;
    if(rect && width && height){
      const wrapEl = el.classList.contains('sweets-mini') ? el.closest('.sweets-wrap') : null;
      return {
        el,
        wrapEl,
        rect,
        width,
        height,
        rotationDeg: getSwapRotationDeg(el),
        borderRadius: getSwapBorderRadius(el),
      };
    }
  }
  return null;
}



function createSwapFlyCard(rect, size, borderRadius){
  if(!rect || !size) return null;
  const fly = document.createElement('div');
  fly.className = 'sweets-fly-card';
  fly.style.left = `${rect.left + (rect.width - size.width) / 2}px`;
  fly.style.top = `${rect.top + (rect.height - size.height) / 2}px`;
  fly.style.width = `${size.width}px`;
  fly.style.height = `${size.height}px`;
  if(borderRadius){
    fly.style.borderRadius = borderRadius;
  }

  const img = document.createElement('img');
  img.src = SWEETS_BACK_IMG;
  img.alt = 'sweets back';
  img.onerror = () => { img.src = SWEETS_BACK_IMG; };
  fly.appendChild(img);

  document.body.appendChild(fly);
  return fly;
}

function animateSwapFly(fly, fromRect, toRect, options = {}){
  if(!fly || !fromRect || !toRect) return;
  const {
    scaleToTarget = false,
    fromRotationDeg = 0,
    toRotationDeg = 0,
  } = options;
  const dx = toRect.left - fromRect.left;
  const dy = toRect.top - fromRect.top;
  const scaleX = scaleToTarget ? (toRect.width / fromRect.width) : 1;
  const scaleY = scaleToTarget ? (toRect.height / fromRect.height) : 1;
  const rotateMid = fromRotationDeg + (toRotationDeg - fromRotationDeg) * 0.5 + (dx >= 0 ? 8 : -8);

  fly.animate([
    { transform:`translate(0px, 0px) rotate(${fromRotationDeg}deg) scale(1, 1)` },
    { transform:`translate(${dx * 0.5}px, ${dy * 0.5}px) rotate(${rotateMid}deg) scale(${(1 + scaleX) / 2}, ${(1 + scaleY) / 2})` },
    { transform:`translate(${dx}px, ${dy}px) rotate(${toRotationDeg}deg) scale(${scaleX}, ${scaleY})` },
  ], {
    duration: SWAP_MOVE_DURATION_MS,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => fly.remove();
}

function animateSweetsSwap({ fromUid, toUid, fromCard, toCard }){
  if(!fromUid || !toUid) return;
  const fromTarget = getSwapSweetsTarget(fromUid);
  const toTarget = getSwapSweetsTarget(toUid);
  if(!fromTarget || !toTarget) return;

  const shouldScale = (fromUid === state.userId || toUid === state.userId)
    && (Math.abs(fromTarget.width - toTarget.width) > 0.5
      || Math.abs(fromTarget.height - toTarget.height) > 0.5);
  swapHiddenUids.add(fromUid);
  swapHiddenUids.add(toUid);
  const hiddenEls = new Set();
  const collectHiddenEls = (uid) => {
    document.querySelectorAll(`[data-sweets-uid="${uid}"]`).forEach((el) => hiddenEls.add(el));
    document.querySelectorAll(`.sweets-wrap[data-sweets-uid="${uid}"] .sweets-mini`).forEach((el) => hiddenEls.add(el));
    document.querySelectorAll(`.sweets-wrap[data-sweets-uid="${uid}"] .vote-stack`).forEach((el) => hiddenEls.add(el));
    document.querySelectorAll(`.selected-sweets-tag[data-sweets-uid="${uid}"] *`).forEach((el) => hiddenEls.add(el));
  };
  collectHiddenEls(fromUid);
  collectHiddenEls(toUid);
  hiddenEls.add(fromTarget.el);
  hiddenEls.add(fromTarget.wrapEl);
  hiddenEls.add(toTarget.el);
  hiddenEls.add(toTarget.wrapEl);
  const uniqHiddenEls = Array.from(hiddenEls).filter(Boolean);
  uniqHiddenEls.forEach((el) => {
    if(el.dataset.swapHidden) return;
    el.dataset.swapHidden = '1';
    el.dataset.swapHiddenVisibility = el.style.visibility || '';
    el.dataset.swapHiddenOpacity = el.style.opacity || '';
    el.dataset.swapHiddenBackground = el.style.background || '';
    el.dataset.swapHiddenBoxShadow = el.style.boxShadow || '';

    el.style.visibility = 'hidden';
   el.style.opacity = '0';
    if(el.classList.contains('sweets-wrap') || el.classList.contains('sweets-mini') || el.classList.contains('selected-sweets-card')){
      el.style.background = 'transparent';
      el.style.boxShadow = 'none';
    }

  });
  const flyFrom = createSwapFlyCard(fromTarget.rect, {
    width: fromTarget.width,
    height: fromTarget.height,
  }, fromTarget.borderRadius);
  const flyTo = createSwapFlyCard(toTarget.rect, {
    width: toTarget.width,
    height: toTarget.height,
  }, toTarget.borderRadius);
  animateSwapFly(flyFrom, {
    left: fromTarget.rect.left + (fromTarget.rect.width - fromTarget.width) / 2,
    top: fromTarget.rect.top + (fromTarget.rect.height - fromTarget.height) / 2,
    width: fromTarget.width,
    height: fromTarget.height,
  }, {
    left: toTarget.rect.left + (toTarget.rect.width - toTarget.width) / 2,
    top: toTarget.rect.top + (toTarget.rect.height - toTarget.height) / 2,
    width: toTarget.width,
    height: toTarget.height,
  }, {
    scaleToTarget: shouldScale,
    fromRotationDeg: fromTarget.rotationDeg,
    toRotationDeg: toTarget.rotationDeg,
  });
  animateSwapFly(flyTo, {
    left: toTarget.rect.left + (toTarget.rect.width - toTarget.width) / 2,
    top: toTarget.rect.top + (toTarget.rect.height - toTarget.height) / 2,
    width: toTarget.width,
    height: toTarget.height,
  }, {
    left: fromTarget.rect.left + (fromTarget.rect.width - fromTarget.width) / 2,
    top: fromTarget.rect.top + (fromTarget.rect.height - fromTarget.height) / 2,
    width: fromTarget.width,
    height: fromTarget.height,
  }, {
    scaleToTarget: shouldScale,
    fromRotationDeg: toTarget.rotationDeg,
    toRotationDeg: fromTarget.rotationDeg,
  });
  window.setTimeout(() => {
    swapHiddenUids.delete(fromUid);
    swapHiddenUids.delete(toUid);
   const clearSwapHiddenClass = (uid) => {
      document.querySelectorAll(`[data-sweets-uid="${uid}"]`).forEach((el) => el.classList.remove('swap-hidden'));
      document.querySelectorAll(`.sweets-wrap[data-sweets-uid="${uid}"]`).forEach((el) => el.classList.remove('swap-hidden'));
      document.querySelectorAll(`.selected-sweets-tag[data-sweets-uid="${uid}"]`).forEach((el) => el.classList.remove('swap-hidden'));
    };
    clearSwapHiddenClass(fromUid);
    clearSwapHiddenClass(toUid);

    uniqHiddenEls.forEach((el) => {
      if(!el || el.dataset.swapHidden !== '1') return;
      el.style.visibility = el.dataset.swapHiddenVisibility || '';
      el.style.opacity = el.dataset.swapHiddenOpacity || '';
      el.style.background = el.dataset.swapHiddenBackground || '';
      el.style.boxShadow = el.dataset.swapHiddenBoxShadow || '';

      delete el.dataset.swapHidden;
      delete el.dataset.swapHiddenVisibility;
      delete el.dataset.swapHiddenOpacity;
      delete el.dataset.swapHiddenBackground;
      delete el.dataset.swapHiddenBoxShadow;

    });
  }, SWAP_MOVE_DURATION_MS);
}


function renderPlayerCircle(players){
  playerCircle.innerHTML = '';

  // ★ 中央リーダーボード → ★ playCircle の順で復元
  if(leaderboardBoardEl) playerCircle.appendChild(leaderboardBoardEl);
  playerCircle.appendChild(playCircleEl);

  // ★ 人数でボード画像を切り替え（席に着いてる人数）
  updateLeaderboardBoardByPlayerCount(players?.length || 0);
  updateRequiredSweetsTag();
  document.body.classList.toggle('imprison-active', !!getImprisonedUid());

  if (!players.length) return;

  const n = players.length;
  const radius = 42;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);
  const decidedMoveTargets = [];

  const allPassed = allSeatedPlayersPassed();
  const leaderSeat = state.turn?.leaderSeat ?? null;
  const activeSeat = allPassed ? null : (state.turn?.activeSeat ?? null);
  const roundPick = getRoundPick();
  const roundPickActive = roundPick?.phase === 'choose';
  const roundPickCandidates = roundPickActive && Array.isArray(roundPick.candidates)
    ? roundPick.candidates
    : [];
  const roundPickCanSelect = roundPickActive && roundPick?.leaderId === state.userId;
  const leaderPick = getLeaderPick();
  const leaderPickActive = leaderPick?.phase === 'choose';
  const leaderPickCandidates = leaderPickActive && Array.isArray(leaderPick.candidates)
    ? leaderPick.candidates
    : [];
  const leaderPickCanSelect = leaderPickActive && leaderPick?.leaderId === state.userId;
  const sweetsFocusUid = getSweetsDeckFocus()?.uid ?? null;
  const excludedFocusUid = getSweetsExcludedDeckFocus()?.uid ?? null;
  const voteHoldActive = shouldHoldVoteChips();
  const decidedUids = getDecidedSweetsUids();
  const started = !!state.room?.gameStarted;
  if(roundPick?.phase === 'done' && decidedUids.length){
    ensureDecidedRoundStart(decidedUids);
  }

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    // ===== 自分 =====
    if(p.id === state.userId){
      const tag = document.createElement('div');
      tag.className = 'player-tag me';
      const namePill = document.createElement('span');
      namePill.className = 'name-pill';
      namePill.textContent = p.name;
      tag.appendChild(namePill);
      tag.style.left = `${x}%`;
      tag.style.top = `${y}%`;
      tag.dataset.seat = String(p.seatIndex);
      tag.dataset.uid = p.id;
      applyTagChipStyle(tag, p.tagChipStyle);

      if(leaderPickCanSelect && leaderPickCandidates.includes(state.userId)){
        tag.classList.add('leader-pick-selectable');
        tag.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          requestLeaderPick(state.userId);
        });
        tag.onclick = (e) => {
          e.stopPropagation();
          requestLeaderPick(state.userId);
        };
      }

      playerCircle.appendChild(tag);

      if(leaderSeat !== null && leaderSeat === p.seatIndex){
        const chip = document.createElement('div');
        chip.className = 'leader-chip';
        tag.appendChild(chip);
      }
      // 自分の投票チップ表示はスイーツ枠側で管理
      if(started && decidedUids.includes(state.userId)){
        const sweetsCard = getSweetsCardByUid(state.userId);
        if(sweetsCard){
          const advertised = isAdvertised(state.userId);
          const isCollectHidden = collectedSweetsHidden.has(state.userId);
          const selected = document.createElement('div');
          selected.className = 'selected-sweets-tag';
          let decidedStartedAt = decidedSweetsAnimated.get(state.userId);
          if(typeof decidedStartedAt !== 'number'){
            decidedStartedAt = getDecidedStartAtForUids(decidedUids);
            decidedSweetsAnimated.set(state.userId, decidedStartedAt);
          }
          const canAnimateMySweets = !!(lastMySweetsSnapshot && lastMySweetsSnapshot.cardId === sweetsCard.id);
          const animationCompleted = hasCompletedDecidedMove(state.userId);
          const shouldAnimateMySweets = !animationCompleted
            && canAnimateMySweets
            && mySweetsFlyAnimatedFor !== sweetsCard.id;
          if(animationCompleted || !shouldAnimateMySweets){
            selected.classList.add('decided-static');
          }else{
            selected.classList.add('delayed-show');
          }
         if(isCollectHidden){
            selected.classList.add('collect-hidden');
          }
          if(swapHiddenUids.has(state.userId)){
            selected.classList.add('swap-hidden');
          }
          selected.dataset.sweetsUid = state.userId;
          const cardWrap = document.createElement('div');
          cardWrap.className = 'selected-sweets-card';
          const img = document.createElement('img');
          img.src = advertised ? sweetsCard.img : SWEETS_BACK_IMG;
          img.alt = `sweets ${sweetsCard.value ?? ''}`;
          img.onerror = () => { if(sweetsCard.fallback) img.src = sweetsCard.fallback; };
          cardWrap.appendChild(img);

         const showValueTag = !advertised || shouldShowAdvertiseStar(state.userId);
          if(typeof sweetsCard.value !== 'undefined' && showValueTag){
            const valueTag = document.createElement('div');
            valueTag.className = 'sweets-number-tag';
            const star = createRoundedStarSvg();
            const valueText = document.createElement('span');
            valueText.className = 'sweets-number-text';
            valueText.textContent = String(sweetsCard.value);
            valueTag.appendChild(star);
            valueTag.appendChild(valueText);
            cardWrap.appendChild(valueTag);
          }
          if(advertised && shouldPulseAdvertise(state.userId)){
          }
          if(advertised){
            appendAdvertiseEye(cardWrap);
          }
          selected.appendChild(cardWrap);

         const voterIds = getVoteVoterIds(state.userId);
          if(voterIds.length){
            const voteStack = document.createElement('div');
            voteStack.className = 'vote-stack';
            voteStack.dataset.targetUid = state.userId;
            voterIds.forEach((voterUid) => {
              const v = document.createElement('div');
              v.className = 'vote-mini';
              v.dataset.voterUid = voterUid;
              v.dataset.targetUid = state.userId;
              applyTagChipStyle(v, getTagChipStyleByUid(voterUid));
              if(shouldEnableRobVoteDrag()){
                v.classList.add('rob-selectable');
                v.addEventListener('pointerdown', (e) => startRobVoteDrag(e, v));
              }
              voteStack.appendChild(v);
            });
            selected.appendChild(voteStack);
         }
          tag.appendChild(selected);
          if(shouldAnimateMySweets){
            requestAnimationFrame(() => {
              animateMySweetsToTag(selected, sweetsCard);
            });
          }
          if(!animationCompleted && shouldAnimateMySweets){
            const remaining = Math.max(0, DECIDED_MOVE_DURATION_MS - (Date.now() - decidedStartedAt));
            setTimeout(() => {
              selected.classList.remove('delayed-show');
            }, remaining);
          }else{
            selected.classList.remove('delayed-show');
          }
         if(decidedCenterMoveAnimated.has(state.userId)){
            requestAnimationFrame(() => {
              applyCenterMoveForUid(state.userId);
            });
          }
        }
      }
      return;
    }


// ===== 他プレイヤー =====
const circle = document.createElement('div');
circle.className = 'otherplayerscircle';
circle.style.left = `${x}%`;
circle.style.top  = `${y}%`;
applyTagChipStyle(circle, p.tagChipStyle);

// ★ 中心方向（内側）ベクトル：(-cos, -sin)
const ux = -Math.cos(angle);
const uy = -Math.sin(angle);

// 内側/外側のオフセット（px）
const innerOff = 20;  // カードを内側へ
const outerOff = 44;  // タグを外側へ

circle.style.setProperty('--inX',  `${ux * innerOff}px`);
circle.style.setProperty('--inY',  `${uy * innerOff}px`);
circle.style.setProperty('--outX', `${-ux * outerOff}px`);
circle.style.setProperty('--outY', `${-uy * outerOff}px`);

// ★ カードの「上辺」が中心を向く回転（CSS rotate）
const rotDeg = (Math.atan2(uy, ux) * 180 / Math.PI) + 90;
circle.style.setProperty('--rotDeg', `${rotDeg}deg`);

const tag = document.createElement('div');
tag.className = 'player-tag in-othercircle';

const namePill = document.createElement('span');
namePill.className = 'name-pill';
namePill.textContent = p.name;
tag.appendChild(namePill);
tag.dataset.seat = String(p.seatIndex);
tag.dataset.uid = p.id;
applyTagChipStyle(tag, p.tagChipStyle);
const isRightSide = x > 50;
tag.classList.toggle('right-side', isRightSide);

const leaderPickSelectable = leaderPickCanSelect && leaderPickCandidates.includes(p.id);
  if(leaderPickSelectable){
    tag.classList.add('leader-pick-selectable');
    if(p.id !== state.userId){
      tag.classList.add('leader-pick-candidate');
    }
    tag.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    });
    tag.onclick = (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    };
    circle.onclick = (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    };
  }

const scoutSelectable = actionSelection?.type === 'scout'
  && actionSelection.phase === 'select'
  && p.id !== state.userId;

// 追い出しクリックは今まで通り
const onKick = () => {
  if (!state.roomCode) return;
  if (state.seatedTable !== null) return;

  pendingSeatIndexToSteal = p.seatIndex;
  pendingSeatPlayerIdToSteal = p.id;
  kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
  kickDialog.classList.remove('hidden');
};
if(scoutSelectable){
  const onScout = (e) => {
    e.stopPropagation();
    handleScoutCandidate(p.id);
  };
  circle.onclick = onScout;
  tag.onclick = onScout;
}else{
  circle.onclick = (e) => { e.stopPropagation(); onKick(); };
  tag.onclick = (e) => { e.stopPropagation(); onKick(); };
}

if(activeSeat === p.seatIndex && p.id !== state.userId){
  tag.classList.add('active-turn');
  namePill.classList.add('active-turn');
}

circle.appendChild(tag);

// handData は後でミニ手札にも使うので先に取る
const handData = state.hands?.[p.id];
const roleAssigned = !!state.roles?.[p.id];
const voteChips = getPlayerTotalVoteChips(p.id);
let roleMini = null;

if(started && roleAssigned){
  roleMini = document.createElement('div');
  roleMini.className = 'role-mini other-role-mini';
  roleMini.dataset.uid = p.id;

  const roleFrame = document.createElement('div');
  roleFrame.className = 'role-mini-frame';
  const roleImg = document.createElement('img');
  roleImg.src = 'swroleura.jpg';
  roleImg.alt = 'role';
  roleFrame.appendChild(roleImg);
  roleMini.appendChild(roleFrame);

  if(actionSelection?.type === 'wiretap' && actionSelection.phase === 'select' && p.id !== state.userId){
    roleMini.classList.add('wiretap-selectable');
    roleMini.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      handleWiretapCandidate(p.id);
    });
    roleMini.onclick = (e) => {
      e.stopPropagation();
      handleWiretapCandidate(p.id);
    };
  }
  if(actionSelection?.type === 'imprison' && actionSelection.phase === 'select'){
    roleMini.classList.add('imprison-selectable');
    roleMini.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      handleImprisonCandidate(p.id);
    });
    roleMini.onclick = (e) => {
      e.stopPropagation();
      handleImprisonCandidate(p.id);
    };
  }

  const imprisonedUid = getImprisonedUid();
  if(imprisonedUid && imprisonedUid === p.id){
    const badge = document.createElement('div');
    badge.className = 'imprisoned-badge';
    const badgeImg = document.createElement('img');
    badgeImg.src = '監禁.jpg';
    badgeImg.alt = '監禁';
    badge.appendChild(badgeImg);
    roleMini.appendChild(badge);
  }

  const receivedCount = Array.isArray(handData?.received) ? handData.received.length : 0;
  if(receivedCount > 0 && p.id !== state.userId){
    const stack = document.createElement('div');
    stack.className = 'received-instruction-stack';
    for(let idx = 0; idx < receivedCount; idx += 1){
      const card = document.createElement('div');
      card.className = 'received-instruction-card';
      card.style.transform = `rotate(${idx * 10}deg)`;
      card.style.zIndex = String(10 + idx);
      stack.appendChild(card);
    }
    roleMini.appendChild(stack);
  }
  tag.appendChild(roleMini);


  const hasTheirSweets = !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);
  const showVoteHold = (!hasTheirSweets && getVoteCountFor(p.id) > 0) || (voteHoldActive && getVoteCountFor(p.id) > 0);
  const sweetsCard = getSweetsCardByUid(p.id);

  const showSweetsSlot = hasTheirSweets || showVoteHold || sweetsFocusUid === p.id || excludedFocusUid === p.id;
  if(showSweetsSlot){
    const cardsRow = document.createElement('div');
    cardsRow.className = 'other-cards-row';

    const sweetsWrap = document.createElement('div');
    sweetsWrap.className = 'sweets-wrap';
    sweetsWrap.dataset.sweetsUid = p.id;
    sweetsWrap.classList.toggle('empty', !hasTheirSweets);
    sweetsWrap.classList.toggle('swap-hidden', swapHiddenUids.has(p.id));
    const exchangeSelection = actionSelection?.type === 'exchange'
      ? actionSelection
      : null;
    const exchangeSelectable = exchangeSelection?.phase === 'select';
    if(exchangeSelection && hasTheirSweets){
      const selectedUids = Array.isArray(exchangeSelection.selectedUids)
        ? exchangeSelection.selectedUids
        : [];
      sweetsWrap.classList.toggle('swap-selectable', exchangeSelectable);
      sweetsWrap.classList.toggle('swap-selected', selectedUids.includes(p.id));
      if(exchangeSelectable){
        const onExchange = (e) => {
          e.stopPropagation();
          handleExchangeCandidate(p.id);
        };
        sweetsWrap.addEventListener('pointerdown', onExchange);
        sweetsWrap.onclick = onExchange;
      }
    }
    const advertiseSelection = actionSelection?.type === 'advertise'
      ? actionSelection
      : null;
    const advertiseSelectable = advertiseSelection?.phase === 'select';
    if(advertiseSelection && hasTheirSweets){
      sweetsWrap.classList.toggle('advertise-selectable', advertiseSelectable);
      if(advertiseSelectable){
        const onAdvertise = (e) => {
          e.stopPropagation();
          handleAdvertiseCandidate(p.id);
        };
        sweetsWrap.addEventListener('pointerdown', onAdvertise);
        sweetsWrap.onclick = onAdvertise;
      }
    }
    const accidentSelection = actionSelection?.type === 'accident'
      ? actionSelection
      : null;
    const accidentSelectable = accidentSelection?.phase === 'select';
    if(accidentSelection && hasTheirSweets){
      sweetsWrap.classList.toggle('accident-selectable', accidentSelectable);
      if(accidentSelectable){
        const onAccident = (e) => {
          e.stopPropagation();
          handleAccidentCandidate(p.id);
        };
        sweetsWrap.addEventListener('pointerdown', onAccident);
        sweetsWrap.onclick = onAccident;
      }
    }
    const sweetsPeekSelection = actionSelection?.type === 'sweetsPeek'
      ? actionSelection
      : null;
    const sweetsPeekSelectable = sweetsPeekSelection?.phase === 'select' && p.id !== state.userId;
    if(sweetsPeekSelection && hasTheirSweets){
      sweetsWrap.classList.toggle('peek-selectable', sweetsPeekSelectable);
      if(sweetsPeekSelectable){
        const onPeek = (e) => {
          e.stopPropagation();
          handleSweetsPeekCandidate(p.id);
        };
        sweetsWrap.addEventListener('pointerdown', onPeek);
        sweetsWrap.onclick = onPeek;
      }
    }
    if(collectedSweetsHidden.has(p.id)){
      sweetsWrap.classList.add('collect-hidden');
    }
    if(roundPickCanSelect && roundPickCandidates.includes(p.id) && getImprisonedUid() !== p.id){
      sweetsWrap.classList.add('roundpick-candidate');
      sweetsWrap.classList.add('roundpick-selectable');
      sweetsWrap.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        startRoundPickDrag(e, p.id);
      });
    }
    if(decidedUids.includes(p.id)){
      decidedMoveTargets.push({
        uid: p.id,
        sweetsWrap,
        circle,
        rotDeg,
        skipMove: hasCompletedDecidedMove(p.id),
      });
    }
    if(decidedUids.includes(p.id) && decidedCenterMoveAnimated.has(p.id)){
      requestAnimationFrame(() => {
        applyCenterMoveForUid(p.id);
      });
    }

    const sweetsMini = document.createElement('div');
    sweetsMini.className = 'sweets-mini';
    sweetsMini.classList.toggle('hidden', !hasTheirSweets);
    const advertised = isAdvertised(p.id);
    if(advertised && sweetsCard){
      sweetsMini.classList.add('advertise-revealed');
      if(shouldPulseAdvertise(p.id)){
      }
      const img = document.createElement('img');
      img.src = sweetsCard.img;
      img.alt = `sweets ${sweetsCard.value ?? ''}`;
      img.onerror = () => { if(sweetsCard.fallback) img.src = sweetsCard.fallback; };
      sweetsMini.appendChild(img);
      if(shouldShowAdvertiseStar(p.id)){
        const tag = buildAdvertiseNumberTag(sweetsCard.value);
        if(tag) sweetsMini.appendChild(tag);
      }
    }
    sweetsWrap.appendChild(sweetsMini);
    cacheSweetsRectFromElement(p.id, sweetsMini);

    // 投票チップ（スイーツ右に重ね）
    const voteStack = buildVoteStackEl(p.id);
    if(voteStack){
      sweetsWrap.appendChild(voteStack);
    }

    cardsRow.appendChild(sweetsWrap);
    circle.appendChild(cardsRow);
  }
}





// ★ 他プレイヤー：ミニ手札（タグの下に扇状）はそのまま（欲しければ残す）
if (handData && Array.isArray(handData.action) && handData.action.length){
  const miniHand = document.createElement('div');
  miniHand.className = 'mini-hand';
  if(scoutSelectable){
    miniHand.classList.add('scout-selectable');
  }

  const count = handData.action.length;
  const spread = 70;
  const base = (count > 1) ? (-spread/2) : 0;

  handData.action.forEach((_, idx2) => {
    const c = document.createElement('div');
    c.className = 'mini-card';

    const angleDeg2 = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
    c.style.transform = `translate(-50%,0) rotate(${angleDeg2}deg)`;
    c.style.zIndex = String(10 + idx2);
    miniHand.appendChild(c);
  });

 tag.appendChild(miniHand);
}

if(voteChips > 0){
  const voteChip = document.createElement('div');
  voteChip.className = 'other-vote-chip';
  voteChip.dataset.voterUid = p.id;
  if(roleMini){
    roleMini.appendChild(voteChip);
  }else{
    tag.appendChild(voteChip);
  }
}

playerCircle.appendChild(circle);

if(leaderSeat !== null && leaderSeat === p.seatIndex){
  const chip = document.createElement('div');
  chip.className = 'leader-chip';
  tag.appendChild(chip);
}
  });
 requestAnimationFrame(() => {
    applyDecidedSweetsMove(decidedMoveTargets);
    if(roundPick?.phase === 'done' && decidedUids.length){
      scheduleCenterMovesForUids(decidedUids);
      decidedUids.forEach((uid) => {
        if(decidedCenterMoveAnimated.has(uid)){
          requestAnimationFrame(() => {
            applyCenterMoveForUid(uid);
          });
        }
      });
    }
  });
  scheduleVoteChipAnimations();
  updateActionDeckUI();
  updateSweetsDeckUI();
  requestAnimationFrame(updateSweetsDeckRelocation);
  requestAnimationFrame(updateSweetsExcludedDeckRelocation);
}

/* =========================
   ターンUI更新
   ========================= */
function updateTurnUI(){
  if(revealOwnerId && (!state.turn || state.turn.activePlayerId !== revealOwnerId)){
    revealOverlay?.classList.add('hidden');
    revealOwnerId = null;
  }
  if(!state.turn || state.game?.status !== 'playing' || allSeatedPlayersPassed()){
    if(actionSelection){
      clearActionSelection();
    }
    turnBar.classList.add('hidden');
    turnBadge.textContent = 'TURN';
    const wrap = document.querySelector('.my-hand-wrapper');
    wrap?.classList.remove('my-turn-free','my-turn-blocked','my-turn-selecting');
    renderMySweets();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  if(actionSelection && !isMyTurn()){
    clearActionSelection();
  }

  const activeP = getPlayerBySeat(state.turn.activeSeat);
  const activeName = activeP?.name ?? '？';
  turnBadge.textContent = isTurnBlocked()
    ? 'シャッフル中…'
    : `手番：${activeName}（${state.turn.activeSeat}）`;

  const show = (state.seatedTable !== null);
  turnBar.classList.toggle('hidden', !show);

  const mine = isMyTurn();
  btnPass.disabled = !mine || getMyBonusVoteChips() > 0;

  btnDrawSweets.disabled = true;
  btnVote.disabled = true;

  renderHands();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   4つの手番終了要因（今はパスのみ：既存）
   ========================= */
btnPass.addEventListener('click', async ()=>{
  await endTurn('pass');
});

/* =========================
   ★★★ 右下PASS（ラウンド用）
   - 押したら game/passes[uid]=true
   - その時点で次手番へ（pass済みを飛ばす）
   ========================= */
passRoundBtn.addEventListener('click', async ()=>{
  if(!state.roomCode) return;
  if(!isMyTurn()) return;
  if(!myDoneSweetsAndVote()) return;
  if(getActiveInstructionCards().length > 0) return;

  const gamePassRef = ref(db, `rooms/${state.roomCode}/game/passes/${state.userId}`);
  await set(gamePassRef, true);

  await endTurn('roundPass');
});

/* =========================
   ★★★ ラウンド終了判定＆選抜
   ========================= */
function requiredPickCountByPlayers(n){
  if(n <= 4) return 2;
  if(n <= 6) return 3;
  return 4; // 7-8
}
function getLeaderPlayerId(){
  const leaderSeat = state.turn?.leaderSeat ?? null;
  if(leaderSeat == null) return null;
  const p = getPlayerBySeat(leaderSeat);
  return p?.id ?? null;
}
function allSeatedPlayersPassed(){
  const pm = getPassedMap();
  if(!latestPlayers.length) return false;
  return latestPlayers.every(p => !!pm?.[p.id]);
}
function getSweetsCardByUid(uid){
  const hd = state.hands?.[uid];
  const arr = hd?.sweets;
  if(Array.isArray(arr) && arr.length) return arr[0];
  return null;
}
function getSweetsVoteStats(){
  // 各プレイヤー（スイーツ持ち）の票数
  const owners = getSweetsOwners();
  const imprisonedUid = getImprisonedUid();
  return owners.map(uid => ({
    uid,
    votes: getEffectiveVoteCountFor(uid),
    card: getSweetsCardByUid(uid),
  })).filter(x => !!x.card && x.uid !== imprisonedUid);
}
function groupByVotesDesc(items){
  const sorted = [...items].sort((a,b)=>{
    if(b.votes !== a.votes) return b.votes - a.votes;
    return 0;
  });
  // 票数ごとにグループ
  const groups = [];
  for(const it of sorted){
    const last = groups[groups.length-1];
    if(!last || last.votes !== it.votes){
      groups.push({ votes: it.votes, items:[it] });
    }else{
      last.items.push(it);
    }
  }
  return groups;
}

/**
 * ホストだけが「全員PASS」を検知して、選抜フローを開始する
 * - roundEnding が false の時だけ開始
 * - 同票超過があれば roundPick.phase='choose' をセット
 * - 超過がなければ roundPick.phase='done' をセットしてイベント発火
 */
async function maybeHostStartRoundEndFlow(){
  if(!state.roomCode) return;
  if(!state.room?.gameStarted) return;
  if(state.game?.roundEnding) return;
  if(!allSeatedPlayersPassed()) return;

  const nPlayers = latestPlayers.length;
  const need = requiredPickCountByPlayers(nPlayers);

  const stats = getSweetsVoteStats();
  if(!stats.length){
    // スイーツが誰も無い場合は何もしない（仕様外）
    await update(ref(db, `rooms/${state.roomCode}/game`), { roundEnding:true, roundPick:{ phase:'done', selected:[], need:0 } });
    return;
  }

  const groups = groupByVotesDesc(stats);

  const selected = [];
  let remaining = need;

  // 上位グループから順に確定していくが、最後に同票で超過するならリーダー選択へ
  for(const g of groups){
    if(remaining <= 0) break;

    if(g.items.length <= remaining){
      selected.push(...g.items.map(x=>x.uid));
      remaining -= g.items.length;
      continue;
    }

    // ここで同票超過（g.items が remaining を超える）
    const leaderId = getLeaderPlayerId();
    const payload = {
      roundEnding: true,
      roundPick: {
        phase: 'choose',
        need: remaining,
        baseSelected: selected,
        candidates: g.items.map(x=>x.uid),
        leaderSeat: state.turn?.leaderSeat ?? null,
        leaderId,
      }
    };
    await update(ref(db, `rooms/${state.roomCode}/game`), payload);
    return;
  }

  // 超過なしで確定
  const finalSelected = selected.slice(0, need);
  await update(ref(db, `rooms/${state.roomCode}/game`), {
    roundEnding: true,
    roundPick: {
      phase: 'done',
      need: 0,
      selected: finalSelected,
      revealFiredKey: null,
    }
  });

}

/* =========================
   ★ 同票超過：リーダー選択UI
   - game.roundPick.phase === 'choose' のとき
   - leaderId の人だけクリック可能
   ========================= */
function getRoundPick(){
  return state.game?.roundPick || null;
}
function getLeaderPick(){
  return state.game?.leaderPick || null;
}
function shouldHoldVoteChips(){
  const lp = getLeaderPick();
  return !!lp && lp.phase !== 'done';
}
function canLeaderPickCandidate(uid){
  const lp = getLeaderPick();
  if(!lp || lp.phase !== 'choose') return false;
  if(lp.leaderId !== state.userId) return false;
  const candidates = Array.isArray(lp.candidates) ? lp.candidates : [];
  return candidates.includes(uid);
}
function updateLeaderPickUI(){
  const lp = getLeaderPick();
  const show = !!lp && lp.phase === 'choose' && lp.leaderId === state.userId;
  leaderPickPop.classList.toggle('hidden', !show);
}
async function requestLeaderPick(uid){
  if(!state.roomCode) return;
  if(!canLeaderPickCandidate(uid)) return;
  const lp = getLeaderPick() || {};
  await update(ref(db, `rooms/${state.roomCode}/game/leaderPick`), {
    phase: 'decided',
    decidedId: uid,
    candidates: Array.isArray(lp.candidates) ? lp.candidates : [],
    leaderId: lp.leaderId ?? null,
    leaderSeat: lp.leaderSeat ?? null,
    startAt: (typeof lp.startAt === 'number') ? lp.startAt : Date.now(),
  });
}

function getLeaderChipSizePx(){
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--leaderChipSize'));
  return Number.isFinite(size) ? size : 21.6;
}
function getLeaderChipOffsetPx(){
  const offset = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--leaderChipOffset'));
  return Number.isFinite(offset) ? offset : 22;
}
function getLeaderChipAnchorRect(tagEl){
  if(!tagEl) return null;
  const rect = tagEl.getBoundingClientRect();
  const size = getLeaderChipSizePx();
  const offset = getLeaderChipOffsetPx();
  return {
    left: rect.right + offset - size,
    top: rect.top + (rect.height - size) / 2,
    size,
  };
}
function animateLeaderChipMove(prevSeat, nextSeat){
  const prevTag = document.querySelector(`.player-tag[data-seat="${prevSeat}"]`);
  const nextTag = document.querySelector(`.player-tag[data-seat="${nextSeat}"]`);
  if(!prevTag || !nextTag) return;
  const from = getLeaderChipAnchorRect(prevTag);
  const to = getLeaderChipAnchorRect(nextTag);
  if(!from || !to) return;

  const chip = document.createElement('div');
  chip.className = 'leader-chip leader-chip-fly';
  chip.style.left = `${from.left}px`;
  chip.style.top = `${from.top}px`;
  document.body.appendChild(chip);

  const targetChip = nextTag.querySelector('.leader-chip');
  if(targetChip) targetChip.classList.add('leader-chip-hidden');

  const dx = to.left - from.left;
  const dy = to.top - from.top;
  chip.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1.4)` },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: 1200,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    chip.remove();
    if(targetChip) targetChip.classList.remove('leader-chip-hidden');
  };
}


function getActionDeckRect(){
  if(!actionDeckUI) return null;
  const rect = actionDeckUI.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function getPlayerTagRectBySeat(seat){
  const tag = document.querySelector(`.player-tag[data-seat="${seat}"]`);
  if(!tag) return null;
  const rect = tag.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function getMyHandRect(){
  if(myHandEl){
    const rect = myHandEl.getBoundingClientRect();
    if(rect.width && rect.height) return rect;
  }
  const wrap = document.querySelector('.my-hand-wrapper');
  if(!wrap) return null;
  const rect = wrap.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function getOtherPlayerHandRectBySeat(seat){
  const tag = document.querySelector(`.player-tag[data-seat="${seat}"]`);
  if(!tag) return null;
  const miniHand = tag.querySelector('.mini-hand');
  if(miniHand){
    const rect = miniHand.getBoundingClientRect();
    if(rect.width && rect.height) return rect;
  }
  const rect = tag.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function animateActionDealCard(toSeat, delayMs = 0){
  const from = getActionDeckRect();
  const to = getPlayerTagRectBySeat(toSeat);
  if(!from || !to) return;

  const card = document.createElement('div');
  card.className = 'action-deal-card';
  card.style.left = `${from.left}px`;
  card.style.top = `${from.top}px`;
  card.style.width = `${from.width}px`;
  card.style.height = `${from.height}px`;
  document.body.appendChild(card);

  const dx = (to.left + to.width / 2) - (from.left + from.width / 2);
  const dy = (to.top + to.height / 2) - (from.top + from.height / 2);
  const scale = Math.min(to.width / from.width, to.height / from.height, 1.2);

  card.animate([
    { transform: 'translate(0px, 0px) rotate(-12deg) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(0deg) scale(${scale})` },
  ], {
    duration: 600,
    delay: delayMs,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    card.remove();
  };
}
function animateActionDrawToHand(toUid, toSeat, delayMs = 0){
  const from = getActionDeckRect();
  if(!from) return;

  let targetRect = null;
  if(toUid && toUid === state.userId){
    targetRect = getMyHandRect();
  }else{
    const seat = (typeof toSeat === 'number') ? toSeat : getSeatByUid(toUid);
    if(typeof seat === 'number'){
      targetRect = getOtherPlayerHandRectBySeat(seat);
    }
  }
  if(!targetRect) return;

  const card = document.createElement('div');
  card.className = 'action-deal-card';
  card.style.left = `${from.left}px`;
  card.style.top = `${from.top}px`;
  card.style.width = `${from.width}px`;
  card.style.height = `${from.height}px`;
  document.body.appendChild(card);

  const dx = (targetRect.left + targetRect.width / 2) - (from.left + from.width / 2);
  const dy = (targetRect.top + targetRect.height / 2) - (from.top + from.height / 2);
  const scale = Math.min(targetRect.width / from.width, targetRect.height / from.height, 1.2);

  card.animate([
    { transform: 'translate(0px, 0px) rotate(-10deg) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(0deg) scale(${scale})` },
  ], {
    duration: 620,
    delay: delayMs,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    card.remove();
  };
}
function schedulePostActionDealMiniShuffle(leaderSeat, delayMs){
  if(!state.isHost || !state.roomCode) return;
  const waitMs = Math.max(0, delayMs || 0);
  setTimeout(() => {
    emitEvent({
      type: 'miniSweetsShuffleStart',
      reason: 'afterActionDeal',
      leaderSeat,
    });
  }, waitMs);
}

async function hostDealActionCardsFromLeader(leaderSeat){
  if(!state.isHost || !state.roomCode) return;
  if(leaderSeat == null) return;

  const base = `rooms/${state.roomCode}`;
  const [handsSnap, decksSnap, gameSnap] = await Promise.all([
    get(ref(db, `${base}/hands`)),
    get(ref(db, `${base}/decks`)),
    get(ref(db, `${base}/game`)),
  ]);
  const hands = handsSnap.val() || {};
  const decks = decksSnap.val() || {};
  const gameNow = gameSnap.val() || {};

  if(gameNow?.actionDealKey){
    return;
  }

  const deck = Array.isArray(decks.action) ? [...decks.action] : [];

  const seatOrder = Array.isArray(gameNow.seatOrder) && gameNow.seatOrder.length
    ? gameNow.seatOrder
    : getSeatedSeatOrder();
  const startIdx = seatOrder.indexOf(leaderSeat);
  if(startIdx === -1) return;

  const deals = [];
  for(let i = 0; i < seatOrder.length; i++){
    const seat = seatOrder[(startIdx + i) % seatOrder.length];
    const player = getPlayerBySeat(seat);
    if(!player) continue;
    const hand = hands[player.id];
    const action = Array.isArray(hand?.action) ? hand.action : [];
    if(action.length >= 3) continue;
    if(!deck.length) break;
    const card = deck.shift();
    if(!card) continue;
    action.push(card);
    hands[player.id] = { ...(hand || {}), action };
    deals.push({ seat });
  }


  const dealKey = `${leaderSeat}-${Date.now()}`;
  const updates = {
    'game/actionDealKey': dealKey,
  };
  if(deals.length){
    updates.hands = hands;
    updates['decks/action'] = deck;
  }

  await update(ref(db, base), updates);
  for(let i = 0; i < deals.length; i++){
    await emitEvent({
      type: 'dealActionCard',
      toSeat: deals[i].seat,
      delayMs: i * 120,
    });
  }
  const lastDelay = (deals.length > 0) ? ((deals.length - 1) * 120 + 650) : 200;
  schedulePostActionDealMiniShuffle(leaderSeat, lastDelay);

}


function maybeHostApplyLeaderPick(){
  if(!state.isHost || !state.roomCode) return;
  const lp = getLeaderPick();
  if(!lp || lp.phase === 'done'){
    if(leaderPickApplyTimer){
      clearTimeout(leaderPickApplyTimer);
      leaderPickApplyTimer = null;
    }
    return;
  }

  const decidedId = lp.decidedId || lp.nextLeaderId || null;
  if(!decidedId) return;

  const key = `${lp.phase}:${decidedId}:${lp.startAt ?? ''}`;
  if(leaderPickApplyKey === key && leaderPickApplyTimer) return;

  if(leaderPickApplyTimer){
    clearTimeout(leaderPickApplyTimer);
    leaderPickApplyTimer = null;
  }
  leaderPickApplyKey = key;

  const baseDelay = (typeof lp.startAt === 'number') ? lp.startAt : Date.now();
  const delay = Math.max(0, baseDelay + 1000 - Date.now());

  leaderPickApplyTimer = setTimeout(async () => {
    leaderPickApplyTimer = null;
    const seat = getSeatByUid(decidedId);
    if(seat == null) return;

    await update(ref(db, `rooms/${state.roomCode}/game/turn`), {
      leaderSeat: seat,
    });
    await update(ref(db, `rooms/${state.roomCode}/game/leaderPick`), {
      phase: 'done',
      decidedId,
      appliedAt: Date.now(),
    });
    const handsSnap = await get(ref(db, `rooms/${state.roomCode}/hands`));
    const hands = handsSnap.val() || {};
    Object.keys(hands).forEach(uid => {
      if(!hands[uid] || typeof hands[uid] !== 'object') hands[uid] = {};
      hands[uid].voteChips = 1;
      hands[uid].bonusVoteChips = 0;
    });
    await Promise.all([
      set(ref(db, `rooms/${state.roomCode}/votes`), {}),
      set(ref(db, `rooms/${state.roomCode}/hands`), hands),
    ]);
    setTimeout(() => {
      hostDealActionCardsFromLeader(seat);
    }, 650);
  }, delay);
}
function isLeaderMe(){
  const rp = getRoundPick();
  return !!rp && (rp.leaderId === state.userId);
}
function getDecidedSweetsUids(){
  const rp = getRoundPick();
  if(!rp) return [];
  if(rp.phase === 'choose'){
    return Array.isArray(rp.baseSelected) ? rp.baseSelected : [];
  }
  if(rp.phase === 'done'){
    return Array.isArray(rp.selected) ? rp.selected : [];
  }
  return [];
}

function resetCollectedSweetsHiddenCache(){
  if(!state.game?.roundEnding){
    collectedSweetsHidden.clear();
    decidedSweetsAnimated.clear();
    decidedCenterMoveAnimated.clear();
    centerMoveOffsetByKey.clear();
    decidedCenterMoveTimers.forEach((timerId) => clearTimeout(timerId));
    decidedCenterMoveTimers.clear();
    if(centerMoveBatchTimerId){
      clearTimeout(centerMoveBatchTimerId);
      centerMoveBatchTimerId = null;
    }
    centerMoveBatchKey = null;
    decidedRoundKey = null;
    decidedRoundStartAt = null;
    document.querySelectorAll('.collect-hidden').forEach(el => {
      el.classList.remove('collect-hidden');
    });
  }
}





const roundPickDrag = {
  active:false,
  uid:null,
  ghost:null,
  offsetX:0,
  offsetY:0,
  sourceEl:null,
  sourceHidden:false,
  sourceVisibility:'',
  voteChipHidden:false,
  voteChipVisibility:'',
};

function canLeaderDragPick(uid){
  const rp = getRoundPick();
  const candidates = rp && Array.isArray(rp.candidates) ? rp.candidates : [];
  const imprisonedUid = getImprisonedUid();
  if(imprisonedUid && imprisonedUid === uid) return false;
  return !!rp && rp.phase === 'choose' && rp.leaderId === state.userId && candidates.includes(uid);
}


function startRoundPickDrag(e, uid){
  if(!canLeaderDragPick(uid)) return;
  e.preventDefault();

  const source = e.currentTarget;
  const r = source.getBoundingClientRect();
  roundPickDrag.active = true;
  roundPickDrag.uid = uid;
  roundPickDrag.offsetX = e.clientX - r.left;
  roundPickDrag.offsetY = e.clientY - r.top;
  roundPickDrag.sourceEl = source;
  roundPickDrag.sourceHidden = true;
  roundPickDrag.sourceVisibility = source.style.visibility;
  source.style.visibility = 'hidden';
  if(uid === state.userId){
    roundPickDrag.voteChipHidden = true;
    roundPickDrag.voteChipVisibility = myVoteChipEl.style.visibility;
    myVoteChipEl.style.visibility = 'hidden';
  }

  const ghost = document.createElement('div');
  ghost.className = 'roundpick-dragging';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${source.offsetWidth}px`;
  ghost.style.height = `${source.offsetHeight}px`;
  ghost.style.transformOrigin = 'center';

  const circle = source.closest('.otherplayerscircle');
  const rotDeg = circle ? getComputedStyle(circle).getPropertyValue('--rotDeg').trim() : '0deg';
  if(uid !== state.userId && rotDeg){
    ghost.style.transform = `rotate(${rotDeg})`;
  }

  const card = getSweetsCardByUid(uid);
  const faceImg = card?.img || card?.fallback || SWEETS_BACK_IMG;
  const bgImg = (uid === state.userId) ? faceImg : SWEETS_BACK_IMG;
  ghost.style.backgroundImage = `url('${bgImg}')`;

  document.body.appendChild(ghost);
  roundPickDrag.ghost = ghost;

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onRoundPickDragMove);
  ghost.addEventListener('pointerup', onRoundPickDragEnd);
  ghost.addEventListener('pointercancel', onRoundPickDragEnd);
}

function onRoundPickDragMove(e){
  if(!roundPickDrag.active || !roundPickDrag.ghost) return;
  const x = e.clientX - roundPickDrag.offsetX;
  const y = e.clientY - roundPickDrag.offsetY;
  roundPickDrag.ghost.style.left = `${x}px`;
  roundPickDrag.ghost.style.top  = `${y}px`;

  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (e.clientX >= pr.left && e.clientX <= pr.right && e.clientY >= pr.top && e.clientY <= pr.bottom);
  playCircleEl.classList.toggle('roundpick-target', inPlay);
}

async function onRoundPickDragEnd(e){
  if(!roundPickDrag.active) return;

  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (e.clientX >= pr.left && e.clientX <= pr.right && e.clientY >= pr.top && e.clientY <= pr.bottom);
  const uid = roundPickDrag.uid;

  cleanupRoundPickDrag();

  if(inPlay && uid){
    await leaderPickOne(uid);
  }
}

function cleanupRoundPickDrag(){
  playCircleEl.classList.remove('roundpick-target');
  if(roundPickDrag.ghost){
    roundPickDrag.ghost.removeEventListener('pointermove', onRoundPickDragMove);
    roundPickDrag.ghost.removeEventListener('pointerup', onRoundPickDragEnd);
    roundPickDrag.ghost.removeEventListener('pointercancel', onRoundPickDragEnd);
    roundPickDrag.ghost.remove();
  }
  if(roundPickDrag.sourceEl && roundPickDrag.sourceHidden){
    roundPickDrag.sourceEl.style.visibility = roundPickDrag.sourceVisibility || '';
  }
  if(roundPickDrag.voteChipHidden){
    myVoteChipEl.style.visibility = roundPickDrag.voteChipVisibility || '';
  }
  roundPickDrag.active = false;
  roundPickDrag.uid = null;
  roundPickDrag.ghost = null;
  roundPickDrag.offsetX = 0;
  roundPickDrag.offsetY = 0;
  roundPickDrag.sourceEl = null;
  roundPickDrag.sourceHidden = false;
  roundPickDrag.sourceVisibility = '';
  roundPickDrag.voteChipHidden = false;
  roundPickDrag.voteChipVisibility = '';
}
function updateRoundPickUI(){
  const rp = getRoundPick();
  const roundPickActive = !!rp && rp.phase === 'choose';
  const candidates = roundPickActive && Array.isArray(rp.candidates) ? rp.candidates : [];
  const leaderCanSelect = roundPickActive && rp.leaderId === state.userId;
  const imprisonedUid = getImprisonedUid();
  const meIsCandidate = leaderCanSelect
    && candidates.includes(state.userId)
    && imprisonedUid !== state.userId;
  const meCanSelect = leaderCanSelect && meIsCandidate;


  mySweetsEl.classList.toggle('roundpick-candidate', meIsCandidate);
  mySweetsEl.classList.toggle('roundpick-selectable', meCanSelect);

 if(meCanSelect){
    mySweetsEl.onpointerdown = (e) => {
      e.stopPropagation();
      startRoundPickDrag(e, state.userId);
    };
  }else{
    const exchangeSelectable = actionSelection?.type === 'exchange'
      && actionSelection.phase === 'select'
      && !!getMySweetsCard();
    if(exchangeSelectable){
      mySweetsEl.onpointerdown = (e) => {
        e.stopPropagation();
        handleExchangeCandidate(state.userId);
      };
    }else{
      mySweetsEl.onpointerdown = null;
    }
  }

}
async function leaderPickOne(uid){
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'choose') return;
  if(rp.leaderId !== state.userId) return;
  const imprisonedUid = getImprisonedUid();
  if(imprisonedUid && imprisonedUid === uid) return;

  const need = Number(rp.need || 0);
  if(need <= 0) return;

  const baseSelected = Array.isArray(rp.baseSelected) ? rp.baseSelected : [];
  const candidates = Array.isArray(rp.candidates) ? rp.candidates : [];

  if(!candidates.includes(uid)) return;

  const nextSelected = [...baseSelected, uid];
  const nextCandidates = candidates.filter(x=>x !== uid);
  const nextNeed = need - 1;

  if(nextNeed > 0){
    await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
      phase:'choose',
      need: nextNeed,
      baseSelected: nextSelected,
      candidates: nextCandidates,
      leaderSeat: rp.leaderSeat ?? null,
      leaderId: rp.leaderId ?? null,
    });
    return;
  }

  await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
    phase:'done',
    need: 0,
    selected: nextSelected,
    revealFiredKey: null,
  });

  // ホストがイベント発火するのが原則だが、念のためリーダーでも発火できるようにする（重複は回避）
  // → ホスト側は roundPick.phase='done' を見て発火しない設計にしていないので、ここは発火しない
  //    代わりに、ホストが subscribeGame で roundEnding=true を見て発火済みのケースがあるので、
  //    ここでは「ホストに任せる」。
}

/* ★ ホスト：roundPick が done になったらイベント発火（未発火なら） */
async function maybeHostFireRoundRevealAfterLeaderPick(){
 if(!state.isHost) return;
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'done') return;
  if(!state.game?.roundEnding) return;

  const selected = Array.isArray(rp.selected) ? rp.selected : [];
  const key = selected.join(',');
  if(rp.revealFiredKey === key) return;

  await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
    revealFiredKey: key,
  });

  const cards = selected.map(uid => getSweetsCardByUid(uid)).filter(Boolean);
  await emitEvent({ type:'roundRevealSweets', selectedUids: selected, cards });
}


/* =========================
   ★★★ ラウンド終了演出（全員）
   - 選ばれたスイーツ（裏）を中央へ集める
   - 中央でシャッフルっぽい動き
   - 表にして中央に横並び（折り返しなし）
   - 3秒表示後、消える
   ========================= */
let _roundAnimRunning = false;
function getRoundCollectCenter(){
  const r = playCircleEl?.getBoundingClientRect?.();
  if(r && r.width && r.height){
    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
  }
  return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
}
function getSweetsSourceRect(uid, fallback){
  const el = document.querySelector(`[data-sweets-uid="${uid}"]`);
  if(el){
    const r = el.getBoundingClientRect();
    if(r && r.width && r.height){
      return r;
    }
  }
  return fallback;
}

function toggleCollectHiddenForUids(uids, hidden){
  const list = Array.isArray(uids) ? uids : [];
  list.forEach(uid => {
    const targets = document.querySelectorAll(`[data-sweets-uid="${uid}"]`);
    targets.forEach(el => {
      el.classList.toggle('collect-hidden', hidden);
    });
    if(hidden){
      collectedSweetsHidden.add(uid);
    }
  });
}


/* =========================
   ★★★ ラウンド終了：回収→シャッフル→拡大表示（全員）
   - ゴースト防止：元位置DOMを collect-hidden で不可視化
   - 二重防止：stopRoundEndFx() + token で排他
   ========================= */

const roundEndFx = {
  token: 0,
  timers: new Set(),
  anims: new Set(),
  nodes: new Set(),
  restores: [],
};

function _fxRememberRestore(fn){
  roundEndFx.restores.push(fn);
}
function _fxSetTimeout(fn, ms, token){
  const id = setTimeout(() => {
    roundEndFx.timers.delete(id);
    if(token !== roundEndFx.token) return;
    fn();
  }, ms);
  roundEndFx.timers.add(id);
  return id;
}
function _fxSleep(ms, token){
  return new Promise(resolve => _fxSetTimeout(resolve, ms, token));
}

/** ★ 強制停止＆後始末（“前の”演出を完全に殺す） */
function stopRoundEndFx(){
  // token更新（これで進行中awaitは全部無効化）
  roundEndFx.token++;

  // timers
  for(const t of roundEndFx.timers) clearTimeout(t);
  roundEndFx.timers.clear();

  // anims
  for(const a of roundEndFx.anims){
    try{ a.cancel(); }catch(_){}
  }
  roundEndFx.anims.clear();

  // nodes
  for(const n of roundEndFx.nodes){
    try{ n.remove(); }catch(_){}
  }
  roundEndFx.nodes.clear();

  // restore（途中停止時だけ元に戻す）
  for(const r of roundEndFx.restores){
    try{ r(); }catch(_){}
  }
  roundEndFx.restores = [];

  // overlay掃除（ゴースト残し防止）
  try{
    roundRevealRow.innerHTML = '';
    roundRevealOverlay.classList.add('hidden');
  }catch(_){}
  resetRoundRevealState();
}


/** ★ “元位置”として最優先で使うDOMを探す（ゴースト防止のため） */
function _pickOriginElForUid(uid){
  // 1) decided表示（タグ上の selected-sweets-tag）
  let el = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"]`);
  if(el) return el;

  // 2) 他プレイヤーのスイーツ枠（sweets-wrap）
  el = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"]`);
  if(el) return el;

  // 3) 自分の手元スイーツ
  if(uid === state.userId && mySweetsEl && !mySweetsEl.classList.contains('hidden')){
    return mySweetsEl;
  }

  return null;
}

/** ★ 元位置を不可視化（“ゴースト”＝残像防止） */
function _hideOriginVisual(uid, originEl){
  if(!originEl) return;

  // sweets-wrap / selected-sweets-tag は既存CSSの collect-hidden を使う
  if(originEl.classList.contains('sweets-wrap') || originEl.classList.contains('selected-sweets-tag')){
    if(!originEl.classList.contains('collect-hidden')){
      originEl.classList.add('collect-hidden');
      collectedSweetsHidden.add(uid);
      _fxRememberRestore(()=> {
        originEl.classList.remove('collect-hidden');
        collectedSweetsHidden.delete(uid);
      });
    }
    return;
  }

  // mySweetsEl など：visibilityで消す（レイアウトは保持）
  const prevVis = originEl.style.visibility;
  originEl.style.visibility = 'hidden';
  collectedSweetsHidden.add(uid);
  _fxRememberRestore(()=> {
    originEl.style.visibility = prevVis;
    collectedSweetsHidden.delete(uid);
  });
}

/** ★ 回収カード（裏）を作成 */
function _createCollectCardAtRect(rect){
  const node = document.createElement('div');
  node.className = 'collect-card';
  node.style.left = `${rect.left}px`;
  node.style.top  = `${rect.top}px`;
  node.style.width  = `${rect.width}px`;
  node.style.height = `${rect.height}px`;
  // collect-card の background はCSSで swsweetsura.jpg になってる前提（既存のまま）
  document.body.appendChild(node);
  roundEndFx.nodes.add(node);
  return node;
}

/** ★ 中央座標（PLAYを中心に。無理なら画面中央） */
function _getCenterPoint(){
  const pr = playCircleEl?.getBoundingClientRect?.();
  if(pr && pr.width && pr.height){
    return { x: pr.left + pr.width/2, y: pr.top + pr.height/2 };
  }
  return { x: window.innerWidth/2, y: window.innerHeight/2 };
}

/** ★ シャッフル演出（中央） */
/** ★ シャッフル演出（sweetshuffle1） */
async function _runSweetShuffle1(token){
  const stage = document.createElement('div');
  stage.className = 'sweets-shuffle-stage';
  document.body.appendChild(stage);
  roundEndFx.nodes.add(stage);

  const OFFSET_X = 4;
  const OFFSET_Y = 4;
  const OUT_X = 78;
  const TILT_BASE = 5;
  const TILT_MORE = 5;
  const DUR_OUT = 220;
  const DUR_IN = 220;
  const PAUSE = 20;
  const LOOPS = 3;
  const base = 'translate(-50%,-50%)';
  const baseFront = `${base} translate(0px,0px) rotate(${TILT_BASE}deg)`;
  const baseBack = `${base} translate(${OFFSET_X}px,${OFFSET_Y}px) rotate(${TILT_BASE}deg)`;
  const outTransform = `${base} translate(${OUT_X}px,0px) rotate(${TILT_BASE + TILT_MORE}deg)`;

  const back = document.createElement('div');
  back.className = 'sweets-shuffle-card';
  back.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  back.style.zIndex = '1';
  back.style.transform = baseBack;

  const front = document.createElement('div');
  front.className = 'sweets-shuffle-card';
  front.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  front.style.zIndex = '2';
  front.style.transform = baseFront;

  stage.appendChild(back);
  stage.appendChild(front);

  const animateOnce = (el, keyframes, options) => {
    const anim = el.animate(keyframes, options);
    roundEndFx.anims.add(anim);
    return new Promise(resolve => {
      anim.onfinish = () => {
        roundEndFx.anims.delete(anim);
        resolve();
      };
      anim.oncancel = () => {
        roundEndFx.anims.delete(anim);
        resolve();
      };
    });
  };

  let frontEl = front;
  let backEl = back;

  for(let i=0;i<LOOPS;i++){
    if(token !== roundEndFx.token) return;
    await animateOnce(frontEl, [
      { transform: baseFront },
      { transform: outTransform },
    ], {
      duration: DUR_OUT,
      easing: 'ease-in-out',
      fill: 'forwards',
    });

    if(token !== roundEndFx.token) return;
    frontEl.style.transform = outTransform;
    frontEl.style.zIndex = '1';
    backEl.style.zIndex = '2';
    backEl.style.transform = baseFront;

    await animateOnce(frontEl, [
      { transform: outTransform },
      { transform: baseBack },
    ], {
      duration: DUR_IN,
      easing: 'ease-in-out',
      fill: 'forwards',
    });

    if(token !== roundEndFx.token) return;
    frontEl.style.transform = baseBack;

    const tmp = frontEl;
    frontEl = backEl;
    backEl = tmp;

    await new Promise(resolve => setTimeout(resolve, PAUSE));
  }

  if(token !== roundEndFx.token) return;
  stage.remove();
  roundEndFx.nodes.delete(stage);
}

async function getSweetsDeckRectForMiniShuffle(){
  if(!sweetsDeckUI) return null;
  let rect = sweetsDeckUI.getBoundingClientRect();
  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }

  const wasCenterHidden = centerDecksEl.classList.contains('hidden');
  const wasSweetsHidden = sweetsDeckUI.classList.contains('hidden');
  const prevCenterVisibility = centerDecksEl.style.visibility;
  const prevSweetsVisibility = sweetsDeckUI.style.visibility;

  centerDecksEl.classList.remove('hidden');
  sweetsDeckUI.classList.remove('hidden');
  centerDecksEl.style.visibility = 'hidden';
  sweetsDeckUI.style.visibility = 'hidden';

  for(let i=0;i<6;i++){
    rect = sweetsDeckUI.getBoundingClientRect();
    if(rect && rect.width > 0 && rect.height > 0){
      break;
    }
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
  }

  centerDecksEl.style.visibility = prevCenterVisibility;
  sweetsDeckUI.style.visibility = prevSweetsVisibility;
  if(wasSweetsHidden) sweetsDeckUI.classList.add('hidden');
  if(wasCenterHidden) centerDecksEl.classList.add('hidden');

  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }
  return null;
}

async function getSweetsExcludedDeckRectForMiniShuffle(){
  if(!sweetsExcludedDeckUI) return null;
  let rect = sweetsExcludedDeckUI.getBoundingClientRect();
  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }

  const wasHidden = sweetsExcludedDeckUI.classList.contains('hidden');
  const prevVisibility = sweetsExcludedDeckUI.style.visibility;
  const prevAnimating = sweetsExcludeAnimating;

 sweetsExcludedDeckUI.style.visibility = prevVisibility;
  sweetsExcludeAnimating = prevAnimating;
  if(wasHidden){
    sweetsExcludedDeckUI.classList.add('hidden');
  } else {
    sweetsExcludedDeckUI.classList.remove('hidden');
  }
  updateSweetsDeckUI();

  for(let i=0;i<6;i++){
    rect = sweetsExcludedDeckUI.getBoundingClientRect();
    if(rect && rect.width > 0 && rect.height > 0){
      break;
    }
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
  }

  sweetsExcludedDeckUI.style.visibility = prevVisibility;
  sweetsExcludeAnimating = prevAnimating;
  if(wasHidden) sweetsExcludedDeckUI.classList.add('hidden');

  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }
  return null;
}

function getPlayerCountForSweetsSplit(){
  const seatOrder = state.game?.seatOrder;
  if(Array.isArray(seatOrder) && seatOrder.length){
    return seatOrder.length;
  }
  if(Array.isArray(latestPlayers) && latestPlayers.length){
    return latestPlayers.length;
  }
  const tables = state.room?.tables;
  if(tables && typeof tables === 'object'){
    return Object.values(tables).filter(t => t && t.playerId).length;
  }
  return 0;
}

async function getSweetsDeckForMiniShuffle(){
  const deck = state.room?.decks?.sweets;
  if(Array.isArray(deck) && deck.length){
    return deck;
  }
  if(!state.roomCode) return deck;
  try{
    const snap = await get(ref(db, `rooms/${state.roomCode}/decks/sweets`));
    const data = snap.val();
    if(Array.isArray(data)) return data;
  }catch(_){}
  return deck;
}

async function animateSweetsExcludeMove(fromRect, toRect, totalCount, keepCount){
  const moveCount = Math.max(0, totalCount - keepCount);
  if(moveCount <= 0) return;

  sweetsExcludeAnimating = true;
  setSweetsCountOverrides(totalCount, 0);
  updateSweetsDeckUI();

  const dx = toRect.left - fromRect.left;
  const dy = toRect.top - fromRect.top;
  const duration = 260;

  const card = document.createElement('div');
  card.className = 'sweets-move-card';
  card.style.width = `${fromRect.width}px`;
  card.style.height = `${fromRect.height}px`;
  card.style.left = `${fromRect.left}px`;
  card.style.top = `${fromRect.top}px`;
  document.body.appendChild(card);

  const anim = card.animate([
    { transform: 'translate(0px,0px) rotate(0deg)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(90deg)` },
  ], {
    duration,
    easing: 'ease-in-out',
    fill: 'forwards',
  });

  await new Promise(resolve => {
    anim.onfinish = resolve;
    anim.oncancel = resolve;
  });
  card.remove();

  sweetsExcludeAnimating = false;
  setSweetsCountOverrides(keepCount, moveCount, 5000);
  updateSweetsDeckUI();
}

async function maybeHostApplySweetsSplit(deck, playerCount){
  if(!state.isHost || !state.roomCode) return;
  const currentExcluded = state.room?.decks?.sweetsExcluded;
  if(Array.isArray(currentExcluded) && currentExcluded.length) return;
  const keepCount = clamp(playerCount + 2, 0, Array.isArray(deck) ? deck.length : 0);
  if(!Array.isArray(deck) || deck.length <= keepCount) return;

  const { sweets, excluded } = splitSweetsDeck(deck, playerCount);
  const decksRef = ref(db, `rooms/${state.roomCode}/decks`);
  await update(decksRef, { sweets, sweetsExcluded: excluded });
}

async function runMiniSweetsShuffleAtStart(opts = {}){
  if(miniShuffleRunning) return;
  const reason = opts?.reason || null;
  const leaderSeatForRestart = (typeof opts?.leaderSeat === 'number')
    ? opts.leaderSeat
    : (state.turn?.leaderSeat ?? null);
  turnBlockedByShuffle = true;
  updateTurnUI();
  try{

    const rect = await getSweetsDeckRectForMiniShuffle();
    if(!rect){
      const deck = await getSweetsDeckForMiniShuffle();
      const totalCount = Array.isArray(deck) ? deck.length : 0;
      const playerCount = getPlayerCountForSweetsSplit();
      const keepCount = clamp(playerCount + 2, 0, totalCount);
      const moveCount = Math.max(0, totalCount - keepCount);
      if(moveCount > 0){
        sweetsExcludeAnimating = true;
        setSweetsCountOverrides(keepCount, moveCount, 5000);
        updateSweetsDeckUI();
        sweetsExcludeAnimating = false;
      }
     await maybeHostApplySweetsSplit(deck, playerCount);
      if(reason === 'afterActionDeal'){
        await hostRestartTurnAfterActionDeal(leaderSeatForRestart);
      }else{
        await hostGrantTurnAfterMiniShuffle();
      }
      return;
    }

    const token = ++miniShuffleToken;
    miniShuffleRunning = true;
    updateSweetsDeckUI();

    const cardSample = sweetsDeckUI.querySelector('.card');
    const cardStyle = cardSample ? getComputedStyle(cardSample) : null;
    const cardRadius = cardStyle?.borderRadius || '7px';
    const cardBorder = cardStyle?.border || '1px solid rgba(0,0,0,.18)';
    const cardShadow = cardStyle?.boxShadow || 'none';

    const stage = document.createElement('div');
    stage.className = 'sweets-shuffle-stage';
    stage.style.left = `${rect.left + rect.width / 2}px`;
    stage.style.top = `${rect.top + rect.height / 2}px`;
    stage.style.width = `${rect.width}px`;
    stage.style.height = `${rect.height}px`;
    document.body.appendChild(stage);

    try{
      const BASE_W = 120;
      const BASE_H = 170;
      const scale = Math.min(rect.width / BASE_W, rect.height / BASE_H);
      const OFFSET_X = 4 * scale;
      const OFFSET_Y = 4 * scale;
      const OUT_X = 78 * scale;
      const TILT_BASE = 5;
      const TILT_MORE = 5;
      const DUR_OUT = 220;
      const DUR_IN = 220;
      const PAUSE = 20;
      const LOOPS = 3;
      const base = 'translate(-50%,-50%)';
      const baseFront = `${base} translate(0px,0px) rotate(${TILT_BASE}deg)`;
      const baseBack = `${base} translate(${OFFSET_X}px,${OFFSET_Y}px) rotate(${TILT_BASE}deg)`;
      const outTransform = `${base} translate(${OUT_X}px,0px) rotate(${TILT_BASE + TILT_MORE}deg)`;

      const createCard = (zIndex, transform) => {
        const el = document.createElement('div');
        el.className = 'sweets-shuffle-card';
        el.style.width = `${rect.width}px`;
        el.style.height = `${rect.height}px`;
        el.style.borderRadius = cardRadius;
        el.style.border = cardBorder;
        el.style.boxShadow = cardShadow;
        el.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
        el.style.zIndex = String(zIndex);
        el.style.transform = transform;
        return el;
      };

      const back = createCard(1, baseBack);
      const front = createCard(2, baseFront);
      stage.appendChild(back);
      stage.appendChild(front);

      const animateOnce = (el, keyframes, options) => new Promise(resolve => {
        const anim = el.animate(keyframes, options);
        anim.onfinish = resolve;
        anim.oncancel = resolve;
      });

      let frontEl = front;
      let backEl = back;

      for(let i=0;i<LOOPS;i++){
        if(token !== miniShuffleToken) return;
        await animateOnce(frontEl, [
          { transform: baseFront },
          { transform: outTransform },
        ], {
          duration: DUR_OUT,
          easing: 'ease-in-out',
          fill: 'forwards',
        });

        if(token !== miniShuffleToken) return;
        frontEl.style.transform = outTransform;
        frontEl.style.zIndex = '1';
        backEl.style.zIndex = '2';
        backEl.style.transform = baseFront;

        await animateOnce(frontEl, [
          { transform: outTransform },
          { transform: baseBack },
        ], {
          duration: DUR_IN,
          easing: 'ease-in-out',
          fill: 'forwards',
        });

        if(token !== miniShuffleToken) return;
        frontEl.style.transform = baseBack;

        const tmp = frontEl;
        frontEl = backEl;
        backEl = tmp;

        await new Promise(resolve => setTimeout(resolve, PAUSE));
      }
    } finally {
      stage.remove();
      if(token === miniShuffleToken){
        miniShuffleRunning = false;
        updateSweetsDeckUI();
      }
    }
    if(token !== miniShuffleToken) return;

    const deck = await getSweetsDeckForMiniShuffle();
    const totalCount = Array.isArray(deck) ? deck.length : 0;
    const playerCount = getPlayerCountForSweetsSplit();
    const keepCount = clamp(playerCount + 2, 0, totalCount);
    const moveCount = Math.max(0, totalCount - keepCount);

    const targetRect = await getSweetsExcludedDeckRectForMiniShuffle();
    if(rect && targetRect && moveCount > 0){
      await animateSweetsExcludeMove(rect, targetRect, totalCount, keepCount);
    } else if(moveCount > 0){
      setSweetsCountOverrides(keepCount, moveCount, 5000);
      updateSweetsDeckUI();
    }

    await maybeHostApplySweetsSplit(deck, playerCount);
    if(token !== miniShuffleToken) return;
    if(reason === 'afterActionDeal'){
      await hostRestartTurnAfterActionDeal(leaderSeatForRestart);
    }else{
      await hostGrantTurnAfterMiniShuffle();
    }
  } finally {
    turnBlockedByShuffle = false;
    updateTurnUI();
  }
}

async function animateRoundEndReveal(cards, selectedUids){
  if(_roundAnimRunning){
    stopRoundEndFx();
    _roundAnimRunning = false;
  }
  _roundAnimRunning = true;

  try{
    stopRoundEndFx();
    const token = roundEndFx.token;

    document.querySelectorAll('.collect-card').forEach(el => el.remove());
    roundRevealRow.innerHTML = '';
    roundRevealOverlay.classList.add('hidden');

    const uids = Array.isArray(selectedUids) ? selectedUids : [];
    ensureDecidedRoundStart(uids);
    scheduleCenterMovesForUids(uids);

    await waitForDecidedTimestamps(uids);
    const latestDecidedAt = getLatestAppliedDecidedAt(uids);    const centerMoveStartAt = latestDecidedAt + DECIDED_CENTER_DELAY_MS;
    const shuffleStartAt = centerMoveStartAt + 1200;
    const waitMs = Math.max(0, shuffleStartAt - Date.now());
    if(waitMs > 0){
      await new Promise(resolve => setTimeout(resolve, waitMs));
    }
    if(token !== roundEndFx.token) return;

    uids.forEach(uid => {
      const origin = _pickOriginElForUid(uid);
      _hideOriginVisual(uid, origin);
    });

    await _runSweetShuffle1(token);
    if(token !== roundEndFx.token) return;

    roundRevealRow.innerHTML = '';
    (Array.isArray(cards) ? cards : []).forEach(card => {
      const el = document.createElement('div');
      el.className = 'roundreveal-card';
      const img = document.createElement('img');
      img.src = card?.img || card?.fallback || SWEETS_BACK_IMG;
      img.alt = `sweets ${card?.value ?? ''}`;
      img.onerror = () => { if(card?.fallback) img.src = card.fallback; };
     el.appendChild(img);
      roundRevealRow.appendChild(el);
    });
    markRoundRevealStarted();
    roundRevealOverlay.classList.remove('hidden');

    await new Promise(resolve => setTimeout(resolve, 2800));
    if(token !== roundEndFx.token) return;

    roundRevealOverlay.classList.add('hidden');
    roundRevealRow.innerHTML = '';
    markRoundRevealFinished();

    for(const restore of roundEndFx.restores){
      try{ restore(); }catch(_){}
    }
    roundEndFx.restores = [];
  } finally {
    _roundAnimRunning = false;
    if(roundRevealState.started && !roundRevealState.finished){
      markRoundRevealFinished();
    }
  }
}

/* =========================
   ドラッグ＆ドロップ（アクションカード）
   ========================= */
const drag = {
  active:false,
  card:null,
  el:null,
  fromHand:false,
  offsetX:0, offsetY:0,
  originRect:null,
  lastClientX:null,
  lastClientY:null,
};

function canUseOnPlayCircle(card){
  if(card.kind !== 'instruction') return true;
  if(card.name === '無視' && hasReceivedInstruction()) return true;
  if(INSTRUCTION_NEED_TARGET.has(card.name)) return false;
  return true;
}

function canUseOnOtherPlayer(card){
  if(card.kind !== 'instruction') return false;
  if(card.name === '無視' && hasReceivedInstruction()) return false;
  return true;
}
function canStartUseCard(cardObj){
  if(!isMyTurn()) return false;
  if(getRoundPick()?.phase === 'choose') return false;
  if(isActionSelectionActive()) return false;
  if(getMyBonusVoteChips() > 0) return false;
  const turnBlocked = isInstructionTurnBlocked();
  const receivedIds = new Set(getMyReceivedCards().map(card => card.id));
  if(receivedIds.has(cardObj.id)) return false;
  if(!turnBlocked) return true;

  const isIgnore = (cardObj.kind === 'instruction' && cardObj.name === '無視');
  return isIgnore;
}


let hoverOtherCircle = null;
function clearOtherCircleHint(){
  if(!hoverOtherCircle) return;
  hoverOtherCircle.classList.remove('hint-ok','hint-ng');
  hoverOtherCircle = null;
}
function updateOtherCircleHint(x,y,cardObj){
  clearOtherCircleHint();
  if(cardObj?.kind !== 'instruction') return;
  const el = document.elementFromPoint(x,y);
  const c = el?.closest?.('.otherplayerscircle');
  if(!c) return;

  const ok = canUseOnOtherPlayer(cardObj);
  c.classList.add(ok ? 'hint-ok' : 'hint-ng');
  hoverOtherCircle = c;
}

function showActionDiscardZone(){
  if(!actionDiscardZone) return;
  if(!drag.active || !drag.fromHand) return;
  actionDiscardZone.classList.remove('hidden');
}

function hideActionDiscardZone(){
  if(!actionDiscardZone) return;
  actionDiscardZone.classList.add('hidden');
  actionDiscardZone.classList.remove('active');
}

function syncActionDiscardZoneVisibility(){
  if(!actionDiscardZone) return;
  const shouldShow = drag.active && drag.fromHand;
  actionDiscardZone.classList.toggle('hidden', !shouldShow);
  if(!shouldShow) actionDiscardZone.classList.remove('active');
}

function isInDiscardZone(x,y){
  if(!actionDiscardZone || actionDiscardZone.classList.contains('hidden')) return false;
  const rect = actionDiscardZone.getBoundingClientRect();
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

function getDropTarget(x,y){
  if(isInDiscardZone(x,y)) return { type:'discardZone' };
  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (x>=pr.left && x<=pr.right && y>=pr.top && y<=pr.bottom);
  if(inPlay) return { type:'playCircle' };

  const el = document.elementFromPoint(x,y);
  const circle = el?.closest?.('.otherplayerscircle');
  if(circle){
    const tag = circle.querySelector('.player-tag');
    if(tag){
      const seat = Number(tag.dataset.seat);
      const uid = tag.dataset.uid;
      return { type:'otherCircle', seat, uid };
    }
  }

  const tag = el?.closest?.('.player-tag');
  if(tag){
    const seat = Number(tag.dataset.seat);
    const uid = tag.dataset.uid;
    return { type:'playerTag', seat, uid };
  }

  return { type:'none' };
}

function startDragCard(e, cardObj, cardEl){
  if(!canStartUseCard(cardObj)) return;
  e.preventDefault();

  drag.active = true;
  drag.card = cardObj;
  drag.el = cardEl;
  drag.fromHand = !!cardEl.closest('#myHand');
  drag.originRect = cardEl.getBoundingClientRect();

  const r = drag.originRect;
  drag.offsetX = e.clientX - r.left;
  drag.offsetY = e.clientY - r.top;
  drag.lastClientX = e.clientX;
  drag.lastClientY = e.clientY;

  cardEl.classList.add('dragging');
  cardEl.style.left = `${r.left}px`;
  cardEl.style.top  = `${r.top}px`;

  cardEl.setPointerCapture(e.pointerId);

  playCircleEl.classList.toggle('hint-ok', canUseOnPlayCircle(cardObj));
  playCircleEl.classList.toggle('hint-ng', !canUseOnPlayCircle(cardObj));

  showActionDiscardZone();

  cardEl.addEventListener('pointermove', onDragMove);
  cardEl.addEventListener('pointerup', onDragEnd);
  cardEl.addEventListener('pointercancel', onDragEnd);
}

function onDragMove(e){
  if(!drag.active) return;
  const x = e.clientX - drag.offsetX;
  const y = e.clientY - drag.offsetY;
  drag.lastClientX = e.clientX;
  drag.lastClientY = e.clientY;
  drag.el.style.left = `${x}px`;
  drag.el.style.top  = `${y}px`;

  updateOtherCircleHint(e.clientX, e.clientY, drag.card);
  if(actionDiscardZone){
    actionDiscardZone.classList.toggle('active', isInDiscardZone(e.clientX, e.clientY));
  }
}

async function onDragEnd(e){
  if(!drag.active) return;

  const cardObj = drag.card;
  const drop = getDropTarget(e.clientX, e.clientY);
  const receivedIds = new Set(getMyReceivedCards().map(card => card.id));
  const isReceived = receivedIds.has(cardObj?.id);

  playCircleEl.classList.remove('hint-ok','hint-ng');
  clearOtherCircleHint();

  if(isReceived && drop.type !== 'playCircle'){
    snapBack();
    return;
  }

  if(drop.type === 'discardZone'){
    const discarded = await discardActionCardForPeek(cardObj);
    if(!discarded){
      snapBack();
      return;
    }
    drag.el.classList.remove('dragging');
    drag.el.style.left = '';
    drag.el.style.top  = '';
    cleanupDrag();
    return;
  }

  if(drop.type === 'playCircle'){
    const ok = canUseOnPlayCircle(cardObj);
    if(!ok){ snapBack(); return; }

    const played = await playCardToCircle(cardObj);
    if(!played){
      snapBack();
      return;
    }
    cleanupDrag();
    return;
  }

  if(drop.type === 'otherCircle'){
    if(cardObj.kind !== 'instruction'){ snapBack(); return; }
    if(!canUseOnOtherPlayer(cardObj)){ snapBack(); return; }
    const sent = await giveInstructionToPlayer(cardObj, drop.seat, drop.uid);
    if(!sent){
      snapBack();
      return;
    }
    cleanupDrag();
    return;
  }

  if(drop.type === 'playerTag'){
    const isSelf = (drop.uid === state.userId);
    if(cardObj.kind !== 'instruction'){ snapBack(); return; }
    if(isSelf && !INSTRUCTION_CAN_SELF.has(cardObj.name)){ snapBack(); return; }
    if(isSelf){
      const played = await playCardToCircle(cardObj);
      if(!played){
        snapBack();
        return;
      }
      cleanupDrag();
      return;
    }
    snapBack();
    return;
  }

  snapBack();
}

function snapBack(){
  const el = drag.el;
  el.animate([
    { transform:'translate(0,0) scale(1.02)' },
    { transform:'translate(0,0) scale(1.0)' }
  ], { duration: 120, easing:'ease-out' });

  el.style.left = '';
  el.style.top  = '';
  el.classList.remove('dragging');

  cleanupDrag();
}

function cleanupDrag(){
  if(!drag.el) return;
  drag.el.removeEventListener('pointermove', onDragMove);
  drag.el.removeEventListener('pointerup', onDragEnd);
  drag.el.removeEventListener('pointercancel', onDragEnd);

  drag.active = false;
  drag.card = null;
  drag.el = null;
  drag.fromHand = false;
  drag.originRect = null;
  drag.lastClientX = null;
  drag.lastClientY = null;
  hideActionDiscardZone();
}

/* =========================
   ★ ブロック解除（無視使用時）
   ========================= */
async function consumeReceivedInstruction(){
  if(!state.roomCode) return;
  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const rec = Array.isArray(myData.received) ? myData.received : [];
  if(!rec.length) return;

  await update(myRef, { received: [] });
  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, ...rec]);
}

async function discardReceivedInstructionsForTurn(){
  if(!state.roomCode) return;
  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const rec = Array.isArray(myData.received) ? myData.received : [];
  if(!rec.length) return;

  await update(myRef, { received: [] });
  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, ...rec]);
}

function getActionBlockReason(cardObj){
  if(!cardObj) return null;
  const sweetsOwners = getSweetsOwners();
  if(cardObj.name === '宣伝' || cardObj.name === '事故' || cardObj.name === '激推し'){
    if(sweetsOwners.length === 0) return '場にスイーツがありません。';
  }
  if(cardObj.name === '交換'){
    if(sweetsOwners.length <= 1) return '場に交換できるスイーツがありません。';
  }
  if(cardObj.name === '強奪'){
    if(getTotalVoteChipsOnField() <= 0) return '場に投票チップがありません。';
  }
  if(cardObj.name === '試行錯誤'){
    const excluded = state.room?.decks?.sweetsExcluded;
    if(!Array.isArray(excluded) || !excluded.length) return '除外山札にカードがありません。';
  }
  return null;
}

async function discardActionCardForPeek(cardObj){
  if(!state.roomCode) return false;
  if(!isMyTurn()) return false;
  if(isActionSelectionActive()) return false;
  const candidates = getSweetsOwners().filter(uid => uid !== state.userId && !!getSweetsCardByUid(uid));
  if(!candidates.length){
    showActionBlockedMessage('場に他プレイヤーのスイーツがありません。');
    return false;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, cardObj]);

  await emitEvent({ type:'actionDiscardPeek', card: cardObj, fromUid: state.userId });

  setActionSelection({
    type:'sweetsPeek',
    phase:'select',
    targetUid:null,
  });
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
  return true;
}

/* =========================
   カード使用：プレイサークル
   ========================= */
async function playCardToCircle(cardObj){
  if(!state.roomCode) return false;
  if(!isMyTurn()) return false;

  const receivedExists = hasReceivedInstruction();
  const isIgnore = (cardObj.kind === 'instruction' && cardObj.name === '無視');

  const receivedIds = new Set(getMyReceivedCards().map(card => card.id));
  const isReceived = receivedIds.has(cardObj.id);

  if(isReceived){
    await discardReceivedInstructionsForTurn();

    await emitEvent({ type:'revealCard', card: cardObj });
    await runActionCardEffect(cardObj);

    await endTurn('playReceivedInstruction');
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return true;
  }

  const blockReason = getActionBlockReason(cardObj);
  if(blockReason){
    showActionBlockedMessage(blockReason);
    return false;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, cardObj]);

  await emitEvent({ type:'revealCard', card: cardObj });

  if(receivedExists && isIgnore){
    await consumeReceivedInstruction();
    await endTurn('ignore_clear_received');
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return true;
  }

  const shouldEndTurn = await runActionCardEffect(cardObj);
  if(shouldEndTurn){
    await endTurn('playAction');
  }
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
  return true;
}

async function runActionCardEffect(cardObj){
  if(cardObj?.name === '盗聴'){
    await runWiretapEffect(cardObj);
    return true;
  }
  if(cardObj?.name === '監禁'){
    await runImprisonEffect();
    return true;
  }
  if(cardObj?.name === '偵察'){
    await runScoutEffect();
    return true;
  }
  if(cardObj?.name === '世代交代'){
    await runGenerationShiftEffect();
    return true;
  }
  if(cardObj?.name === '仕込み'){
    await runPreparationEffect(cardObj);
    return true;
  }
  if(cardObj?.name === '宣伝'){
    await runAdvertiseEffect();
    return true;
  }
  if(cardObj?.name === '交換'){
    await runExchangeEffect();
    return true;
  }
  if(cardObj?.name === '事故'){
    await runAccidentEffect();
    return true;
  }
  if(cardObj?.name === '強奪'){
    return await runRobEffect();
  }
  if(cardObj?.name === '激推し'){
    await runGekioshiEffect();
    return false;
  }
  if(cardObj?.name === 'ひらめき'){
    await runInspirationEffect();
    return true;
  }
  if(cardObj?.name === '試行錯誤'){
    return await runTrialEffect();
  }
  return true;
}

async function runGenerationShiftEffect(){
  if(!state.roomCode) return;
  const mySeat = getSeatByUid(state.userId) ?? state.seatedTable ?? null;
  if(mySeat == null) return;
  const currentLeaderSeat = state.turn?.leaderSeat ?? null;
  if(currentLeaderSeat === mySeat) return;
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await update(turnRef, { leaderSeat: mySeat });
}

async function runScoutEffect(){
  if(!state.room?.gameStarted) return;
  const targetUid = await beginScoutSelection();
  if(!targetUid) return;

  const fromSeat = state.turn?.activeSeat ?? state.seatedTable;
  const toSeat = getSeatByUid(targetUid);
  const arrowId = `scout-${state.userId}-${Date.now()}`;
  if(fromSeat !== null && toSeat !== null){
    await emitEvent({
      type:'scoutArrowStart',
      fromSeat,
      toSeat,
      fromUid: state.userId,
      arrowId,
    });
  }

  await showScoutReveal(targetUid);
  if(fromSeat !== null && toSeat !== null){
    removeWiretapArrow(arrowId);
    await emitEvent({
      type:'scoutArrowEnd',
      fromUid: state.userId,
      arrowId,
    });
  }
}

async function runPreparationEffect(cardObj){
  if(!state.roomCode) return;
  if(!cardObj) return;

  const base = `rooms/${state.roomCode}`;
  const [deckSnap, mySnap] = await Promise.all([
    get(ref(db, `${base}/decks/action`)),
    get(ref(db, `${base}/hands/${state.userId}`)),
  ]);
  const deck = deckSnap.val() || [];
  if(!Array.isArray(deck) || !deck.length) return;

  const myData = mySnap.val() || {};
  const action = Array.isArray(myData.action) ? myData.action : [];

  const nextCard = deck.shift();
  if(!nextCard) return;
  action.push(nextCard);

  await Promise.all([
    set(ref(db, `${base}/decks/action`), deck),
    update(ref(db, `${base}/hands/${state.userId}`), { action }),
  ]);

  const seat = getSeatByUid(state.userId) ?? state.seatedTable ?? null;
  await emitEvent({
    type: 'actionDrawToHand',
    toUid: state.userId,
    toSeat: seat,
  });
}

async function runAdvertiseEffect(){
  if(!state.room?.gameStarted) return;
  const candidates = getSweetsOwners();
  if(!candidates.length) return;
  const targetUid = await beginAdvertiseSelection();
  if(!targetUid) return;
  await revealAdvertisedSweets(targetUid);
}

async function runExchangeEffect(){
  if(!state.room?.gameStarted) return;
  const candidates = getSweetsOwners();
  if(candidates.length < 2) return;
  const selection = await beginExchangeSelection();
  if(!selection || selection.length < 2) return;
  const [firstUid, secondUid] = selection;
  if(!firstUid || !secondUid || firstUid === secondUid) return;
  await swapSweetsBetweenUids(firstUid, secondUid);
}

async function runAccidentEffect(){
  if(!state.room?.gameStarted) return;
  const candidates = getSweetsOwners();
  if(!candidates.length) return;
  const targetUid = await beginAccidentSelection();
  if(!targetUid) return;
  await emitEvent({ type:'sweetsReturn', uid: targetUid });
  await returnSweetsToDeckByUid(targetUid);
}

async function runRobEffect(){
  if(!state.room?.gameStarted) return true;
  const result = await beginRobSelection();
  if(typeof result === 'boolean') return result;
  return true;
}

async function runGekioshiEffect(){
  if(!state.roomCode) return;
  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const bonusChips = (typeof myData.bonusVoteChips === 'number') ? myData.bonusVoteChips : 0;
  await update(myRef, { bonusVoteChips: bonusChips + 1 });
  renderMyVoteChip();
  updatePassRoundBtn();
}

function getMySweetsRectForAnimation(){
  if(!mySweetsEl) return null;
  const wasHidden = mySweetsEl.classList.contains('hidden');
  const prevVisibility = mySweetsEl.style.visibility;
  if(wasHidden){
    mySweetsEl.classList.remove('hidden');
    mySweetsEl.style.visibility = 'hidden';
  }
  const rect = mySweetsEl.getBoundingClientRect();
  if(wasHidden){
    mySweetsEl.style.visibility = prevVisibility;
    mySweetsEl.classList.add('hidden');
  }
  if(!rect.width || !rect.height) return null;
  const width = mySweetsEl.offsetWidth || rect.width;
  const height = mySweetsEl.offsetHeight || rect.height;
  return {
    left: rect.left,
    top: rect.top,
    width,
    height,
  };
}

const sweetsRectCache = new Map();
function cacheSweetsRectFromElement(uid, el){
  if(!uid || !el) return;
  const rect = el.getBoundingClientRect();
  if(!rect.width || !rect.height) return;
  const width = el.offsetWidth || rect.width;
  const height = el.offsetHeight || rect.height;
  sweetsRectCache.set(uid, {
    left: rect.left,
    top: rect.top,
    width,
    height,
  });
}
function getSweetsRectForAnimation(uid){
  if(!uid) return null;
  if(uid === state.userId){
    const rect = getMySweetsRectForAnimation();
    if(rect) sweetsRectCache.set(uid, rect);
    return rect || sweetsRectCache.get(uid) || null;
  }
  const el = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"] .sweets-mini`);
  if(el && isVisibleRect(el)){
    cacheSweetsRectFromElement(uid, el);
  }
  return sweetsRectCache.get(uid) || null;
}

function animateSweetsFlyToMyHand(cardObj, fromRect, toRect){
  if(!cardObj || !fromRect || !toRect) return;
  const fly = document.createElement('div');
  fly.className = 'sweets-fly-card';
  fly.style.left = `${fromRect.left}px`;
  fly.style.top = `${fromRect.top}px`;
  fly.style.width = `${fromRect.width}px`;
  fly.style.height = `${fromRect.height}px`;

  const img = document.createElement('img');
  img.src = cardObj.img;
  img.alt = `sweets ${cardObj.value ?? ''}`;
  img.onerror = () => { if(cardObj.fallback) img.src = cardObj.fallback; };
  fly.appendChild(img);

  document.body.appendChild(fly);

  const dx = toRect.left - fromRect.left;
  const dy = toRect.top - fromRect.top;
  const scale = toRect.width / fromRect.width;

  fly.animate([
    { transform:'translate(0px, 0px) scale(1)' },
    { transform:`translate(${dx}px, ${dy}px) scale(${scale})` },
  ], {
    duration: 520,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => fly.remove();
}

async function returnMySweetsToDeckIfNeeded(){
  if(!state.roomCode) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const deckRef = ref(db, `rooms/${state.roomCode}/decks/sweets`);
  const [mySnap, deckSnap] = await Promise.all([get(myRef), get(deckRef)]);

  const myData = mySnap.val() || {};
  const sweetsArr = Array.isArray(myData.sweets) ? myData.sweets : [];
  if(!sweetsArr.length) return;

  const currentDeck = Array.isArray(deckSnap.val()) ? deckSnap.val() : [];
  const returningCard = sweetsArr[0];
  const nextDeck = [...currentDeck, returningCard];

  const fromRect = getMySweetsRectForAnimation();
  const target = getSweetsDeckTargetRect();

  await Promise.all([
    set(deckRef, nextDeck),
    update(myRef, { sweets: [] }),
  ]);

  if(fromRect && target){
    await animateOneCardToDeck(fromRect, target, { rotateFrom: 0, rotateTo: 0 });
  }
}

async function returnSweetsToDeckByUid(uid){
  if(!state.roomCode || !uid) return;
  const base = `rooms/${state.roomCode}`;
  const [handSnap, deckSnap] = await Promise.all([
    get(ref(db, `${base}/hands/${uid}`)),
    get(ref(db, `${base}/decks/sweets`)),
  ]);
  const handData = handSnap.val() || {};
  const sweetsArr = Array.isArray(handData.sweets) ? handData.sweets : [];
  if(!sweetsArr.length) return;

  const deck = Array.isArray(deckSnap.val()) ? deckSnap.val() : [];
  const returningCard = sweetsArr[0];
  const nextDeck = [...deck, returningCard];

  const updates = [
    set(ref(db, `${base}/decks/sweets`), nextDeck),
    update(ref(db, `${base}/hands/${uid}`), { sweets: [] }),
  ];
  if(state.game?.advertisedSweets?.[uid]){
    updates.push(remove(ref(db, `${base}/game/advertisedSweets/${uid}`)));
  }

  await Promise.all(updates);
}

async function animateSweetsReturnToDeck(uid){
  if(!uid) return;
  const fromRect = getSweetsRectForAnimation(uid);
  const target = getSweetsDeckTargetRect();
  if(fromRect && target){
    await animateOneCardToDeck(fromRect, target, { rotateFrom: 0, rotateTo: 0 });
  }
}

async function runInspirationEffect(){
  if(!state.room?.gameStarted) return;
  const selectionPromise = beginInspirationSelection();
  await returnMySweetsToDeckIfNeeded();
  await selectionPromise;
}

async function runTrialEffect(){
  if(!state.room?.gameStarted) return true;
  const excluded = state.room?.decks?.sweetsExcluded;
  if(!Array.isArray(excluded) || !excluded.length){
    showActionBlockedMessage('除外山札にカードがありません。');
    return true;
  }
  await beginTrialSelection();
  return true;
}

async function revealAdvertisedSweets(uid){
  if(!state.roomCode || !uid) return;
  const refPath = ref(db, `rooms/${state.roomCode}/game/advertisedSweets/${uid}`);
  await set(refPath, {
    revealedAt: Date.now(),
    byUid: state.userId,
  });
}

async function swapSweetsBetweenUids(firstUid, secondUid){
  if(!state.roomCode) return;
  if(firstUid === secondUid) return;
  const base = `rooms/${state.roomCode}/hands`;
  const [firstSnap, secondSnap] = await Promise.all([
    get(ref(db, `${base}/${firstUid}`)),
    get(ref(db, `${base}/${secondUid}`)),
  ]);
  const firstData = firstSnap.val() || {};
  const secondData = secondSnap.val() || {};
  const firstSweets = Array.isArray(firstData.sweets) ? firstData.sweets : [];
  const secondSweets = Array.isArray(secondData.sweets) ? secondData.sweets : [];
  if(!firstSweets.length || !secondSweets.length) return;
  const firstCard = firstSweets[0];
  const secondCard = secondSweets[0];

  await emitEvent({
    type:'sweetsSwap',
    fromUid:firstUid,
    toUid:secondUid,
    fromCard:firstCard,
    toCard:secondCard,
  });

  await Promise.all([
    update(ref(db, `${base}/${firstUid}`), { sweets: [secondCard] }),
    update(ref(db, `${base}/${secondUid}`), { sweets: [firstCard] }),
  ]);
}


async function runWiretapEffect(cardObj){
  if(!state.room?.gameStarted) return;
  const targetUid = await beginWiretapSelection();
  if(!targetUid) return;

  const fromSeat = state.turn?.activeSeat ?? state.seatedTable;
  const arrowId = `wiretap-${state.userId}-${Date.now()}`;
  if(fromSeat !== null){
    await emitEvent({
      type:'wiretapArrowStart',
      fromSeat,
      targetUid,
      fromUid: state.userId,
      arrowId,
    });
  }
  const roleKey = state.roles?.[targetUid] ?? null;
  await showRolePeekReveal(roleKey);
  if(fromSeat !== null){
    await emitEvent({
      type:'wiretapArrowEnd',
      fromUid: state.userId,
      arrowId,
    });
  }
}

async function runImprisonEffect(){
  if(!state.room?.gameStarted) return;
  const targetUid = await beginImprisonSelection();
  if(!targetUid || !state.roomCode) return;
  const imprisonRef = ref(db, `rooms/${state.roomCode}/game/imprisoned`);
  await set(imprisonRef, {
    uid: targetUid,
    byUid: state.userId,
    startedAt: Date.now(),
    roundNo: state.game?.roundNo ?? 1,
  });
}

async function showScoutReveal(targetUid){
  if(!scoutRevealOverlay || !scoutRevealGrid) return;
  scoutRevealGrid.innerHTML = '';
  const cards = Array.isArray(state.hands?.[targetUid]?.action)
    ? state.hands[targetUid].action
    : [];
  if(cards.length){
    cards.forEach(cardObj => {
      const cardEl = buildCardEl(cardObj);
      scoutRevealGrid.appendChild(cardEl);
    });
  }else{
    const empty = document.createElement('div');
    empty.textContent = '（アクションカードなし）';
    scoutRevealGrid.appendChild(empty);
  }

  if(scoutCloseConfirmPop) scoutCloseConfirmPop.classList.remove('hidden');
  scoutRevealOverlay.classList.remove('hidden');

  return new Promise(resolve => {
    const closeOverlay = () => {
      scoutRevealOverlay.classList.add('hidden');
      if(scoutCloseConfirmPop) scoutCloseConfirmPop.classList.add('hidden');
      scoutCloseYes?.removeEventListener('click', onCloseYes);
      resolve();
    };
    const onCloseYes = () => closeOverlay();
    scoutCloseYes?.addEventListener('click', onCloseYes);
  });
}

function showSweetsPeekReveal(cardObj){
  if(!sweetsPeekOverlay || !sweetsPeekImg || !sweetsPeekCard) return Promise.resolve(false);
  sweetsPeekImg.src = cardObj?.img || '';
  sweetsPeekImg.alt = `sweets ${cardObj?.value ?? ''}`;
  sweetsPeekImg.onerror = () => { if(cardObj?.fallback) sweetsPeekImg.src = cardObj.fallback; };
  if(sweetsPeekCloseConfirmPop) sweetsPeekCloseConfirmPop.classList.remove('hidden');
  sweetsPeekOverlay.classList.remove('hidden');

  return new Promise(resolve => {
    const closeOverlay = (shouldEnd) => {
      sweetsPeekOverlay.classList.add('hidden');
      if(sweetsPeekCloseConfirmPop) sweetsPeekCloseConfirmPop.classList.add('hidden');
      sweetsPeekCloseYes?.removeEventListener('click', onCloseYes);
      resolve(shouldEnd);
    };
    const onCloseYes = () => closeOverlay(true);
    sweetsPeekCloseYes?.addEventListener('click', onCloseYes);
  });
}

function showRolePeekReveal(roleKey){
  if(!rolePeekOverlay || !rolePeekImg || !rolePeekCard) return Promise.resolve(false);
  const info = roleToHelp(roleKey);
  rolePeekImg.src = info?.img || 'swroleura.jpg';
  rolePeekImg.alt = info?.name || 'role';
  if(rolePeekCloseConfirmPop) rolePeekCloseConfirmPop.classList.remove('hidden');
  rolePeekOverlay.classList.remove('hidden');

  return new Promise(resolve => {
    const closeOverlay = () => {
      rolePeekOverlay.classList.add('hidden');
      if(rolePeekCloseConfirmPop) rolePeekCloseConfirmPop.classList.add('hidden');
      rolePeekCloseYes?.removeEventListener('click', onCloseYes);
      resolve(true);
    };
    const onCloseYes = () => closeOverlay();
    rolePeekCloseYes?.addEventListener('click', onCloseYes);
  });
}

/* =========================
   指示カード：他プレイヤーへ渡す
   ========================= */
async function giveInstructionToPlayer(cardObj, targetSeat, targetUid){
  if(!state.roomCode) return false;
  if(!isMyTurn()) return false;

  if(!canUseOnOtherPlayer(cardObj)){
    return false;
  }

  if(cardObj?.name === '賄賂' && !hasSweets()){
    showActionBlockedMessage('自分のスイーツがありません。');
    return false;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const toRef = ref(db, `rooms/${state.roomCode}/hands/${targetUid}`);
  const toSnap = await get(toRef);
  const toData = toSnap.val() || {};
  const received = Array.isArray(toData.received) ? toData.received : [];
  const fromSeat = state.turn?.activeSeat ?? state.seatedTable;
  const receivedCard = { ...cardObj, fromUid: state.userId, fromSeat };
  const nextReceived = [...received, receivedCard];
  await update(toRef, { received: nextReceived });

  await emitEvent({ type:'flyBackCard', fromSeat, toSeat: targetSeat });

  await runInstructionCardEffect(cardObj, targetUid);

  await endTurn('giveInstruction_received');
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
  return true;
}
async function runInstructionCardEffect(cardObj, targetUid){
  return;
}

/* =========================
   ★ スイーツ：山札クリック → 一覧表示
   ========================= */
let sweetsPanelLocked = false;
const SWEETS_PANEL_MODE = {
  PICK: 'pick',
  TRIAL: 'trial',
};
let sweetsPanelMode = SWEETS_PANEL_MODE.PICK;
const SWEETS_PICK_SOURCE = {
  MAIN: 'main',
  EXCLUDED: 'excluded',
};
let sweetsPickSource = SWEETS_PICK_SOURCE.MAIN;
let trialDropPreviewEl = null;
let trialPendingSourceEl = null;

function setSweetsPanelMode(mode){
  sweetsPanelMode = mode;
  if(!sweetsPanelTitleEl || !sweetsDropZone) return;
  if(mode === SWEETS_PANEL_MODE.TRIAL){
    sweetsPanelTitleEl.textContent = 'スイーツ（除外エリアにドラッグ）';
    sweetsDropZone.textContent = 'スイーツ山札から除外したいカードをここにドラッグしてください。';
    sweetsDropZone.setAttribute('aria-label', 'スイーツ除外エリア');
    sweetsDropZone.classList.add('trial');
    sweetsBackdrop?.classList.add('trial');
    return;
  }
  sweetsPanelTitleEl.textContent = sweetsPanelDefaultTitle;
  sweetsDropZone.textContent = sweetsDropZoneDefaultText;
  sweetsDropZone.setAttribute('aria-label', 'スイーツ獲得エリア');
  sweetsDropZone.classList.remove('trial');
  sweetsBackdrop?.classList.remove('trial');
}

function clearTrialDropPreview(options = {}){
  const { restoreSource = true } = options;
  if(trialDropPreviewEl){
    trialDropPreviewEl.remove();
    trialDropPreviewEl = null;
  }
  if(restoreSource && trialPendingSourceEl){
    trialPendingSourceEl.style.visibility = '';
  }
  trialPendingSourceEl = null;
}

function showTrialDropPreview(cardObj){
  if(!sweetsDropZone || !cardObj) return;
  clearTrialDropPreview({ restoreSource: false });
  const preview = document.createElement('div');
  preview.className = 'trial-drop-preview';
  const img = document.createElement('img');
  img.src = cardObj.img;
  img.alt = `sweets ${cardObj.value ?? ''}`;
  img.onerror = () => { if(cardObj.fallback) img.src = cardObj.fallback; };
  preview.appendChild(img);
  sweetsDropZone.appendChild(preview);
  trialDropPreviewEl = preview;
}

function canOpenSweetsPicker(){
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(isActionSelectionActive()) return false;
  if(getMyBonusVoteChips() > 0) return false;
  if(hasSweets()) return false;
  const instructionNames = getActiveInstructionNames();
  if(instructionNames.size > 0 && !instructionNames.has('応援') && !instructionNames.has('脅迫')) return false;
  const deck = state.room?.decks?.sweets;
  if(!Array.isArray(deck) || !deck.length) return false;
  return true;
}

function canOpenExcludedSweetsPicker(){
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(actionSelection?.type !== 'inspiration' || actionSelection.phase !== 'select') return false;
  const deck = state.room?.decks?.sweetsExcluded;
  if(!Array.isArray(deck) || !deck.length) return false;
  return true;
}

function getSweetsInstructionRestriction(){
  const instructionNames = getActiveInstructionNames();
  const needsMax = instructionNames.has('応援');
  const needsMin = instructionNames.has('脅迫');
  if(!needsMax && !needsMin) return null;
  return { needsMax, needsMin };
}

function getRestrictedSweetsIds(deck){
  const restriction = getSweetsInstructionRestriction();
  if(!restriction) return null;
  const values = deck.map(card => (typeof card.value === 'number' ? card.value : 0));
  const maxValue = Math.max(...values);
  const minValue = Math.min(...values);
  const allowed = new Set();
  deck.forEach(card => {
    if(restriction.needsMax && card.value === maxValue) allowed.add(card.id);
    if(restriction.needsMin && card.value === minValue) allowed.add(card.id);
  });
  return allowed;
}

function canStartSweetsDrag(source){
  if(sweetsPanelMode === SWEETS_PANEL_MODE.TRIAL){
    return actionSelection?.type === 'trial' && actionSelection.phase === 'select';
  }
  if(source === SWEETS_PICK_SOURCE.EXCLUDED){
    return canOpenExcludedSweetsPicker();
  }
  return canOpenSweetsPicker();
}

function adjustSweetsPanelHeight(){
  if(!sweetsPanelBodyEl || !sweetsGrid) return;
  const panelEl = sweetsPanelBodyEl.closest('.sweets-panel');
  if(!panelEl) return;
  const cardEl = sweetsGrid.querySelector('.sweets-pick-card');
  if(!cardEl){
    sweetsPanelBodyEl.style.maxHeight = '';
    return;
  }
  const cardRect = cardEl.getBoundingClientRect();
  const cardHeight = cardRect.height || 135;
  const gridStyles = getComputedStyle(sweetsGrid);
  const gapValue = parseFloat(gridStyles.rowGap || gridStyles.gap) || 10;
  const totalCards = sweetsGrid.children.length;
  const cols = sweetsGridCols || 1;
  const rows = Math.ceil(totalCards / cols);
  const panelRect = panelEl.getBoundingClientRect();
  const availableHeight = Math.max(0, window.innerHeight - panelRect.top - 24);
  const contentHeight = rows * cardHeight + Math.max(0, rows - 1) * gapValue;
  const pulseBuffer = Math.ceil(cardHeight * 0.16);
  if(!availableHeight){
    sweetsPanelBodyEl.style.maxHeight = '';
    return;
  }
  const maxRows = Math.max(1, Math.floor((availableHeight + gapValue) / (cardHeight + gapValue)));
  const visibleRows = Math.min(rows, maxRows);
  const targetHeight = visibleRows * cardHeight + Math.max(0, visibleRows - 1) * gapValue;
  const maxHeight = Math.min(contentHeight, availableHeight);
  sweetsPanelBodyEl.style.maxHeight = `${Math.min(maxHeight, targetHeight + pulseBuffer)}px`;
}

async function setSweetsDeckFocus(active){
  if(!state.roomCode) return;
  const focusRef = ref(db, `rooms/${state.roomCode}/game/sweetsDeckFocus`);
  const current = getSweetsDeckFocus();
  if(active){
    if(current?.uid === state.userId && current.active) return;
    await set(focusRef, { uid: state.userId, active: true, ts: Date.now() });
    return;
  }
  if(current?.uid !== state.userId) return;
  await set(focusRef, null);
}

async function setSweetsExcludedDeckFocus(active){
  if(!state.roomCode) return;
  const focusRef = ref(db, `rooms/${state.roomCode}/game/sweetsExcludedFocus`);
  const current = getSweetsExcludedDeckFocus();
  if(active){
    if(current?.uid === state.userId && current.active) return;
    await set(focusRef, { uid: state.userId, active: true, ts: Date.now() });
    return;
  }
  if(current?.uid !== state.userId) return;
  await set(focusRef, null);
}

function openSweetsPicker(options = {}){
  const source = options.source ?? SWEETS_PICK_SOURCE.MAIN;
  const mode = options.mode ?? SWEETS_PANEL_MODE.PICK;
  const highlightedIds = options.highlightedIds ?? null;
  const deck = source === SWEETS_PICK_SOURCE.EXCLUDED
    ? state.room?.decks?.sweetsExcluded
    : state.room?.decks?.sweets;
  if(!Array.isArray(deck) || !deck.length) return;

  sweetsPanelLocked = true;
  btnSweetsClose.disabled = true;
  sweetsPickSource = source;
  setSweetsPanelMode(mode);

  const sorted = [...deck].sort((a,b)=> (a.value ?? 0) - (b.value ?? 0));
  const allowedIds = (source === SWEETS_PICK_SOURCE.MAIN && mode === SWEETS_PANEL_MODE.PICK)
    ? getRestrictedSweetsIds(sorted)
    : null;
  const cols = Math.ceil(sorted.length / 2);
  sweetsGridCols = cols;
  sweetsGrid.style.gridTemplateColumns = `repeat(${cols}, 90px)`;

  sweetsGrid.innerHTML = '';
  sorted.forEach(cardObj => {
    const el = document.createElement('div');
    el.className = 'sweets-pick-card';
    el.dataset.cardId = cardObj.id;
    if(allowedIds && !allowedIds.has(cardObj.id)){
      el.classList.add('restricted');
    }

    const img = document.createElement('img');
    img.src = cardObj.img;
    img.alt = `sweets ${cardObj.value ?? ''}`;
    img.onerror = () => { if(cardObj.fallback) img.src = cardObj.fallback; };

    el.appendChild(img);
    if(highlightedIds && highlightedIds.has(cardObj.id)){
      el.classList.add('trial-added');
      const note = document.createElement('div');
      note.className = 'trial-added-note';
      note.textContent = '除外された山札から追加されました。';
      el.appendChild(note);
    }
    if(!el.classList.contains('restricted')){
      el.addEventListener('pointerdown', (e) => startDragSweets(e, cardObj, el));
    }
    sweetsGrid.appendChild(el);
  });

  sweetsBackdrop.classList.remove('hidden');
  requestAnimationFrame(adjustSweetsPanelHeight);
  if(source === SWEETS_PICK_SOURCE.MAIN && mode !== SWEETS_PANEL_MODE.TRIAL){
    setSweetsDeckFocus(true);
  }
}

function closeSweetsPicker(){
  if(sweetsPanelLocked) return;
  sweetsBackdrop.classList.add('hidden');
  setSweetsPanelMode(SWEETS_PANEL_MODE.PICK);
  setSweetsDeckFocus(false);
  if(sweetsExcludedFocusActive){
    sweetsExcludedFocusActive = false;
    setSweetsExcludedDeckFocus(false);
  }
}

function getTrialAddedIds(){
  if(actionSelection?.type !== 'trial') return null;
  return new Set(Array.isArray(actionSelection.addedIds) ? actionSelection.addedIds : []);
}

function openTrialSweetsPicker(){
  const highlightedIds = getTrialAddedIds();
  clearTrialDropPreview();
  openSweetsPicker({
    source: SWEETS_PICK_SOURCE.MAIN,
    mode: SWEETS_PANEL_MODE.TRIAL,
    highlightedIds,
  });
}

function buildDeckTargetFromRect(rect){
  return rect ? {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2,
    w: rect.width,
    h: rect.height,
    raw: rect,
  } : null;
}

async function moveTopExcludedToSweetsDeckForTrial(){
  if(!state.roomCode) return null;
  const base = `rooms/${state.roomCode}/decks`;
  const [sweetsSnap, excludedSnap] = await Promise.all([
    get(ref(db, `${base}/sweets`)),
    get(ref(db, `${base}/sweetsExcluded`)),
  ]);
  const deck = Array.isArray(sweetsSnap.val()) ? sweetsSnap.val() : [];
  const excluded = Array.isArray(excludedSnap.val()) ? excludedSnap.val() : [];
  if(!excluded.length) return null;

  const movedCard = excluded.shift();
  const nextDeck = [...deck, movedCard];

  await Promise.all([
    set(ref(db, `${base}/sweets`), nextDeck),
    set(ref(db, `${base}/sweetsExcluded`), excluded),
  ]);

  updateSweetsDeckUI();
  await emitEvent({ type:'trialExcludedToSweets', byUid: state.userId });
  await animateTrialExcludedToSweets();
  return movedCard;
}

async function getExcludedDeckTargetRectForTrial(){
  const rect = await getSweetsExcludedDeckRectForMiniShuffle();
  return buildDeckTargetFromRect(rect);
}

async function animateTrialExcludedToSweets(){
  const fromRect = await getSweetsExcludedDeckRectForMiniShuffle();
  const target = getSweetsDeckTargetRect();
  if(fromRect && target){
    await animateOneCardToDeck(fromRect, target, { rotateFrom: 90, rotateTo: 0 });
  }
}

async function animateTrialSweetsToExcluded(){
  const fromRect = await getSweetsDeckRectForMiniShuffle();
  const target = await getExcludedDeckTargetRectForTrial();
  if(fromRect && target){
    await animateOneCardToDeck(fromRect, target, { rotateFrom: 0, rotateTo: 90 });
  }
}

async function handleTrialSweetsDeckClick(){
  if(actionSelection?.type !== 'trial') return;
  if(actionSelection.phase === 'draw'){
    const moved = await moveTopExcludedToSweetsDeckForTrial();
    if(!moved){
      showActionBlockedMessage('除外山札にカードがありません。');
      return;
    }
    const nextAdded = Array.isArray(actionSelection.addedIds)
      ? [...actionSelection.addedIds, moved.id]
      : [moved.id];
    setActionSelection({
      ...actionSelection,
      phase: 'select',
      addedIds: nextAdded,
    });
    openTrialSweetsPicker();
  }
}
btnSweetsClose.addEventListener('click', closeSweetsPicker);
sweetsBackdrop.addEventListener('click', (e) => {
  if(e.target === sweetsBackdrop) closeSweetsPicker();
});

sweetsDeckUI.addEventListener('click', async () => {
  if(actionSelection?.type === 'trial'){
    await handleTrialSweetsDeckClick();
    return;
  }
  if(!canOpenSweetsPicker()) return;
  openSweetsPicker();
});
sweetsExcludedDeckUI.addEventListener('click', () => {
  if(!canOpenExcludedSweetsPicker()) return;
  if(actionSelection?.type === 'inspiration'){
    sweetsExcludedFocusActive = true;
    setSweetsExcludedDeckFocus(true);
    requestAnimationFrame(updateSweetsExcludedDeckRelocation);
  }
  openSweetsPicker({ source: SWEETS_PICK_SOURCE.EXCLUDED });
});

/* =========================
   ★ スイーツ：ドラッグ → dropZone で獲得
   ========================= */
const sweetsDrag = {
  active:false,
  card:null,
  srcEl:null,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
  source:SWEETS_PICK_SOURCE.MAIN,
};

function startDragSweets(e, cardObj, srcEl){
  if(!canStartSweetsDrag(sweetsPickSource)) return;
  if(srcEl.classList.contains('restricted')) return;
  e.preventDefault();

  sweetsDrag.active = true;
  sweetsDrag.card = cardObj;
  sweetsDrag.srcEl = srcEl;
  sweetsDrag.source = sweetsPickSource;
  const r = srcEl.getBoundingClientRect();
  sweetsDrag.offsetX = e.clientX - r.left;
  sweetsDrag.offsetY = e.clientY - r.top;
  sweetsDrag.lastClientX = e.clientX;
  sweetsDrag.lastClientY = e.clientY;

  const ghost = srcEl.cloneNode(true);
  ghost.classList.add('sweets-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  sweetsDrag.ghost = ghost;
  sweetsDrag.srcEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onSweetsDragMove);
  ghost.addEventListener('pointerup', onSweetsDragEnd);
  ghost.addEventListener('pointercancel', onSweetsDragEnd);
}

function onSweetsDragMove(e){
  if(!sweetsDrag.active || !sweetsDrag.ghost) return;
  const x = e.clientX - sweetsDrag.offsetX;
  const y = e.clientY - sweetsDrag.offsetY;
  sweetsDrag.lastClientX = e.clientX;
  sweetsDrag.lastClientY = e.clientY;
  sweetsDrag.ghost.style.left = `${x}px`;
  sweetsDrag.ghost.style.top  = `${y}px`;

  if(sweetsDropZone){
    const zoneR = sweetsDropZone.getBoundingClientRect();
    const inZone = (e.clientX >= zoneR.left && e.clientX <= zoneR.right && e.clientY >= zoneR.top && e.clientY <= zoneR.bottom);
    sweetsDropZone.classList.toggle('active', inZone);
  }
}

async function onSweetsDragEnd(e){
  if(!sweetsDrag.active) return;

  const gx = e.clientX;
  const gy = e.clientY;

  const zoneR = sweetsDropZone?.getBoundingClientRect();
  const inDropZone = zoneR
    ? (gx >= zoneR.left && gx <= zoneR.right && gy >= zoneR.top && gy <= zoneR.bottom)
    : false;

  if(inDropZone){
    if(sweetsPanelMode === SWEETS_PANEL_MODE.TRIAL){
      if(actionSelection?.type === 'trial' && actionSelection.phase === 'select'){
        const srcRect = sweetsDrag.srcEl?.getBoundingClientRect();
        trialPendingSourceEl = sweetsDrag.srcEl;
        showTrialDropPreview(sweetsDrag.card);
        setActionSelection({
          ...actionSelection,
          phase: 'confirm',
          pendingCard: sweetsDrag.card,
          sourceRect: srcRect
            ? { left: srcRect.left, top: srcRect.top, width: srcRect.width, height: srcRect.height }
            : null,
        });
      }
      cleanupSweetsDrag({ restoreSource: false });
      return;
    }
    if(sweetsDrag.source === SWEETS_PICK_SOURCE.EXCLUDED){
      await acquireExcludedSweetsCard(sweetsDrag.card);
    }else{
      await acquireSweetsCard(sweetsDrag.card);
    }
    cleanupSweetsDrag();
    return;
  }

  cleanupSweetsDrag();
}

function cleanupSweetsDrag(options = {}){
  const { restoreSource = true } = options;
  if(sweetsDrag.ghost){
    sweetsDrag.ghost.removeEventListener('pointermove', onSweetsDragMove);
    sweetsDrag.ghost.removeEventListener('pointerup', onSweetsDragEnd);
    sweetsDrag.ghost.removeEventListener('pointercancel', onSweetsDragEnd);
    sweetsDrag.ghost.remove();
  }
  if(restoreSource && sweetsDrag.srcEl){
    sweetsDrag.srcEl.style.visibility = '';
  }
  sweetsDropZone?.classList.remove('active');
  sweetsDrag.active = false;
  sweetsDrag.card = null;
  sweetsDrag.srcEl = null;
  sweetsDrag.ghost = null;
  sweetsDrag.offsetX = 0;
  sweetsDrag.offsetY = 0;
  sweetsDrag.lastClientX = null;
  sweetsDrag.lastClientY = null;
  sweetsDrag.source = SWEETS_PICK_SOURCE.MAIN;
}

async function acquireSweetsCard(cardObj){
  if(!state.roomCode) return;
  if(!canOpenSweetsPicker()) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const already = Array.isArray(myData.sweets) && myData.sweets.length;
  if(already) return;

  const deckRef = ref(db, `rooms/${state.roomCode}/decks/sweets`);
  const deckSnap = await get(deckRef);
  const deck = deckSnap.val() || [];
  const exists = Array.isArray(deck) && deck.some(c => c.id === cardObj.id);
  if(!exists) return;

  const nextDeck = deck.filter(c => c.id !== cardObj.id);

  await set(deckRef, nextDeck);
  await update(myRef, { sweets: [cardObj] });

  sweetsPanelLocked = false;
  btnSweetsClose.disabled = false;
  closeSweetsPicker();

  await endTurn('drawSweets');

  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

async function acquireExcludedSweetsCard(cardObj){
  if(!state.roomCode) return;
  if(!canOpenExcludedSweetsPicker()) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const already = Array.isArray(myData.sweets) && myData.sweets.length;
  if(already) return;

  const deckRef = ref(db, `rooms/${state.roomCode}/decks/sweetsExcluded`);
  const deckSnap = await get(deckRef);
  const deck = deckSnap.val() || [];
  const exists = Array.isArray(deck) && deck.some(c => c.id === cardObj.id);
  if(!exists) return;

  const nextDeck = deck.filter(c => c.id !== cardObj.id);
  const fromRect = await getSweetsExcludedDeckRectForMiniShuffle();
  const toRect = getMySweetsRectForAnimation();

  await Promise.all([
    set(deckRef, nextDeck),
    update(myRef, { sweets: [cardObj] }),
  ]);

  sweetsPanelLocked = false;
  btnSweetsClose.disabled = false;
  closeSweetsPicker();

  if(fromRect && toRect){
    requestAnimationFrame(() => {
      animateSweetsFlyToMyHand(cardObj, fromRect, toRect);
    });
  }

  if(actionSelection?.type === 'inspiration'){
    const resolve = actionSelection.resolve;
    clearActionSelection();
    if(resolve) resolve(cardObj);
  }

  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   ★ 強奪：投票チップドラッグ
   ========================= */
const robVoteDrag = {
  active:false,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
  sourceEl:null,
  fromTargetUid:null,
  voterUid:null,
  sourceRect:null,
};
function shouldEnableRobVoteDrag(){
  return actionSelection?.type === 'rob' && actionSelection.phase === 'select';
}
function canRobMoveTo(uid, fromUid){
  if(!uid || uid === fromUid) return false;
  const handData = state.hands?.[uid];
  return !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);
}
function setRobSweetsWrapHints(active, options = {}){
  const { fromUid = null } = options;
  document.querySelectorAll('.sweets-wrap').forEach((wrap) => {
    wrap.classList.remove('hint-ok', 'hint-ng');
    if(!active) return;
    const uid = wrap.dataset.sweetsUid || null;
    const ok = canRobMoveTo(uid, fromUid);
    wrap.classList.add(ok ? 'hint-ok' : 'hint-ng');
  });
  if(mySweetsEl){
    mySweetsEl.classList.remove('hint-ok', 'hint-ng');
    if(active){
      const ok = canRobMoveTo(state.userId, fromUid);
      mySweetsEl.classList.add(ok ? 'hint-ok' : 'hint-ng');
    }
  }
}
function getRobDropTarget(x,y, fromUid){
  const el = document.elementFromPoint(x,y);
  const wrap = el?.closest?.('.sweets-wrap');
  if(wrap){
    const uid = wrap.dataset.sweetsUid || null;
    return { type:'swwrap', uid, ok: canRobMoveTo(uid, fromUid) };
  }
  const myWrap = el?.closest?.('#mySweets');
  if(myWrap){
    const uid = state.userId;
    return { type:'mySweets', uid, ok: canRobMoveTo(uid, fromUid) };
  }
  return { type:'none' };
}
function startRobVoteDrag(e, sourceEl){
  if(!shouldEnableRobVoteDrag()) return;
  const voterUid = sourceEl?.dataset?.voterUid || null;
  const fromTargetUid = sourceEl?.dataset?.targetUid || null;
  if(!voterUid || !fromTargetUid) return;
  e.preventDefault();

  const r = sourceEl.getBoundingClientRect();
  robVoteDrag.active = true;
  robVoteDrag.sourceEl = sourceEl;
  robVoteDrag.fromTargetUid = fromTargetUid;
  robVoteDrag.voterUid = voterUid;
  robVoteDrag.offsetX = e.clientX - r.left;
  robVoteDrag.offsetY = e.clientY - r.top;
  robVoteDrag.lastClientX = e.clientX;
  robVoteDrag.lastClientY = e.clientY;
  robVoteDrag.sourceRect = {
    left: r.left,
    top: r.top,
    width: r.width,
    height: r.height,
  };

  setRobSweetsWrapHints(true, { fromUid: fromTargetUid });

  const ghost = sourceEl.cloneNode(true);
  ghost.classList.add('vote-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  robVoteDrag.ghost = ghost;
  robVoteDrag.sourceEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onRobVoteDragMove);
  ghost.addEventListener('pointerup', onRobVoteDragEnd);
  ghost.addEventListener('pointercancel', onRobVoteDragEnd);
}
function onRobVoteDragMove(e){
  if(!robVoteDrag.active || !robVoteDrag.ghost) return;
  const x = e.clientX - robVoteDrag.offsetX;
  const y = e.clientY - robVoteDrag.offsetY;
  robVoteDrag.lastClientX = e.clientX;
  robVoteDrag.lastClientY = e.clientY;
  robVoteDrag.ghost.style.left = `${x}px`;
  robVoteDrag.ghost.style.top  = `${y}px`;
}
function onRobVoteDragEnd(e){
  if(!robVoteDrag.active) return;

  const drop = getRobDropTarget(e.clientX, e.clientY, robVoteDrag.fromTargetUid);
  const fromTargetUid = robVoteDrag.fromTargetUid;
  const voterUid = robVoteDrag.voterUid;
  const sourceRect = robVoteDrag.sourceRect;

  cleanupRobVoteDrag();

  if(!actionSelection || actionSelection.type !== 'rob') return;
  if(drop.type === 'none' || !drop.ok) return;
  if(drop.uid === fromTargetUid) return;

  setActionSelection({
    ...actionSelection,
    phase:'confirm',
    fromTargetUid,
    toTargetUid: drop.uid,
    voterUid,
    sourceRect,
  });
}
function cleanupRobVoteDrag(){
  if(robVoteDrag.ghost){
    robVoteDrag.ghost.removeEventListener('pointermove', onRobVoteDragMove);
    robVoteDrag.ghost.removeEventListener('pointerup', onRobVoteDragEnd);
    robVoteDrag.ghost.removeEventListener('pointercancel', onRobVoteDragEnd);
    robVoteDrag.ghost.remove();
  }
  if(robVoteDrag.sourceEl){
    robVoteDrag.sourceEl.style.visibility = '';
  }
  setRobSweetsWrapHints(false);
  robVoteDrag.active = false;
  robVoteDrag.ghost = null;
  robVoteDrag.offsetX = 0;
  robVoteDrag.offsetY = 0;
  robVoteDrag.lastClientX = null;
  robVoteDrag.lastClientY = null;
  robVoteDrag.sourceEl = null;
  robVoteDrag.fromTargetUid = null;
  robVoteDrag.voterUid = null;
  robVoteDrag.sourceRect = null;
}

/* =========================
   ★ 投票：チップドラッグ → swarea へドロップ
   ========================= */
const voteDrag = {
  active:false,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
  sourceEl:null,
  showAllHints:false,
  useBonus:false,
};
let hoverSwarea = null;

function isVoteTargetAllowed(uid, options = {}){
  const { useBonus = getMyBonusVoteChips() > 0 } = options;
  const bribeTargetUids = getActiveBribeTargetUids();
  if(bribeTargetUids.length && !bribeTargetUids.includes(uid)) return false;
  if(useBonus && uid === state.userId) return false;
  return true;
}

function setAllSweetsWrapHints(active, options = {}){
  const { useBonus = false } = options;
  document.querySelectorAll('.sweets-wrap').forEach((wrap) => {
    wrap.classList.remove('hint-ok', 'hint-ng');
    if(!active) return;
    const circle = wrap.closest('.otherplayerscircle');
    const tag = circle?.querySelector('.player-tag');
    const uid = tag?.dataset?.uid || null;
    if(!uid || !isVoteTargetAllowed(uid, { useBonus })) return;
    const ok = !wrap.classList.contains('empty');
    wrap.classList.add(ok ? 'hint-ok' : 'hint-ng');
  });
}

function clearSwareaHint(){
  if(!hoverSwarea) return;
  hoverSwarea.classList.remove('hint-ok','hint-ng');
  hoverSwarea = null;
}
function updateSwareaHint(x,y){
  if(voteDrag.showAllHints) return;
  clearSwareaHint();
  const drop = getVoteDropTarget(x,y, { useBonus: voteDrag.useBonus });
  if(drop.type !== 'swwrap') return;
  if(!isVoteTargetAllowed(drop.uid, { useBonus: voteDrag.useBonus })) return;
  const el = document.elementFromPoint(x,y);
  const area = el?.closest?.('.sweets-wrap');
  if(!area) return;
  const ok = drop.ok;
  area.classList.add(ok ? 'hint-ok' : 'hint-ng');
  hoverSwarea = area;
}
function getVoteDropTarget(x,y, options = {}){
  const { useBonus = false } = options;
  const el = document.elementFromPoint(x,y);
  const wrap = el?.closest?.('.sweets-wrap');   // ★変更
  if(!wrap) return { type:'none' };

  // ★ tagは祖先じゃないので、otherplayerscircle から uid を取る
  const circle = wrap.closest('.otherplayerscircle');
  const tag = circle?.querySelector('.player-tag');
  const uid = tag?.dataset?.uid || null;
  if(!uid) return { type:'none' };
  if(!isVoteTargetAllowed(uid, { useBonus })) return { type:'swwrap', uid, ok:false };

  const handData = state.hands?.[uid];
  const hasTheirSweets = !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);

  return { type:'swwrap', uid, ok: hasTheirSweets };
}

function startDragVoteChip(e, options = {}){
  const { useBonus = false, sourceEl = myVoteChipEl } = options;
  if(!canVoteNow({ useBonus })) return;
  e.preventDefault();

  const r = sourceEl.getBoundingClientRect();
  voteDrag.active = true;
  voteDrag.sourceEl = sourceEl;
  voteDrag.offsetX = e.clientX - r.left;
  voteDrag.offsetY = e.clientY - r.top;
  voteDrag.lastClientX = e.clientX;
  voteDrag.lastClientY = e.clientY;
  voteDrag.useBonus = useBonus;

  voteDrag.showAllHints = true;
  setAllSweetsWrapHints(true, { useBonus });

  const ghost = sourceEl.cloneNode(true);
  ghost.classList.remove('hidden');
  ghost.classList.add('vote-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  voteDrag.ghost = ghost;
  voteDrag.sourceEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onVoteDragMove);
  ghost.addEventListener('pointerup', onVoteDragEnd);
  ghost.addEventListener('pointercancel', onVoteDragEnd);
}

function onVoteDragMove(e){
  if(!voteDrag.active || !voteDrag.ghost) return;
  const x = e.clientX - voteDrag.offsetX;
  const y = e.clientY - voteDrag.offsetY;
  voteDrag.lastClientX = e.clientX;
  voteDrag.lastClientY = e.clientY;
  voteDrag.ghost.style.left = `${x}px`;
  voteDrag.ghost.style.top  = `${y}px`;
  updateSwareaHint(e.clientX, e.clientY);
}

async function onVoteDragEnd(e){
  if(!voteDrag.active) return;

  const drop = getVoteDropTarget(e.clientX, e.clientY, { useBonus: voteDrag.useBonus });
  clearSwareaHint();

  if(drop.type === 'swwrap' && drop.ok){   // ★変更
    await castVote(drop.uid, { useBonus: voteDrag.useBonus });
  }

  cleanupVoteDrag();
}

function cleanupVoteDrag(){
  if(voteDrag.ghost){
    voteDrag.ghost.removeEventListener('pointermove', onVoteDragMove);
    voteDrag.ghost.removeEventListener('pointerup', onVoteDragEnd);
    voteDrag.ghost.removeEventListener('pointercancel', onVoteDragEnd);
    voteDrag.ghost.remove();
  }
if(voteDrag.sourceEl){
    voteDrag.sourceEl.style.visibility = '';
  }
  voteDrag.active = false;
  voteDrag.showAllHints = false;
  setAllSweetsWrapHints(false);
  clearSwareaHint();
  voteDrag.ghost = null;
  voteDrag.offsetX = 0;
  voteDrag.offsetY = 0;
  voteDrag.lastClientX = null;
  voteDrag.lastClientY = null;
  voteDrag.sourceEl = null;
  voteDrag.useBonus = false;
}

function syncFloatingDragPositions(){
  if(drag.active && drag.el && drag.lastClientX !== null && drag.lastClientY !== null){
    const x = drag.lastClientX - drag.offsetX;
    const y = drag.lastClientY - drag.offsetY;
    drag.el.style.left = `${x}px`;
    drag.el.style.top  = `${y}px`;
    updateOtherCircleHint(drag.lastClientX, drag.lastClientY, drag.card);
  }

  if(sweetsDrag.active && sweetsDrag.ghost && sweetsDrag.lastClientX !== null && sweetsDrag.lastClientY !== null){
    const x = sweetsDrag.lastClientX - sweetsDrag.offsetX;
    const y = sweetsDrag.lastClientY - sweetsDrag.offsetY;
    sweetsDrag.ghost.style.left = `${x}px`;
    sweetsDrag.ghost.style.top  = `${y}px`;
  }

  if(voteDrag.active && voteDrag.ghost && voteDrag.lastClientX !== null && voteDrag.lastClientY !== null){
    const x = voteDrag.lastClientX - voteDrag.offsetX;
    const y = voteDrag.lastClientY - voteDrag.offsetY;
    voteDrag.ghost.style.left = `${x}px`;
    voteDrag.ghost.style.top  = `${y}px`;
    updateSwareaHint(voteDrag.lastClientX, voteDrag.lastClientY);
  }

  if(robVoteDrag.active && robVoteDrag.ghost && robVoteDrag.lastClientX !== null && robVoteDrag.lastClientY !== null){
    const x = robVoteDrag.lastClientX - robVoteDrag.offsetX;
    const y = robVoteDrag.lastClientY - robVoteDrag.offsetY;
    robVoteDrag.ghost.style.left = `${x}px`;
    robVoteDrag.ghost.style.top  = `${y}px`;
  }
  updateSweetsDeckRelocation();
  updateSweetsExcludedDeckRelocation();
  if(sweetsBackdrop && !sweetsBackdrop.classList.contains('hidden')){
    adjustSweetsPanelHeight();
  }
}

mainEl.addEventListener('scroll', syncFloatingDragPositions, { passive: true });
window.addEventListener('resize', syncFloatingDragPositions);

async function castVote(targetUid, options = {}){
  if(!state.roomCode) return;
  const { useBonus = false } = options;
  if(!canVoteNow({ useBonus })) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const chips = (typeof myData.voteChips === 'number') ? myData.voteChips : 1;
  const bonusChips = (typeof myData.bonusVoteChips === 'number') ? myData.bonusVoteChips : 0;
  if(useBonus){
    if(bonusChips <= 0) return;
  }else{
    if(bonusChips > 0) return;
    if(chips <= 0) return;
  }

  // 1) 自分のチップ消費（手元から消える）
  if(useBonus){
    await update(myRef, { bonusVoteChips: bonusChips - 1 });
  }else{
    await update(myRef, { voteChips: chips - 1 });
  }

  // 2) 投票記録（ターゲットの右側に表示される）
  const targetRef = ref(db, `rooms/${state.roomCode}/votes/${targetUid}/${state.userId}`);
  const targetSnap = await get(targetRef);
  const currentCount = (typeof targetSnap.val() === 'number') ? targetSnap.val() : (targetSnap.exists() ? 1 : 0);
  await set(targetRef, currentCount + 1);

  // 3) これは1投票（手番終了）
  await endTurn('vote');

  renderMyVoteChip();
  updatePassRoundBtn();
}

/* ★ 投票チップ：pointerdown */
myVoteChipEl.addEventListener('pointerdown', (e) => {
  startDragVoteChip(e, { useBonus: false, sourceEl: myVoteChipEl });
});
myBonusVoteChipEl.addEventListener('pointerdown', (e) => {
  startDragVoteChip(e, { useBonus: true, sourceEl: myBonusVoteChipEl });
});

/* =========================
   Seat UI（既存）
   ========================= */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
          const tables = tablesSnap.val() || {};
          const tagChipStyle = pickRandomTagChipStyle(tables);
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName, tagChipStyle });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
        const tables = tablesSnap.val() || {};
        const tagChipStyle = pickRandomTagChipStyle(tables);
        await set(tRef, { playerId: state.userId, playerName: state.userName, tagChipStyle });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* =========================
   追い出しダイアログ（既存）
   ========================= */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const tagChipStyle = pickRandomTagChipStyle(tables);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し', tagChipStyle });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   ホストUI（既存）
   ========================= */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  resetLocalGameEffects();
  await hostGameStart();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/roles`)),
    remove(ref(db, `${base}/game`)),
    remove(ref(db, `${base}/decks`)),
    remove(ref(db, `${base}/discard`)),
    remove(ref(db, `${base}/events`)),
    remove(ref(db, `${base}/votes`)),
    remove(ref(db, `${base}/gameStarted`)),
  ]);

  resetLocalGameEffects();
  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
});

/* =========================
   Join（既存）
   ========================= */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeRoles();
  subscribeGame();
  subscribeEvents();

  syncSeatUI();

  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});


</script>

</body>
</html>
