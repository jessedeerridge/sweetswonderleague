<!DOCTYPE html>    
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn:disabled{opacity:.45; cursor:not-allowed;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

/* ★ プレイヤー円配置用（拡大：直径だいたい400前後） */
.player-circle{
  position:relative;
  width:min(360px, 92vw);
  height:min(420px, 92vw);
  margin:20px auto 0;
  border-radius:50%;
  box-sizing:border-box;
  border:none;
}



  /* ★ 中央：プレイサークル（※スイーツ山札クリックのため pointer-events を有効に） */
  .play-circle{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:86px;height:86px;border-radius:50%;
    border:2px dashed rgba(0,0,0,.35);
    background:rgba(255,255,255,.20);
    box-shadow:0 8px 20px rgba(0,0,0,.12) inset;
    pointer-events:auto;
  }
  .play-circle::after{
    content:'PLAY';
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    font-weight:900;font-size:12px;letter-spacing:.08em;opacity:.65;
    pointer-events:none;
  }
  .play-circle.hint-ok{border-style:solid; border-color:rgba(34,197,94,.65);}
  .play-circle.hint-ng{border-color:rgba(239,68,68,.65);}
  .play-circle.roundpick-target{
    border-style:solid;
    border-color:rgba(59,130,246,.8);
    background:rgba(59,130,246,.12);
  }

  /* =========================
     ★★ 中央：アクション山札（左）＋スイーツ山札（右）
     ========================= */
  .center-decks{
    position:absolute;
    left:50%; top:50%;
  transform:translate(-50%,-50%) translateY(60px); /* ← ここを増やすほど下がる */
    display:flex;
    gap:14px;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }
  .center-decks.hidden{display:none;}

  /* アクション山札（見た目専用） */
  .action-deck{
    position:relative;
    width:28px; height:40px;
    pointer-events:none;
  }
  .action-deck.hidden{display:none;}
  .action-deck .stack{position:absolute; inset:0;}
  .action-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swactionura.jpg') center/cover no-repeat;
    box-shadow:none;
  }
  .action-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
  .action-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
  .action-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
  .action-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
  .action-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
  }

  /* スイーツ山札（クリック可能） */
 .sweets-deck{
    position:relative;
    width:28px; height:40px;
    pointer-events:auto;
    cursor:pointer;
    user-select:none;
    touch-action:none;
  }
  .sweets-deck-wrap{
    position:relative;
    width:28px;
    height:40px;
  }
  .sweets-deck-wrap .sweets-deck{
    position:absolute;
    inset:0;
  }
  .sweets-deck.hidden{display:none;}
  .sweets-deck .stack{position:absolute; inset:0;}
  .sweets-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:none;
  }
  .sweets-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
  .sweets-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
  .sweets-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
  .sweets-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
  .sweets-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
   line-height:1.1;
    pointer-events:none;
  }
  .sweets-exclude-deck{
    position:absolute;
    right:-43px;
    top:0px;
    width:28px;
    height:40px;
    pointer-events:none;
    user-select:none;
  }
  .sweets-exclude-deck.hidden{display:none;}
  .sweets-exclude-deck .stack{position:absolute; inset:0;}
  .sweets-exclude-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:none;
    transform:rotate(90deg);
    transform-origin:center;
  }
  .sweets-exclude-deck .card.c2{ transform:translate(1px,-1px) rotate(90deg); opacity:.95; }
  .sweets-exclude-deck .card.c3{ transform:translate(2px,-2px) rotate(90deg); opacity:.90; }
  .sweets-exclude-deck .card.c4{ transform:translate(3px,-3px) rotate(90deg); opacity:.86; }
  .sweets-exclude-deck .card.c5{ transform:translate(4px,-4px) rotate(90deg); opacity:.82; }
  .sweets-exclude-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
    pointer-events:none;
  }
/* 除外札全体を少し薄く */
#sweetsExcludedDeckUI{
  opacity: .50;   /* 好みで調整 */
}

/* ✅ 除外デッキ：出現を「傾き＋フェード」で */
.sweets-exclude-deck{
  /* ふわっと出すための基準状態 */
  opacity: 1;
  visibility: visible;
  transform: translateX(0px) rotate(0deg) scale(1);
  will-change: opacity, transform;
  transition:
    opacity .22s ease,
    transform .22s cubic-bezier(.22,.84,.44,1),
    visibility 0s linear 0s;
}

/* ✅ 重要：.hidden を display:none にさせず、アニメ可能な隠し方に上書き */
.sweets-exclude-deck.hidden{
  display: block;                 /* ← これが肝。display:none を殺す */
  opacity: 0;
  visibility: hidden;
  transform: translateX(10px) rotate(-25deg) scale(.85); /* ← “傾く”の正体 */
  transition:
    opacity .18s ease,
    transform .18s ease,
    visibility 0s linear .18s;    /* ← フェード後に不可視へ */
}


  /* ★ 自分のターンだけ「大小アニメ（鼓動）」 */
  @keyframes pulseCard {
    0%{transform:scale(1);}
    50%{transform:scale(1.06);}
    100%{transform:scale(1);}
  }
 @keyframes pulseCardStrong {
    0%{transform:scale(1);}
    50%{transform:scale(1.12);}
    100%{transform:scale(1);}
  }
  .sweets-move-card{
    position:fixed;
    left:0;
    top:0;
    width:28px;
    height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.2);
    z-index:620;
    pointer-events:none;
    will-change:transform;
  }

  @keyframes sweetsDecidedMove {
    from{transform:translateY(0);}
    to{transform:translateY(-60px);}
  }
  @keyframes sweetsTagMove {
    from{transform:translate(-50%,0);}
    to{transform:translate(-50%, var(--sweetsTagMoveY));}
  }
  @keyframes sweetsDecidedMoveMy {
    from{transform:translateY(0);}
    to{transform:translateY(-30px);}
  }
/* ✅ スイーツ山札専用：鼓動（例：強め） */
@keyframes pulseSweetsDeck {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.4); } /* ← 強さ（例：1.06〜1.14） */
  100% { transform: scale(1); }
}
  .sweets-deck.pulsing{ animation:pulseSweetsDeck 1.05s ease-in-out infinite; }
  .sweets-deck.pulsing:hover{ animation:none; transform:scale(1.14); }

  /* ★★ 他プレイヤー：ネームタグ＋カード周りを円で囲む（otherplayerscircle） */
  .otherplayerscircle{
    position:absolute;
    left:0; top:0;
    width:126px; height:126px;
    transform:translate(-50%,-50%);
    border-radius:50%;
    border:2px solid rgba(0,0,0,.22);
    background:rgba(255,255,255,.10);
    display:flex;align-items:center;justify-content:center;
    box-sizing:border-box;
  }
  .otherplayerscircle.hint-ok{ border-color:rgba(34,197,94,.75); }
  .otherplayerscircle.hint-ng{ border-color:rgba(239,68,68,.75); }

  /* ★★ 重要：手番の青枠は「サークル」には付けない（無効化） */
  .otherplayerscircle.active-turn{
    outline:none !important;
    outline-offset:0 !important;
  }

  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    display:flex;align-items:center;gap:6px;
  }
  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  /* ★ 手番の青枠：ネームタグ輪郭の外側 */
  .player-tag.active-turn{
    outline:3px solid rgba(59,130,246,.65);
    outline-offset:3px;
  }

  /* otherplayerscircle 内のタグは「中央配置」扱い */
  .player-tag.in-othercircle{
    position:relative;
    transform:none;
    left:auto; top:auto;
  }

/* ★ リーダーチップ（1.2倍） */
.leader-chip{
  position:absolute;
  right:-22px;
  top:50%;
  width:21.6px;
  height:21.6px;
  transform:translateY(-50%);
  background:url('swleader.png') center/contain no-repeat;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.35));
  pointer-events:none;
}


  /* 他プレイヤー：正体カード（裏） */
/* 他プレイヤー：正体カード（裏） */
.role-mini{
  position:absolute;
  left:-34px; top:50%;
  transform:translateY(-50%);
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swroleura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  pointer-events:none;
}


  /* ★★ 他プレイヤー：ミニスイーツ（裏）＋周りを円で囲む＝swarea */
/* 他プレイヤー：スイーツ枠（山札と同サイズ） */
.sweets-area{
  position:absolute;
  left:-66px; top:50%;
  transform:translateY(-50%);
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:2px solid rgba(0,0,0,.22);
  background:rgba(255,255,255,.10);
  display:flex;
  align-items:center;
  justify-content:center;
  box-sizing:border-box;
  pointer-events:auto;
}
.sweets-area.empty{
  border-style:dashed;
  opacity:.35;
}
.sweets-area.hint-ok{ border-color:rgba(34,197,94,.75); }
.sweets-area.hint-ng{ border-color:rgba(239,68,68,.75); }

.sweets-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swsweetsura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}
.sweets-mini.hidden{display:none;}

/* 投票チップ（他プレイヤーのスイーツ右側に重ねる） */
.vote-stack{
  position:absolute;
  right:-22px;
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-wrap:wrap;

  width:calc(var(--voteMiniSize) * 2 + 6px); /* 2列 */
  gap:3px;
  justify-content:flex-start;
  align-items:center;
  pointer-events:none;
}

.vote-mini{
  width:var(--voteMiniSize);
  height:var(--voteMiniSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 6px 14px rgba(0,0,0,.18);
}


  /* 他プレイヤーのミニカード（ネームタグの下に扇状） */
  .player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:60px;height:30px;pointer-events:none;
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:url('swactionura.jpg') center/cover no-repeat;
  transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }
  .player-tag .other-vote-chip{
    position:absolute;
    left:50%;
    top:100%;
    transform:translate(12px,15px);
    width:var(--voteMiniSize);
    height:var(--voteMiniSize);
    border-radius:50%;
    border:2px solid var(--voteChipStroke);
    background:var(--voteChipFill);
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    pointer-events:none;
  }
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    pointer-events:none;
  }
  .player-tag .other-vote-chip.is-empty{
    opacity:0;
  }
  .player-tag .other-vote-chip.is-flying{
    opacity:0;
  }
  .vote-chip-fly{
    position:fixed;
    left:0;
    top:0;
    width:var(--voteMiniSize);
    height:var(--voteMiniSize);
    border-radius:50%;
    border:2px solid var(--voteChipStroke);
    background:var(--voteChipFill);
    box-shadow:0 12px 28px rgba(0,0,0,.25);
    pointer-events:none;
    z-index:999;
    will-change:transform;
  }
.vote-stack{
  --voteStackSize: var(--voteMiniSize);
  min-height: var(--voteStackSize);
}

  /* 自分の手札表示（大きめ横並び） */
  .my-hand-wrapper{margin-top:16px;text-align:center; position:relative;}
  .my-hand-title{display:none;}
  .my-area{
    display:flex;gap:10px;justify-content:center;align-items:flex-start;
    margin-top:-20px;
  }

  /* ★ 自分の正体カード（自分のアクションカードの左側） */
  .my-role{
    width:78px;height:118px;border-radius:12px;border:1px solid #ddd;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    background:#fff;
    overflow:hidden;
    flex:0 0 auto;
  }
  .my-role img{width:100%;height:100%;object-fit:cover;display:block;}

  /* ★★ 自分のスイーツ（正体カードの左／同サイズ） */
  .my-sweets{
    width:78px;height:118px;border-radius:12px;border:1px solid #ddd;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    background:#fff;
  overflow:visible;  
    flex:0 0 auto;
  }
  .my-sweets.hidden{display:none;}
  .my-sweets img{width:100%;height:100%;object-fit:cover;display:block;
}

  /* =========================
     ★ 受け取った指示カードスロット（正体カードの左）
     ========================= */
  .my-received-slot{
    flex:0 0 auto;
    display:flex;align-items:flex-start;justify-content:center;
  }

  .my-hand{
    display:flex;justify-content:center;gap:10px;flex-wrap:wrap;
    min-height:130px;
  }

  /* ★ アクションカード（自分の手札） */
  .action-card{
    position:relative;
    width:90px;height:135px;border-radius:12px;border:1px solid #ddd;background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    overflow:hidden;
    user-select:none;
    touch-action:none;
    cursor:grab;
    transform-origin:center;
  }
  .action-card:active{cursor:grabbing;}
  .action-card img.card-img{
    position:absolute;inset:0;width:100%;height:100%;object-fit:cover;
    display:block;
  }
  .action-card .card-name{
    position:absolute;left:8px;top:6px;
    font-weight:900;font-size:14px;
    color:#1d4ed8;
    text-shadow:0 2px 6px rgba(255,255,255,.7);
    pointer-events:none;
  }

  .action-card .effect-frame{
    position:absolute;left:0;right:0;bottom:0;height:50%;
    background:rgba(255,255,255,.55);
    border-top:1px solid rgba(0,0,0,.15);
    padding:8px 8px 8px;
    display:flex;align-items:flex-start;justify-content:flex-start;
    box-sizing:border-box;
    pointer-events:none;
  }
  .action-card .effect-text{
    width:100%;
    font-weight:800;
    line-height:1.25;
    color:#111;
    font-size:13px;
    overflow:hidden;
    display:-webkit-box;
    -webkit-line-clamp:6;
    -webkit-box-orient:vertical;
  }

  .my-turn-free .action-card{ animation:pulseCard 1.05s ease-in-out infinite; }
  .my-turn-free .action-card:hover{ animation:none; transform:scale(1.08); }

  /* ★ 受け取り指示カードがある間：通常手札は無効＆アニメ停止 */
  .my-turn-blocked .my-hand .action-card{
    animation:none !important;
    cursor:not-allowed;
    filter:grayscale(.25);
    opacity:.72;
  }

  /* ★ 指示カードスロット内のカードだけ鼓動させる */
  .my-turn-blocked .my-received-slot .action-card.pulse-only{
    animation:pulseCard 1.05s ease-in-out infinite;
    cursor:grab;
    filter:none;
    opacity:1;
  }
  .my-turn-blocked .my-received-slot .action-card.pulse-only:hover{
    animation:none;
    transform:scale(1.08);
  }

  /* ★ 無視カード：ブロック中でも鼓動＆使用可（手札内） */
  .my-turn-blocked .my-hand .action-card.can-ignore{
    animation:pulseCard 1.05s ease-in-out infinite !important;
    cursor:grab !important;
    filter:none !important;
    opacity:1 !important;
  }
  .my-turn-blocked .my-hand .action-card.can-ignore:hover{
    animation:none !important;
    transform:scale(1.08);
  }

  /* ★ ドラッグ中の見た目 */
  .dragging{
    position:fixed !important;
    z-index:9999 !important;
    margin:0 !important;
    animation:none !important;
    pointer-events:none;
  }

  /* ★ 追い出し確認ダイアログ */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン（右下固定） */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* ★ 設定ポップ（ホスト専用パネル） */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  /* 詳細情報消す用 */
  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  /* =========================
     ★ 左下「？」ボタン
     ========================= */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  /* ★ ヘルプ一覧ポップ */
  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
  }
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
    overflow:hidden;
  }
  .role-card img{width:100%;height:100%;object-fit:cover;display:block;}
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  /* =========================
     ★ ターン操作バー
     ========================= */
  .turn-bar{
    position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
    z-index:228;
    display:flex; gap:8px; align-items:center; justify-content:center;
    background:rgba(255,255,255,.85);
    border:1px solid #ddd;
    border-radius:999px;
    padding:6px 10px;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    backdrop-filter: blur(6px);
  }
  .turn-bar.hidden{display:none;}
  .turn-badge{
    font-size:12px;font-weight:900;opacity:.85;
    padding:4px 8px;border-radius:999px;border:1px solid #ddd;background:#fff;
  }

  /* =========================
     ★ 全員に見せる「中央拡大」(1秒)
     ========================= */
  .reveal-overlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:500;
  }
  .reveal-overlay.hidden{display:none;}
  .reveal-card{
    width:min(260px, 78vw);
    aspect-ratio: 2 / 3;
    border-radius:18px;
    border:none;
    box-shadow:none;
 background:transparent;
    overflow:hidden;
    position:relative;
  }
  .reveal-card img{width:100%;height:100%;object-fit:cover;display:block;border:none;background:transparent;}
  .reveal-card .label{
    position:absolute; left:10px; top:10px;
    font-weight:900; color:#1d4ed8;
    text-shadow:0 2px 10px rgba(255,255,255,.75);
  }

  /* ★ 指示カード移動アニメ用（小さい裏カード） */
 .fly-card{
    position:fixed;
    width:22px;height:32px;border-radius:6px;
    border:1px solid rgba(0,0,0,.2);
    background:url('swactionura.jpg') center/cover no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.25);
    z-index:520;
    pointer-events:none;
  }
  .sweets-fly-card{
    position:fixed;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 10px 24px rgba(0,0,0,.22);
    background:#fff;
    overflow:hidden;
    z-index:540;
    pointer-events:none;
    transform-origin:top left;
  }
  .sweets-fly-card img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }


  /* ★ 自分の手札サイズ統一（60x90） */
  :root{
    --myCardW: 60px;
    --myCardH: 90px;
    --myCardR: 10px;
  }
  .my-role{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }
  .action-card{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }
  .my-sweets{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }

  /* =========================
     ★ スイーツ一覧（ローカル表示）
     ========================= */
  .sweets-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; flex-direction:column;
    align-items:center; justify-content:flex-start;
    z-index:560;
    padding:16px;
    gap:12px;
    overflow:auto;
  }
  .sweets-backdrop.hidden{display:none;}
  .sweets-panel{
    width:min(760px, calc(100% - 32px));
    background:#fff;
    border:1px solid #ddd;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
    position:sticky;
    top:140px;
  }
  .sweets-panel-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .sweets-panel-title{
    font-weight:900;font-size:14px;
  }
  .sweets-panel-body{
    padding:12px;
    overflow:auto;
    max-height:min(70vh, 640px);
  }
  .sweets-grid{
    display:grid;
    gap:10px;
    justify-content:center;
    align-content:center;
  }
  .sweets-pick-card{
    width:90px; height:135px;
    border-radius:12px;
    border:1px solid #ddd;
    background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    overflow:hidden;
    position:relative;
    cursor:grab;
    user-select:none;
    touch-action:none;
    animation:pulseCardStrong 1.05s ease-in-out infinite;
    transform-origin:center;
  }
  .sweets-pick-card:active{cursor:grabbing;}
  .sweets-pick-card:hover{ animation:none; transform:scale(1.12); }
  .sweets-pick-card img{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    display:block;
  }

  /* ★ スイーツドラッグ中の見た目 */
 .sweets-dragging{
    position:fixed !important;
    z-index:99999 !important;
    pointer-events:none;
    animation:none !important;
  }
  .sweets-drop-zone{
    width:min(800px, calc(100% - 32px));
    min-height:200px;
    border:transparent;
    border-radius:14px;
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:transparent;
    text-align:center;
    padding:8px 12px;
    margin-top:130px;
  }
  .sweets-drop-zone.active{
    border-color:transparent;
    color:transparent;
    background:transparent;
  }

  /* =========================
     ★ 投票チップ（自分の手元：全カードの右側）
     ========================= */
/* 投票チップ（自分の手元：全カードの右側） */
.vote-chip{
  width:var(--voteChipSize);
  height:var(--voteChipSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 10px 24px rgba(0,0,0,.18);
  flex:0 0 auto;
  align-self:flex-start;
  cursor:grab;
  user-select:none;
  touch-action:none;
  position:relative;
  transition:transform .2s ease;
}
/* ✅ 投票チップ専用：鼓動を弱める */
@keyframes pulseVoteChip {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.5); } /* ← ここが強さ（例：1.04〜1.10） */
  100% { transform: scale(1); }
}

.vote-chip.hidden{display:none;}
.vote-chip:active{cursor:grabbing;}
.vote-chip.pulsing{ animation:pulseVoteChip 1.05s ease-in-out infinite; }
.vote-chip.pulsing:hover{ animation:none; transform:scale(1.10); } /* ← hover拡大も投票専用に調整 */


/* 既存の「V」文字は消す（デザイン統一） */
.vote-chip::after{ content:''; }


  .vote-dragging{
    position:fixed !important;
    z-index:999999 !important;
    pointer-events:none;
    animation:none !important;
  }

  .roundpick-dragging{
    position:fixed !important;
    z-index:999999 !important;
    pointer-events:none;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.35);
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    background:#fff center/cover no-repeat;
  }



  /* =========================
     ★★★ ここから PASS & ラウンド終了演出 ★★★
     ========================= */

  /* 右下：丸いPASSボタン（紫・白字） */
  .pass-round-btn{
    position:fixed;
    right:16px;
    bottom:16px;
    width:64px;
    height:64px;
    border-radius:50%;
    border:1px solid rgba(255,255,255,.25);
    background:#7c3aed;           /* 紫 */
    color:#fff;
    font-weight:900;
    letter-spacing:.06em;
    box-shadow:0 14px 34px rgba(0,0,0,.25);
    cursor:pointer;
    z-index:235;                  /* hostSettingsBtnより上でもOK */
    display:none;
    user-select:none;
  }
  .pass-round-btn.visible{display:grid; place-items:center;}
  .pass-round-btn:active{transform:scale(.98);}
  .pass-round-btn:disabled{opacity:.5; cursor:not-allowed; transform:none;}

  /* 収集アニメ用：中央に集まる裏カード */
  .collect-card{
    position:fixed;
    width:90px;
    height:135px;
    border-radius:7px;
    border:1px solid rgba(255,255,255,.25);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    z-index:610;
    pointer-events:none;
    transform-origin:center;
  }

  /* 最終公開（複数） */
  .roundreveal-overlay{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);
    background:transparent;
    z-index:620;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:6px;
    pointer-events:none;
  }
  .roundreveal-overlay.hidden{display:none;}
  .roundreveal-row{
    display:flex;
    gap:30px;
    align-items:center;
    justify-content:center;
    flex-wrap:nowrap;          /* 折り返しなし */
    overflow:auto;
    padding:6px;
  }
  .roundreveal-card{
    width:min(240px, 32vw);
    aspect-ratio:2/3;
    border-radius:18px;
    border:none;
    box-shadow:none;
    background:transparent;
    overflow:hidden;
    flex:0 0 auto;
    transform:scale(1.02);
  }
  .roundreveal-card img{width:100%;height:100%;object-fit:cover;display:block;}

:root{
  --deckCardW: 28px;
  --deckCardH: 40px;
  --deckCardR: 7px;

  /* 投票チップ（自分/他人 共通） */
  /* 自分（ドラッグ用） */
  --voteChipSize: 22px;

  /* 他プレイヤーに乗る小さいやつ */
  --voteMiniSize: 14px;

  --voteChipFill: rgba(196, 181, 253, .92);
  --voteChipStroke: rgba(255,255,255,.95);
}

/* =========================
   ★★ 他プレイヤー：内側に「正体＋スイーツ」横並び（平行）
   - JSから --inX/--inY/--rotDeg を渡す
   ========================= */
.otherplayerscircle{ --inX:0px; --inY:0px; --outX:0px; --outY:0px; --rotDeg:0deg; }

/* タグ（外側へ） */
.player-tag.in-othercircle{
  position:absolute;
  left:50%; top:50%;
  transform:translate(-50%,-50%) translate(var(--outX), var(--outY));
}

/* 内側カード列（回転して「上が中心を向く」） */
.other-cards-row{
  position:absolute;
  left:50%; top:50%;
  transform:
    translate(-50%,-50%)
    translate(var(--inX), var(--inY))
    rotate(var(--rotDeg));
  display:flex;
  gap:8px;
  align-items:center;
  justify-content:center;
  pointer-events:none; /* 見た目専用（投票などにしたいなら外す） */
}

/* 正体ミニ（裏） */
.role-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swroleura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}

/* スイーツ枠（裏カード＋投票チップ重ね） */
.sweets-wrap{
  position:relative;
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:2px solid rgba(0,0,0,.22);
  background:rgba(255,255,255,.10);
  box-sizing:border-box;
  display:flex; align-items:center; justify-content:center;
  transition:transform .6s ease;
  --decidedMoveX: 0px;
  --decidedMoveY: 0px;
}

.sweets-wrap.empty{
  border-style:dashed;
  opacity:.35;
}
.sweets-wrap.hint-ok{ border-color:rgba(34,197,94,.75); }
.sweets-wrap.hint-ng{ border-color:rgba(239,68,68,.75); }
.sweets-wrap.roundpick-candidate{
  animation:pulseSweetsDeck 1.05s ease-in-out infinite;
}
.sweets-wrap.roundpick-selectable{
  cursor:pointer;
}
.sweets-wrap.roundpick-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
.sweets-wrap.decided-move{
  transform:translate(var(--decidedMoveX), var(--decidedMoveY));
}
.sweets-wrap.decided-move.decided-static{
  transition:none;
}
.sweets-wrap.center-move-host{
  border-color:transparent;
  background:transparent;
}
.sweets-wrap.collect-hidden{
  border-color:transparent;
  background:transparent;
}
.sweets-wrap.collect-hidden .sweets-mini{
  opacity:0;
}

.sweets-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swsweetsura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  --centerMoveX: 0px;
  --centerMoveY: 0px;
}
.sweets-mini.hidden{display:none;}
.sweets-mini.center-move{
  transition:transform .6s ease;
  transform:translate(var(--centerMoveX), var(--centerMoveY));
}
.sweets-mini.center-move.center-static{
  transition:none;
}

.my-sweets.roundpick-candidate{
  animation:pulseCardStrong 1.05s ease-in-out infinite;
}
.my-sweets.roundpick-selectable{
  cursor:pointer;
}
.my-sweets.roundpick-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
.my-sweets.roundpick-selectable:hover ~ .vote-chip,
.my-sweets.roundpick-selectable:active ~ .vote-chip{
  transform:scale(1.12);
}
.my-sweets.decided-move{
  transform:translateY(-30px);
  animation:sweetsDecidedMoveMy .6s ease;
}

/* 投票チップ（スイーツの右側に重ねる） */
.vote-stack{
  position:absolute;
  right:-22px;
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-wrap:wrap;
  width:calc(var(--voteMiniSize) * 2 + 6px); /* 2列 */
  gap:3px;
  justify-content:flex-start;
  align-items:center;
  pointer-events:none;
}

.selected-sweets-tag{
  position:absolute;
  left:50%;
  bottom:100%;
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  overflow:visible;
  --sweetsTagMoveY:-30px;
  transform:translate(-50%, var(--sweetsTagMoveY));
  animation:sweetsTagMove .6s ease;
  pointer-events:none;
}
.selected-sweets-tag.delayed-show{
  opacity:0;
  visibility:hidden;
}
.selected-sweets-tag.decided-static{
  animation:none;
}



.selected-sweets-tag.collect-hidden .selected-sweets-card{
  border-color:transparent;
  background:transparent;
  box-shadow:none;
}
.selected-sweets-tag.collect-hidden img{
  opacity:0;
}
.selected-sweets-tag.collect-hidden .sweets-number-tag{
  opacity:0;
}
.selected-sweets-card{
  position:relative;
  width:100%;
  height:100%;
  border-radius:inherit;
  border:1px solid rgba(0,0,0,.18);
  background:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  --centerMoveX: 0px;
  --centerMoveY: 0px;
}
.selected-sweets-card.center-move{
  transition:transform .6s ease;
  transform:translate(var(--centerMoveX), var(--centerMoveY));
}
.selected-sweets-card.center-move.center-static{
  transition:none;
}
.selected-sweets-card img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
  border-radius:inherit;

}
.selected-sweets-card .sweets-number-tag{
  position:absolute;
  right:9px;
  top:-12px;

  /* 少し大きくして余裕を作る */
  width:34px;
  height:34px;

  display:grid;
  place-items:center;

  font-weight:900;
  font-size:13px;
  line-height:1;
  color:#111;

  text-shadow:0 1px 0 rgba(255,255,255,.6);
}
.selected-sweets-card .sweets-number-star{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:0;
  pointer-events:none;
}
.selected-sweets-card .sweets-number-text{
  position:relative;
  z-index:1;
  transform:translateZ(0) translateY(-1px);
}


/* ★ 修正：otherplayerscircle内の横並び用 role-mini を “絶対配置” から解除し、サイズ計算も統一 */
.other-cards-row .role-mini{
  position:relative;      /* ← absoluteを殺す */
  left:auto;
  top:auto;
  transform:none;         /* ← translateY(-50%)を殺す */
  box-sizing:border-box;  /* ← border込みで28x40にする */
}

/* 念のため：他の場所で role-mini を絶対配置したいなら、そっちはスコープを付ける */


/* 下の手番バーだけ消して、右下PASSは残す */
#turnBar{
  display:none !important;
}
/* 投票ドロップのため：内側カード列はポインターを通す */
.other-cards-row{ pointer-events:auto; }

/* ドロップ判定したいのはスイーツ枠なので、ここも明示しておく */
.sweets-wrap{ pointer-events:auto; }

/* ★ 他プレイヤー：スイーツ未獲得の間は正体カードだけ中央表示 */
.other-cards-row.solo{
  justify-content:center;
}
.other-cards-row.solo .role-mini{
  margin:0;
}
/* solo時は投票やスイーツ枠が無い前提だが、念のため */
.other-cards-row.solo .sweets-wrap,
.other-cards-row.solo .vote-stack{
  display:none !important;
}

/* 自分のスイーツにも投票ミニを重ねるため */
.my-sweets{ position:relative; }

/* 自分スイーツ上の投票（右に重ね） */
.my-sweets .vote-stack{
  right:-22px;                 /* 少しだけ内側に寄せる（好みで調整OK） */
  top:10%;
  transform:translateY(-50%);
  --voteStackSize: var(--voteChipSize);
}
/* ★ 自分のスイーツ上の投票チップだけ「手元チップと同サイズ」にする */
.my-sweets .vote-stack{
  width:calc(var(--voteChipSize) * 2 + 6px); /* 2列レイアウトも同サイズ基準に */
}

.my-sweets .vote-stack .vote-mini{
  width:var(--voteChipSize);
  height:var(--voteChipSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 10px 24px rgba(0,0,0,.18);
}

/* =========================
   ★★ 選抜スイーツ：回収→シャッフル（中央）
   ========================= */
.sweets-shuffle-stage{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:160px;
  height:220px;
  z-index:615;
  pointer-events:none;
}
.sweets-shuffle-card{
  position:absolute;
  left:50%;
  top:50%;
  width:120px;
  height:170px;
  transform:translate(-50%,-50%);
  border-radius:12px;
  border:1px solid rgba(255,255,255,.25);
  box-shadow:0 16px 44px rgba(0,0,0,.35);
  background:center/cover no-repeat;
  will-change:transform, opacity;
}

/* =========================
   ★ 中央：リーダーボード（長方形 5:3.3）
   ========================= */
.leaderboard-board{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:min(120px, 78vw);
  aspect-ratio: 5 / 3.3;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.18);
  background:rgba(255,255,255,.18);
  box-shadow:0 10px 24px rgba(0,0,0,.12);
  overflow:hidden;
  pointer-events:none;
  z-index:4; /* play-circleより下/上は好みで */
}
.leaderboard-board.hidden{display:none;}
.leaderboard-board img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

/* play-circle を前面に（中央ボードの上に乗せる） */
.play-circle{ z-index:6; }
/* ✅ leaderboardより前面に出したいUIのレイヤーを上げる */
.otherplayerscircle{ z-index: 7; }   /* 他プレイヤーの円ごと前へ */
.player-tag{ z-index: 8; }          /* ネームタグ前へ */
.other-cards-row{ z-index: 8; }     /* 内側カード列も前へ */

/* 選抜スイーツ表示（selected card）をさらに前へ */
.selected-sweets-tag{ z-index: 9; }

/* チップ系も前へ（投票チップ/投票スタック） */
.vote-chip{ z-index: 9; }           /* 自分の投票チップ（念のため） */
.vote-stack{ z-index: 9; }          /* 付随する投票チップ群 */

/* ※ leaderboardは現状のままでもOK（z-index:4） */

/* =========================
   ★ 中央：ラウンドチップ枠（3つ横並び）
   - z-indexに頼らず、DOM順で前面化（leaderboardの後ろに置く）
   ========================= */
.round-chips{
  position:absolute;
  left:50%;
top:calc(50% - 6.5px);  
  transform:translate(-50%,-50%);
  display:flex;
  gap:9.6px;
  align-items:center;
  justify-content:center;
  pointer-events:none; /* クリック不要なら none（必要になったらautoに） */
}

.round-chip-slot{
  width:18.5px;
  height:18.5px;
  border-radius:50%;
  border:2px dashed rgba(0,0,0,.35);
  background:rgba(255,255,255,.20);
  box-shadow:0 6px 14px rgba(0,0,0,.10) inset;
  position:relative;
  overflow:hidden;
}

.round-chip-slot::after{
  /* 今は目印（後で消してOK） */
  content: attr(data-round);
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  font-weight:900;
  font-size:10px;
  opacity:.55;
}

.round-chip-img{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

.round-chip-img.hidden{ display:none; }



</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">

  <!-- ★ 中央：リーダーボード（人数で画像切替） -->
<div id="leaderboardBoard" class="leaderboard-board hidden" aria-hidden="true">
  <img id="leaderboardImg" alt="leaderboard" />

  <!-- ★ 中央：ラウンドチップ枠（R1/R2/R3）※leaderboardより後に置く＝前面に描画される -->
  <div id="roundChips" class="round-chips" aria-label="ラウンドチップ">
    <div class="round-chip-slot" data-round="1" aria-label="ラウンド1">
      <img class="round-chip-img hidden" alt="round1" />
    </div>
    <div class="round-chip-slot" data-round="2" aria-label="ラウンド2">
      <img class="round-chip-img hidden" alt="round2" />
    </div>
    <div class="round-chip-slot" data-round="3" aria-label="ラウンド3">
      <img class="round-chip-img hidden" alt="round3" />
    </div>
  </div>
</div>


      <div id="playCircle" class="play-circle">
        <!-- ★ 中央：アクション山札（左）＋スイーツ山札（右） -->
        <div id="centerDecks" class="center-decks hidden" aria-hidden="false">
          <div id="actionDeckUI" class="action-deck hidden" aria-hidden="true">
            <div class="stack" aria-hidden="true">
              <div class="card c5"></div>
              <div class="card c4"></div>
              <div class="card c3"></div>
              <div class="card c2"></div>
              <div class="card c1"></div>
            </div>
            <div id="actionDeckCount" class="count">0</div>
          </div>

         <div class="sweets-deck-wrap">
            <div id="sweetsDeckUI" class="sweets-deck hidden" aria-label="スイーツ山札">
              <div class="stack" aria-hidden="true">
                <div class="card c5"></div>
                <div class="card c4"></div>
                <div class="card c3"></div>
                <div class="card c2"></div>
                <div class="card c1"></div>
              </div>
              <div id="sweetsDeckCount" class="count">0</div>
            </div>
            <div id="sweetsExcludedDeckUI" class="sweets-exclude-deck hidden" aria-label="スイーツ除外山札">
              <div class="stack" aria-hidden="true">
                <div class="card c5"></div>
                <div class="card c4"></div>
                <div class="card c3"></div>
                <div class="card c2"></div>
                <div class="card c1"></div>
              </div>
              <div id="sweetsExcludedDeckCount" class="count">0</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>

      <!-- ★ ownarea -->
      <div class="my-area" id="myArea">
        <!-- ★ 受け取った指示カード（正体カードの左） -->
        <div id="myReceived" class="my-received-slot"></div>

        <!-- ★ 自分のスイーツ（正体カードの左・同サイズ） -->
        <div id="mySweets" class="my-sweets hidden"></div>

        <div id="myRole" class="my-role hidden"></div>
        <div id="myHand" class="my-hand"></div>

        <!-- ★ 投票チップ（全所有カードより右） -->
        <div id="myVoteChip" class="vote-chip hidden" aria-label="投票チップ"></div>
      </div>
    </div>
  </div>
</main>

<!-- ★ 参加者：ホスト人数選択中ポップ -->
<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<!-- 着席ポップ -->
<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<!-- 既存プレイヤー追い出し確認ポップ -->
<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<!-- ホスト専用 設定ボタン（⚙） -->
<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<!-- ★ ヘルプボタン（？） -->
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<!-- ★ ヘルプ一覧ポップ -->
<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<!-- 設定ポップ（スタート＋リセット） -->
<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で正体カード＋アクションカード配布＋手番決定。<br>
    「リセット」で人数選択へ戻します（内容は後で）。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ★ ターン操作バー（既存） -->
<div id="turnBar" class="turn-bar hidden">
  <span id="turnBadge" class="turn-badge">TURN</span>
  <button id="btnPass" class="btn">パス</button>
  <button id="btnDrawSweets" class="btn" disabled>スイーツドロー（後で）</button>
  <button id="btnVote" class="btn" disabled>投票（後で）</button>
</div>

<!-- ★ 右下：丸いPASSボタン（ラウンド用） -->
<button id="passRoundBtn" class="pass-round-btn" type="button" aria-label="PASS">PASS</button>

<!-- ★ 中央拡大表示（全員、1秒） -->
<div id="revealOverlay" class="reveal-overlay hidden">
  <div class="reveal-card">
    <img id="revealImg" alt="" />
    <div id="revealLabel" class="label"></div>
  </div>
</div>

<!-- ★ スイーツ一覧（ローカル表示） -->
<div id="sweetsBackdrop" class="sweets-backdrop hidden">
  <div class="sweets-panel" role="dialog" aria-modal="true" aria-label="スイーツ一覧">
    <div class="sweets-panel-header">
      <div class="sweets-panel-title">スイーツ（下の獲得エリアにドラッグ）</div>
      <button id="btnSweetsClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="sweets-panel-body">
      <div id="sweetsGrid" class="sweets-grid"></div>
    </div>
  </div>
  <div id="sweetsDropZone" class="sweets-drop-zone" aria-label="スイーツ獲得エリア">
    ここにカードを出すと獲得
  </div>
</div>

<!-- ★ ラウンド終了：公開（複数） -->
<div id="roundRevealOverlay" class="roundreveal-overlay hidden" aria-hidden="true">
  <div id="roundRevealRow" class="roundreveal-row"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove,
  push, onChildAdded, serverTimestamp
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* =========================
   Firebase
   ========================= */
const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};
const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

// ★ userId をタブ単位で固定（タブごとに別ID）
const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

/* =========================
   状態
   ========================= */
const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  turnEnding: false,
  passReadyBlockedTurnNo: null,
  lastPassEligible: false,
  prevTurnNo: null,

  room: {},
  hands: {},
  roles: {},
  game: {},
  turn: null,
};
let latestPlayers = [];
const collectedSweetsHidden = new Set();
let miniShuffleRunning = false;
let miniShuffleToken = 0;
let sweetsExcludeAnimating = false;
let sweetsDeckCountOverride = null;
let sweetsExcludedCountOverride = null;
let sweetsOverrideClearTimer = null;
let currentGameSessionId = null;
let eventsSubscribedAt = 0;
let turnBlockedByShuffle = false;
/* =========================
   DOM
   ========================= */
const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const playCircleEl = document.getElementById('playCircle');
const myHandEl = document.getElementById('myHand');
const myRoleEl = document.getElementById('myRole');
const myReceivedEl = document.getElementById('myReceived');
const mySweetsEl = document.getElementById('mySweets');
const myAreaEl = document.getElementById('myArea');
const myVoteChipEl = document.getElementById('myVoteChip');
const leaderboardBoardEl = document.getElementById('leaderboardBoard');
const leaderboardImgEl   = document.getElementById('leaderboardImg');

const centerDecksEl = document.getElementById('centerDecks');

/* ✅ 追加：ラウンドチップ（R1/R2/R3） */
const roundChipsEl = document.getElementById('roundChips');
const roundChipImgEls = Array.from(document.querySelectorAll('#roundChips .round-chip-img'));


/* 中央の山札UI */
const actionDeckUI = document.getElementById('actionDeckUI');
const actionDeckCountEl = document.getElementById('actionDeckCount');
const sweetsDeckUI = document.getElementById('sweetsDeckUI');
const sweetsDeckCountEl = document.getElementById('sweetsDeckCount');
const sweetsExcludedDeckUI = document.getElementById('sweetsExcludedDeckUI');
const sweetsExcludedDeckCountEl = document.getElementById('sweetsExcludedDeckCount');


/* スイーツ一覧（ローカル） */
const sweetsBackdrop = document.getElementById('sweetsBackdrop');
const sweetsDropZone = document.getElementById('sweetsDropZone');
const btnSweetsClose = document.getElementById('btnSweetsClose');
const sweetsGrid = document.getElementById('sweetsGrid');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

/* ヘルプ */
const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

/* ターン操作バー */
const turnBar = document.getElementById('turnBar');
const turnBadge = document.getElementById('turnBadge');
const btnPass = document.getElementById('btnPass');
const btnDrawSweets = document.getElementById('btnDrawSweets');
const btnVote = document.getElementById('btnVote');

/* 右下PASS（ラウンド用） */
const passRoundBtn = document.getElementById('passRoundBtn');

/* ラウンド公開（複数） */
const roundRevealOverlay = document.getElementById('roundRevealOverlay');
const roundRevealRow = document.getElementById('roundRevealRow');

/* 中央拡大（単体） */
const revealOverlay = document.getElementById('revealOverlay');
const revealImg = document.getElementById('revealImg');
const revealLabel = document.getElementById('revealLabel');

/* =========================
   ユーティリティ
   ========================= */
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}
function shuffle(arr){
  const a = [...arr];
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function now(){ return Date.now(); }

/* ✅ 追加：勝利点テーブル（人数×ラウンド） */
function getRoundWinThreshold(playerCount, roundNo){
  const r = clamp(roundNo ?? 1, 1, 3);
  if(playerCount <= 4)  return [8,10,12][r-1];
  if(playerCount <= 6)  return [12,14,16][r-1];
  return [16,18,20][r-1]; // 7〜8人想定
}

/* ✅ 追加：選ばれたスイーツ合計点（cards配列のvalue合計） */
function calcSweetsTotalPoints(cards){
  const arr = Array.isArray(cards) ? cards : [];
  return arr.reduce((sum, c) => {
    const v =
      (c && typeof c.value === 'number') ? c.value :
      (c && typeof c.name === 'string') ? (parseInt(c.name, 10) || 0) :
      0;
    return sum + v;
  }, 0);
}

/* ✅ 追加：roundchip表示（game.roundChipsを反映） */
function renderRoundChipsFromGame(){
  if(!roundChipImgEls || !roundChipImgEls.length) return;
  const chips = (state.game && typeof state.game === 'object' && state.game.roundChips) ? state.game.roundChips : {};
  roundChipImgEls.forEach((img, idx) => {
    const r = String(idx + 1);
    const src = chips?.[r] || chips?.[idx + 1] || null; // 数字キー/文字キー両対応
    if(src){
      img.src = src;
      img.classList.remove('hidden');
    }else{
      img.removeAttribute('src');
      img.classList.add('hidden');
    }
  });
}



const roundRevealState = {
  started: false,
  finished: false,
  startedAt: null,
  finishedAt: null,
};

function resetRoundRevealState(){
  roundRevealState.started = false;
  roundRevealState.finished = false;
  roundRevealState.startedAt = null;
  roundRevealState.finishedAt = null;
}

function markRoundRevealStarted(){
  roundRevealState.started = true;
  roundRevealState.startedAt = now();
  roundRevealState.finished = false;
  roundRevealState.finishedAt = null;
}

function markRoundRevealFinished(){
  roundRevealState.finished = true;
  roundRevealState.finishedAt = now();
}

async function waitForRoundRevealCompletion(timeoutMs = 10000){
  const start = now();
  while(true){
    if(roundRevealState.started && roundRevealState.finished) return true;
    if(timeoutMs && now() - start > timeoutMs) return false;
    await sleep(50);
  }
}

function resetLocalGameEffects(){
  stopRoundEndFx();
  resetRoundRevealState();
  resetCollectedSweetsHiddenCache();

  miniShuffleToken += 1;
  miniShuffleRunning = false;
  sweetsExcludeAnimating = false;
  turnBlockedByShuffle = false;

  if(revealTimer){
    clearTimeout(revealTimer);
    revealTimer = null;
  }
  revealOverlay.classList.add('hidden');

  if(sweetsOverrideClearTimer){
    clearTimeout(sweetsOverrideClearTimer);
    sweetsOverrideClearTimer = null;
  }
  sweetsDeckCountOverride = null;
  sweetsExcludedCountOverride = null;

  document.querySelectorAll('.sweets-shuffle-stage, .sweets-move-card, .collect-card')
    .forEach(el => el.remove());

  roundRevealRow.innerHTML = '';
  roundRevealOverlay.classList.add('hidden');

  lastVoteSnapshot = null;
  lastPreparedVotesKey = '';
  queuedVoteAnimations = [];
  pendingVoteAdds.clear();

  updateActionDeckUI();
  updateSweetsDeckUI();
}




function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function setLeaderboardImageBase(base){
  if(!leaderboardImgEl) return;
  // 既定は .jpg → ダメなら .png → .webp
  leaderboardImgEl.dataset.base = base;
  leaderboardImgEl.dataset.try = 'jpg';
  leaderboardImgEl.src = `${base}.jpg`;
}
if (leaderboardImgEl){
  leaderboardImgEl.addEventListener('error', () => {
    const base = leaderboardImgEl.dataset.base || '';
    const tried = leaderboardImgEl.dataset.try || 'jpg';
    if(!base) return;

    if(tried === 'jpg'){
      leaderboardImgEl.dataset.try = 'png';
      leaderboardImgEl.src = `${base}.png`;
      return;
    }
    if(tried === 'png'){
      leaderboardImgEl.dataset.try = 'webp';
      leaderboardImgEl.src = `${base}.webp`;
      return;
    }
    // ここまで来たら諦めて非表示（無限エラー防止）
    leaderboardBoardEl?.classList.add('hidden');
  });
}

function updateLeaderboardBoardByPlayerCount(n){
  if(!leaderboardBoardEl || !leaderboardImgEl) return;

  let base = null;
  if(n >= 1 && n <= 4) base = 'swleaderboard1';
  else if(n >= 5 && n <= 6) base = 'swleaderboard2';
  else if(n >= 7 && n <= 8) base = 'swleaderboard3';

  if(!base){
    leaderboardBoardEl.classList.add('hidden');
    leaderboardBoardEl.setAttribute('aria-hidden','true');
    return;
  }

  leaderboardBoardEl.classList.remove('hidden');
  leaderboardBoardEl.setAttribute('aria-hidden','false');

  // 同じbaseなら張り替えない
  if(leaderboardImgEl.dataset.base !== base){
    setLeaderboardImageBase(base);
  }
}


/* =========================
   ★ 中央：アクション山札UI
   ========================= */
function updateActionDeckUI(){
  const deck = state.room?.decks?.action;
  const count = Array.isArray(deck) ? deck.length : 0;

  const started = !!state.room?.gameStarted;
  centerDecksEl.classList.toggle('hidden', !started);

  actionDeckUI.classList.toggle('hidden', !started);
  actionDeckCountEl.textContent = String(count);

  const stackN =
    count >= 20 ? 5 :
    count >= 12 ? 4 :
    count >= 6  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = actionDeckUI.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

/* =========================
   ★ 中央：スイーツ山札UI（残り枚数/山札感/鼓動）
   ========================= */
function getMySweetsCard(){
  const myData = state.hands?.[state.userId];
  const arr = myData?.sweets;
  if(Array.isArray(arr) && arr.length) return arr[0];
  return null;
}
function hasSweets(){
  return !!getMySweetsCard();
}
function clearSweetsCountOverridesIfSynced(liveCount, liveExcluded){
  if(sweetsDeckCountOverride === null && sweetsExcludedCountOverride === null) return;
  if(sweetsDeckCountOverride === liveCount && sweetsExcludedCountOverride === liveExcluded){
    sweetsDeckCountOverride = null;
    sweetsExcludedCountOverride = null;
    if(sweetsOverrideClearTimer){
      clearTimeout(sweetsOverrideClearTimer);
      sweetsOverrideClearTimer = null;
    }
  }
}
function setSweetsCountOverrides(deckCount, excludedCount, autoClearMs = 0){
  sweetsDeckCountOverride = deckCount;
  sweetsExcludedCountOverride = excludedCount;
  if(sweetsOverrideClearTimer){
    clearTimeout(sweetsOverrideClearTimer);
    sweetsOverrideClearTimer = null;
  }
  if(autoClearMs > 0){
    sweetsOverrideClearTimer = setTimeout(() => {
      sweetsDeckCountOverride = null;
      sweetsExcludedCountOverride = null;
      sweetsOverrideClearTimer = null;
      updateSweetsDeckUI();
    }, autoClearMs);
  }
}
function updateDeckStackUI(deckEl, count){
  if(!deckEl) return;
  const stackN =
    count >= 10 ? 5 :
    count >= 8  ? 4 :
    count >= 5  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = deckEl.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

function updateSweetsDeckUI(){
  const deck = state.room?.decks?.sweets;
  const excludedDeck = state.room?.decks?.sweetsExcluded;
  const liveCount = Array.isArray(deck) ? deck.length : 0;
  const liveExcluded = Array.isArray(excludedDeck) ? excludedDeck.length : 0;

  clearSweetsCountOverridesIfSynced(liveCount, liveExcluded);

  const count = sweetsDeckCountOverride ?? liveCount;
  const excludedCount = sweetsExcludedCountOverride ?? liveExcluded;


  const started = !!state.room?.gameStarted;
  centerDecksEl.classList.toggle('hidden', !started);

  sweetsDeckUI.classList.toggle('hidden', !started || miniShuffleRunning);
  sweetsExcludedDeckUI.classList.toggle('hidden', !started || miniShuffleRunning || (!sweetsExcludeAnimating && excludedCount <= 0));
  sweetsDeckCountEl.textContent = String(count);

 sweetsExcludedDeckCountEl.textContent = String(excludedCount);

  updateDeckStackUI(sweetsDeckUI, count);
  updateDeckStackUI(sweetsExcludedDeckUI, excludedCount);


  const pulsing = isMyTurn() && !hasSweets() && !hasReceivedInstruction();
  sweetsDeckUI.classList.toggle('pulsing', pulsing);
}

/* =========================
   ヘルプ（正体カード）
   ========================= */
function roleToHelp(role){
  if(role === 'usakoma'){
    return { name:"うさこま", img:"swsweetsurakoma.jpg", text:"（説明は後で）" };
  }
  if(role === 'uragiri'){
    return { name:"裏切り者", img:"swsweetsuragiri.jpg", text:"（説明は後で）" };
  }
  return { name:"不明", img:"swroleura.jpg", text:"" };
}
function renderHelpList(){
  helpBody.innerHTML = '';
  const list = [
    { name:"うさこま", img:"swsweetsurakoma.jpg", text:"（説明は後で）" },
    { name:"裏切り者", img:"swsweetsuragiri.jpg", text:"（説明は後で）" },
  ];
  list.forEach((r) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    const img = document.createElement('img');
    img.src = r.img;
    img.alt = r.name;
    card.appendChild(img);

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;

    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

/* =========================
   Seat 復元
   ========================= */
async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

/* =========================
   subscribe
   ========================= */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();

    prepareVoteAnimationsFromRoom();
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
renderMySweetsVoteStack();
    updatePassRoundBtn();
  });
}

function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
updateLeaderboardBoardByPlayerCount(players.length); 
    updatePassRoundBtn();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
    updatePassRoundBtn();
  });
}
function subscribeRoles(){
  const rolesRef = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderHands();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    state.game = snap.val() || {};
    state.turn = state.game.turn || null;
    state.turnEnding = false;
    const nextSessionId = state.game?.sessionId || null;
    const sessionChanged = nextSessionId !== currentGameSessionId;
    if(sessionChanged){
      resetLocalGameEffects();
      currentGameSessionId = nextSessionId;
    } else {
      resetCollectedSweetsHiddenCache();
    }
    syncPassTurnState();
    updateTurnUI();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    renderRoundChipsFromGame();

    // ★ ホスト：全員PASSになったらラウンド終了処理へ
    if(state.isHost){
      maybeHostStartRoundEndFlow().catch(()=>{});
      maybeHostFireRoundRevealAfterLeaderPick().catch(()=>{});
    }
    // ★ リーダー選択UI更新（同票解決）
    updateRoundPickUI();
    updatePassRoundBtn();
  });
}
function subscribeEvents(){
  const evRef = ref(db, `rooms/${state.roomCode}/events`);
  eventsSubscribedAt = now();
 onChildAdded(evRef, async snap => {
    const key = snap.key;
    const ev = snap.val();
    if(!ev) return;
    const expectedSessionId = state.game?.sessionId || currentGameSessionId || null;
    if(ev.sessionId){
      if(expectedSessionId && ev.sessionId !== expectedSessionId) return;
      if(!currentGameSessionId) currentGameSessionId = ev.sessionId;
    }
    if(!expectedSessionId && !currentGameSessionId) return;
    const isStaleEvent = typeof ev.at === 'number' && eventsSubscribedAt && ev.at < eventsSubscribedAt;
    if(!ev.sessionId && isStaleEvent) return;
    if(ev.type === 'miniSweetsShuffleStart' && isStaleEvent) return;
    if(ev.type === 'revealCard'){
      showReveal(ev.card);
    }
    if(ev.type === 'flyBackCard'){
      animateFlyBackCard(ev.fromSeat, ev.toSeat);
    }

    // ★ ラウンド終了演出（全員）
    if(ev.type === 'roundRevealSweets'){
      // ev.cards: 表にするカード配列（スイーツカード）
      await animateRoundEndReveal(ev.cards || [], ev.selectedUids || []);
  await animateReturnAllFieldSweetsToDeck();
  // ✅ その直後：除外札を「縦になって」山札へ回収
  await animateReturnExcludedDeckToSweetsDeck();
  await hostFinalizeReturnSweetsToDeck(ev.cards || []);

    }
    if(ev.type === 'miniSweetsShuffleStart'){
      await runMiniSweetsShuffleAtStart();
    }

    if(state.isHost){
      maybeHostStartRoundEndFlow().catch(()=>{});
    }
  });
}

/* =========================
   ターン管理（PASS対応：passした人は飛ばす）
   ========================= */
function getSeatedSeatOrder(){
  return latestPlayers.map(p => p.seatIndex).sort((a,b)=>a-b);
}
function getPlayerBySeat(seatIndex){
  return latestPlayers.find(p => p.seatIndex === seatIndex) || null;
}
function getPassedMap(){
  const p = state.game?.passes;
  return (p && typeof p === 'object') ? p : {};
}
function isPassedPlayerId(uid){
  const pm = getPassedMap();
  return !!pm?.[uid];
}
function isTurnBlocked(){
  return !!turnBlockedByShuffle;
}

async function hostGrantTurnAfterMiniShuffle(){
  if(!state.isHost || !state.roomCode) return;
  if(state.game?.turn) return;
  const seats = getSeatedSeatOrder();
  if(!seats.length) return;
  const randomSeat = seats[Math.floor(Math.random() * seats.length)];
  const player = getPlayerBySeat(randomSeat);
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await set(turnRef, {
    activeSeat: randomSeat,
    activePlayerId: player?.id ?? null,
    startSeat: randomSeat,
    leaderSeat: randomSeat,
    turnNo: 1,
    updatedAt: serverTimestamp(),
  });
}

function getNextOccupiedSeatSkippingPassed(currentSeat){
  const seats = getSeatedSeatOrder();
  if(!seats.length) return null;

  const startIdx = seats.indexOf(currentSeat);
  const begin = (startIdx === -1) ? 0 : startIdx;

  for(let step=1; step<=seats.length; step++){
    const s = seats[(begin + step) % seats.length];
    const p = getPlayerBySeat(s);
    if(!p) continue;
    if(!isPassedPlayerId(p.id)) return s;
  }
  // 全員pass済みなら、通常はここに来ない（ラウンド終了に入る）
  return seats[(begin + 1) % seats.length];
}
function isMyTurn(){
  if(!state.turn) return false;
  if(isTurnBlocked()) return false;
  return (state.turn.activePlayerId === state.userId);
}
async function endTurn(reason){
  if(!state.roomCode || !state.turn) return;
  if(!isMyTurn()) return;

  state.turnEnding = true;
  updatePassRoundBtn();

  const nextSeat = getNextOccupiedSeatSkippingPassed(state.turn.activeSeat);
  if(nextSeat == null) return;

  const nextP = getPlayerBySeat(nextSeat);
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await update(turnRef, {
    activeSeat: nextSeat,
    activePlayerId: nextP?.id || null,
    lastEndReason: reason,
    updatedAt: serverTimestamp(),
    turnNo: (state.turn.turnNo || 1) + 1,
  });
}

/* =========================
   デッキ構築（アクションカード）
   ========================= */
const ACTION_COUNTS_BASE = [
  { name:'ああ', count:3, kind:'normal' },
  { name:'いい', count:3, kind:'normal' },
  { name:'うう', count:3, kind:'normal' },
  { name:'ええ', count:3, kind:'normal' },
  { name:'おお', count:3, kind:'normal' },
  { name:'かか', count:3, kind:'normal' },

  { name:'きき', count:3, kind:'instruction' },
  { name:'くく', count:3, kind:'instruction' },
  { name:'けけ', count:3, kind:'instruction' },

  { name:'',     count:3, kind:'instruction' },
  { name:'応援', count:3, kind:'instruction' },
  { name:'賄賂', count:3, kind:'instruction' },

  { name:'無視', count:3, kind:'instruction' },
];
const ACTION_COUNTS_7P = [
  { name:'ああ', count:2, kind:'normal' },
  { name:'いい', count:2, kind:'normal' },
  { name:'うう', count:2, kind:'normal' },
];
const INSTRUCTION_NEED_TARGET = new Set(['きき','くく','けけ','応援','賄賂','']);
const INSTRUCTION_CAN_SELF = new Set(['無視']);

function cardNameToImg(name){
  if(name === '') return 'blank.jpg';
  return `${name}.jpg`;
}
function buildActionDeck(playerCount){
  const list = [];
  const counts = [...ACTION_COUNTS_BASE, ...(playerCount >= 7 ? ACTION_COUNTS_7P : [])];
  counts.forEach(def => {
    for(let i=0;i<def.count;i++){
      list.push({
        id: crypto.randomUUID(),
        name: def.name,
        kind: def.kind,
        img: cardNameToImg(def.name),
        backImg: `swactionura.jpg`,
        effectText: getActionEffectText(def.name),
      });
    }
  });
  return shuffle(list);
}
function getActionEffectText(cardName){
  const map = {
    'ああ': '（効果は後で）',
    'いい': '（効果は後で）',
    'うう': '（効果は後で）',
    'ええ': '（効果は後で）',
    'おお': '（効果は後で）',
    'かか': '（効果は後で）',
    'きき': '（指示：相手に使う／効果は後で）',
    'くく': '（指示：相手に使う／効果は後で）',
    'けけ': '（指示：相手に使う／効果は後で）',
    '':     '（指示：相手に使う／効果は後で）',
    '応援': '（指示：相手に使う／効果は後で）',
    '賄賂': '（指示：相手に使う／効果は後で）',
    '無視': '（指示：自分/相手OK／効果は後で）',
  };
  return map[cardName] ?? '（効果は後で）';
}

/* =========================
   ★ スイーツデッキ構築
   ========================= */
const SWEETS_BACK_IMG = 'swsweetsura.jpg';

function buildSweetsPool(){
  const base = [
    { value:0, img:'sw0.jpg', fallback:'sw1.jpg' },
    { value:1, img:'sw1.jpg' },
    { value:2, img:'sw2.jpg' },
    { value:3, img:'sw3.jpg' },
    { value:3, img:'sw3(2).jpg' },
    { value:4, img:'sw4.jpg' },
    { value:4, img:'sw4(2).jpg' },
    { value:5, img:'sw5.jpg' },
    { value:5, img:'sw5(2).jpg' },
    { value:6, img:'sw6.jpg' },
    { value:7, img:'sw7.jpg' },
    { value:8, img:'sw8.jpg' },
  ];
  return base.map(b => ({
    id: crypto.randomUUID(),
    kind: 'sweets',
    value: b.value,
    name: String(b.value),
    img: b.img,
    backImg: SWEETS_BACK_IMG,
    fallback: b.fallback || null,
  }));
}
function buildSweetsDeck(playerCount){
  const pool = buildSweetsPool();
  return shuffle(pool);
}
function splitSweetsDeck(deck, playerCount){
  const total = Array.isArray(deck) ? deck.length : 0;
  const keepCount = clamp(playerCount + 2, 0, total);
  if(!Array.isArray(deck) || total <= keepCount){
    return { sweets: Array.isArray(deck) ? deck : [], excluded: [] };
  }
  const shuffled = shuffle([...deck]);
  return {
    sweets: shuffled.slice(0, keepCount),
    excluded: shuffled.slice(keepCount),
  };
}

/* =========================
   正体カード配布
   ========================= */
function buildRolePool(n){
  const usakoma = Math.ceil(n/2);
  const uragiri = Math.floor(n/2);
  const pool = [];
  for(let i=0;i<usakoma;i++) pool.push('usakoma');
  for(let i=0;i<uragiri;i++) pool.push('uragiri');
  return shuffle(pool);
}

/* =========================
   ゲーム開始（ホストのみ）
   ========================= */
async function hostGameStart(){
  if(!state.isHost || !state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? {
      id: t.playerId,
      name: t.playerName || '名無し',
      seatIndex: Number(seatIndex)
    } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex-b.seatIndex);

  if(players.length === 0) return;

  const seats = players.map(p=>p.seatIndex).sort((a,b)=>a-b);

  let actionDeck = buildActionDeck(players.length);
  const sweetsDeck = buildSweetsDeck(players.length);

  const hands = {};
  players.forEach(p => {
    hands[p.id] = {
      action: actionDeck.splice(0, 3),
      sweets: [],
      received: [],
      voteChips: 1,
    };
  });

  const pool = buildRolePool(players.length);
 const roles = {};
  players.forEach((p, i) => { roles[p.id] = pool[i]; });

  const base = `rooms/${state.roomCode}`;
  const gameSessionId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  await update(ref(db, `${base}/game`), { turn: null });
  await update(ref(db, `${base}`), { gameStarted: true });
  await remove(ref(db, `${base}/events`));
  await set(ref(db, `${base}/hands`), {});
  await set(ref(db, `${base}/roles`), {});
  await set(ref(db, `${base}/discard`), { action: [] });

  await set(ref(db, `${base}/decks`), { action: actionDeck, sweets: sweetsDeck, sweetsExcluded: [] });



  await Promise.all([
    set(ref(db, `${base}/hands`), hands),
    set(ref(db, `${base}/roles`), roles),
  ]);

  await set(ref(db, `${base}/votes`), {});
  await set(ref(db, `${base}/game`), {
    status: 'playing',
    startedAt: serverTimestamp(),
    sessionId: gameSessionId,
    seatOrder: seats,
    passes: {},               // ★ ラウンドPASS
    roundEnding: false,       // ★ ラウンド終了中フラグ
    roundPick: null,          // ★ 同票解決状態
    roundNo: 1,
    roundChips: {},
    turn: null

  });

  await emitEvent({ type: 'miniSweetsShuffleStart', sessionId: gameSessionId });

  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   イベント（全員演出用）
   ========================= */
async function emitEvent(payload){
  if(!state.roomCode) return;
  const evRef = ref(db, `rooms/${state.roomCode}/events`);
  const sessionId = payload.sessionId ?? currentGameSessionId ?? state.game?.sessionId ?? null;
  const eventPayload = { ...payload, at: now() };
  if(sessionId) eventPayload.sessionId = sessionId;
  await push(evRef, eventPayload);
}


/* =========================
   中央拡大（全員1秒）
   ========================= */
let revealTimer = null;
function showReveal(card){
  if(!card) return;
  revealImg.src = card.img || '';
  revealLabel.textContent = card.name || '';
  revealOverlay.classList.remove('hidden');
  if(revealTimer) clearTimeout(revealTimer);
  revealTimer = setTimeout(()=>{
    revealOverlay.classList.add('hidden');
  }, 1000);
}







/* =========================
   指示カード：裏カード移動アニメ（全員）
   ========================= */
function animateFlyBackCard(fromSeat, toSeat){
  const fromEl = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  const toEl   = document.querySelector(`.player-tag[data-seat="${toSeat}"]`);
  if(!fromEl || !toEl) return;

  const fr = fromEl.getBoundingClientRect();
  const tr = toEl.getBoundingClientRect();

  const fly = document.createElement('div');
  fly.className = 'fly-card';
  fly.style.left = `${fr.right + 6}px`;
  fly.style.top  = `${fr.top + fr.height/2 - 16}px`;
  document.body.appendChild(fly);

  const toX = (tr.right + 6) - (fr.right + 6);
  const toY = (tr.top + tr.height/2 - 16) - (fr.top + fr.height/2 - 16);

  fly.animate([
    { transform:`translate(0px,0px) scale(1)`, opacity:1 },
    { transform:`translate(${toX}px,${toY}px) scale(1.05)`, opacity:1 }
  ], {
    duration: 520,
    easing: 'cubic-bezier(.22,.84,.44,1)'
  }).onfinish = () => fly.remove();
}

/* =========================
   文字を枠内に収める
   ========================= */
function fitEffectText(el){
  if(!el) return;
  const box = el.parentElement;
  if(!box) return;

  let size = 13;
  el.style.fontSize = size + 'px';

  for(let i=0;i<10;i++){
    if(el.scrollHeight <= box.clientHeight - 2) break;
    size = size - 1;
    if(size < 9){ size = 9; break; }
    el.style.fontSize = size + 'px';
  }
}

/* =========================
   ★ 受け取り指示カード
   ========================= */
function getMyReceivedCard(){
  const myData = state.hands?.[state.userId];
  const rec = myData?.received;
  if(Array.isArray(rec) && rec.length) return rec[0];
  return null;
}
function hasReceivedInstruction(){
  return !!getMyReceivedCard();
}


/* =========================
   ★ スイーツ回収（拡大表示終了後）
   - 場のスイーツ（selected / 非selected）を山札へ
   - その直後、除外札は縦になって山札へ
   ========================= */

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

async function waitUntilHidden(el, timeoutMs = 4500){
  const start = Date.now();
  while(Date.now() - start < timeoutMs){
    if(!el || el.classList.contains('hidden')) return;
    await sleep(50);
  }
}

function isVisibleRect(el){
  if(!el) return false;
  const r = el.getBoundingClientRect();
  return !!(r.width && r.height);
}

function isFieldElement(el){
  if(!el) return false;
  // オーバーレイ中のカードは対象外
  if(el.closest('#roundRevealOverlay')) return false;
  if(el.closest('#revealOverlay')) return false;
  if(el.closest('#sweetsBackdrop')) return false;
  return isVisibleRect(el);
}

function getSweetsDeckTargetRect(){
  if(!sweetsDeckUI) return null;
  const r = sweetsDeckUI.getBoundingClientRect();
  if(!r.width || !r.height) return null;
  return {
    x: r.left + r.width/2,
    y: r.top + r.height/2,
    w: r.width,
    h: r.height,
    raw: r
  };
}

function getCollectAnimationSnapshot(el){
  if(!el) return null;
  const rect = el.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  const width = el.offsetWidth || rect.width;
  const height = el.offsetHeight || rect.height;
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  const hostCircle = el.closest('.otherplayerscircle');
  const rotValue = hostCircle ? getComputedStyle(hostCircle).getPropertyValue('--rotDeg').trim() : '0deg';
  const rotateDeg = parseRotationDegrees(rotValue);

  return {
    left: centerX - width / 2,
    top: centerY - height / 2,
    width,
    height,
    rotateDeg,
  };
}

function normalizeRotationDegrees(fromDeg, toDeg){
  const from = Number.isFinite(fromDeg) ? fromDeg : 0;
  const to = Number.isFinite(toDeg) ? toDeg : 0;
  const diff = ((from - to + 540) % 360) - 180;
  return to + diff;
}

function animateOneCardToDeck(srcRect, target, { delay = 0, rotateFrom = 0, rotateTo = 0 } = {}){
  if(!srcRect || !srcRect.width || !srcRect.height || !target) return Promise.resolve();

  const fly = document.createElement('div');
  fly.className = 'collect-card';
  fly.style.left = `${srcRect.left}px`;
  fly.style.top  = `${srcRect.top}px`;
  fly.style.width  = `${srcRect.width}px`;
  fly.style.height = `${srcRect.height}px`;
  fly.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  fly.style.zIndex = '999999';
  document.body.appendChild(fly);

  const dx = target.x - (srcRect.left + srcRect.width/2);
  const dy = target.y - (srcRect.top  + srcRect.height/2);

  const scaleX = target.w / srcRect.width;
  const scaleY = target.h / srcRect.height;
  const scale  = Math.min(scaleX, scaleY);

  const normalizedRotateFrom = normalizeRotationDegrees(rotateFrom, rotateTo);

  return new Promise(resolve => {
    fly.animate([
      { transform:`translate(0px,0px) rotate(${normalizedRotateFrom}deg) scale(1)`, opacity:1 },
      { transform:`translate(0px,0px) rotate(${rotateTo}deg) scale(1)`, opacity:1, offset:0.55 },
      { transform:`translate(${dx}px,${dy}px) rotate(${rotateTo}deg) scale(${scale})`, opacity:0.92 },
    ],{
      duration: 780,
      delay,
      easing: 'cubic-bezier(.22,.84,.44,1)',
      fill: 'forwards'
    }).onfinish = () => {
      fly.remove();
      resolve();
    };
  });
}

async function animateReturnAllFieldSweetsToDeck(){

  // 「拡大公開が実行済み & 終了済み」を待つ
  const revealDone = await waitForRoundRevealCompletion();
  if(!revealDone) return;
  await sleep(800);

  const target = getSweetsDeckTargetRect();
  if(!target) return;

  const sources = [];

  // 1) selected（ネームタグ上の selected-sweets-card）
  document.querySelectorAll('.selected-sweets-card').forEach(cardEl => {
    if(!isFieldElement(cardEl)) return;
    sources.push({
      el: cardEl,
      host: cardEl.closest('.selected-sweets-tag') || cardEl,
      uid: (cardEl.closest('.selected-sweets-tag')?.dataset?.sweetsUid) || null
    });
  });

  // 2) 非selected（他プレイヤーの sweets-wrap 内 sweets-mini）
  document.querySelectorAll('.sweets-wrap .sweets-mini').forEach(miniEl => {
    if(!isFieldElement(miniEl)) return;
    sources.push({
      el: miniEl,
      host: miniEl.closest('.sweets-wrap') || miniEl,
      uid: (miniEl.closest('.sweets-wrap')?.dataset?.sweetsUid) || null
    });
  });

  // 3) 自分のスイーツ（手元表示が残っている場合も回収）
  const myImg = mySweetsEl?.querySelector('img');
  if(myImg && isFieldElement(myImg)){
    sources.push({
      el: myImg,
      host: mySweetsEl,
      uid: state.userId || null
    });
  }

  if(!sources.length) return;

  // フリッカー防止：render側でも消えるように（既存キャッシュを利用）
  sources.forEach(s => { if(s.uid) collectedSweetsHidden.add(s.uid); });

  // 元DOMを先に不可視化（回収中に二重に見えないように）
  sources.forEach(s => {
    if(s.host?.classList) s.host.classList.add('collect-hidden');
    else if(s.el) s.el.style.visibility = 'hidden';
  });

  // 回収アニメ（少しだけズラして気持ちよく）
  const tasks = sources.map((s, i) => {
    const snapshot = getCollectAnimationSnapshot(s.el);
    if(!snapshot) return Promise.resolve();
    return animateOneCardToDeck(snapshot, target, { delay: i * 35, rotateFrom: snapshot.rotateDeg, rotateTo: 0 });
  });

  await Promise.all(tasks);
}

async function animateReturnExcludedDeckToSweetsDeck(){
  // 「その直後」
  await sleep(30);

  // 除外が無いなら何もしない
  const excludedDeck = state.room?.decks?.sweetsExcluded;
  const liveExcluded = Array.isArray(excludedDeck) ? excludedDeck.length : 0;
  const excludedCount = (sweetsExcludedCountOverride ?? liveExcluded);
  if(excludedCount <= 0) return;

  const target = getSweetsDeckTargetRect();
  if(!target) return;

  if(!sweetsExcludedDeckUI || !isVisibleRect(sweetsExcludedDeckUI)) return;
  const exRect = sweetsExcludedDeckUI.getBoundingClientRect();

  // UIを一瞬隠して「飛ぶ1枚」だけ見せる（見た目重複防止）
  const prevVis = sweetsExcludedDeckUI.style.visibility;
  sweetsExcludedDeckUI.style.visibility = 'hidden';

  // 横(90deg) → 縦(0deg) になりつつ山札へ
  await animateOneCardToDeck(exRect, target, { delay: 0, rotateFrom: 90, rotateTo: 0 });

  sweetsExcludedDeckUI.style.visibility = prevVis;
}

// ✅ ホストだけ：ラウンド終了後に「全スイーツ（selected/非selected/手元）＋除外」をDB上で山札へ戻す
async function hostFinalizeReturnSweetsToDeck(revealedCards = []){
  if(!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;

  // 最新を取り直す（stateのズレ対策）
  const [handsSnap, decksSnap] = await Promise.all([
    get(ref(db, `${base}/hands`)),
    get(ref(db, `${base}/decks`)),
  ]);

  const gameSnap = await get(ref(db, `${base}/game`));
  const gameNow = gameSnap.val() || {};


  const hands = handsSnap.val() || {};
  const decks = decksSnap.val() || {};
  const deckSweets = Array.isArray(decks.sweets) ? decks.sweets : [];
  const excluded   = Array.isArray(decks.sweetsExcluded) ? decks.sweetsExcluded : [];

  // 返すカードを「id」でユニーク化（重複防止）
  const returned = new Map();
  const add = (c) => {
    if(!c || !c.id) return;
    if(!returned.has(c.id)) returned.set(c.id, c);
  };

  // ① イベントで公開されたカード（selected/非selectedの実体になっている想定）
  (Array.isArray(revealedCards) ? revealedCards : []).forEach(add);

  // ② hands に残っているスイーツ（手元含む）も全部回収（これが枚数不足の主因）
  Object.values(hands).forEach(h => {
    const arr = h?.sweets;
    if(Array.isArray(arr)) arr.forEach(add);
  });

  // ③ 除外も山札へ戻す（今回の仕様）
  excluded.forEach(add);

  const returnedIds = new Set(returned.keys());

  // 既に山札に紛れ込んでいた場合でも二重化しないよう、先に除去してから足す
  const baseDeck = deckSweets.filter(c => !(c && c.id && returnedIds.has(c.id)));
  const newDeck  = shuffle([...baseDeck, ...Array.from(returned.values())]);

  // hands の sweets を全員ぶん空にする
  for(const uid of Object.keys(hands)){
    if(hands[uid] && Array.isArray(hands[uid].sweets)){
      hands[uid].sweets = [];
    }
  }

  // DB反映（decksは部分更新でOK）
  await update(ref(db, base), {
    'hands': hands,
    'decks/sweets': newDeck,
    'decks/sweetsExcluded': [],   // 除外は空に
    /* ✅ 追加：ここから勝敗判定→roundchip→round+1 */
    ...( (() => {
      const playerCount = Array.isArray(gameNow.seatOrder) ? gameNow.seatOrder.length : (latestPlayers?.length || 0);
      const currentRound = (typeof gameNow.roundNo === 'number') ? gameNow.roundNo : 1;

      const pts = calcSweetsTotalPoints(revealedCards);          // 選ばれたスイーツ合計点
      const th  = getRoundWinThreshold(playerCount || 1, currentRound);
      const win = pts >= th;

      // roundchipは1〜3のスロットにのみ描画（キーは "1","2","3" で持つ）
      const prev = (gameNow.roundChips && typeof gameNow.roundChips === 'object') ? gameNow.roundChips : {};
      const nextChips = { ...prev };
      if(currentRound >= 1 && currentRound <= 3){
        nextChips[String(currentRound)] = win ? 'winchip.png' : 'losechip.png';
      }

      return {
        'game/roundChips': nextChips,
        'game/roundNo': currentRound + 1,          // 処理が終わった後で +1
        'game/lastRoundPoints': pts,               // （任意：デバッグ用。不要なら消してOK）
        'game/lastRoundThreshold': th,             // （任意：デバッグ用）
      };
    })() )

  });
}


/* =========================
   ★ 投票（チップ表示＆条件）
   ========================= */
function getMyVoteChips(){
  if(!state.room?.gameStarted) return 0;
  const myData = state.hands?.[state.userId] || {};
  const v = myData.voteChips;
  return (typeof v === 'number') ? v : 0;
}
function getPlayerVoteChips(uid){
  if(!state.room?.gameStarted) return 0;
  const data = state.hands?.[uid] || {};
  const v = data.voteChips;
  return (typeof v === 'number') ? v : 0;
}
function getSweetsOwners(){
  return latestPlayers
    .filter(p => {
      const hd = state.hands?.[p.id];
      return !!(hd && Array.isArray(hd.sweets) && hd.sweets.length);
    })
    .map(p => p.id);
}
function canVoteNow(){
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(hasReceivedInstruction()) return false;
  if(getMyVoteChips() <= 0) return false;
  return getSweetsOwners().length >= 1;
}
function renderMyVoteChip(){
  const started = !!state.room?.gameStarted;
  if(!started){
    myVoteChipEl.classList.add('hidden');
    myVoteChipEl.classList.remove('pulsing');
    return;
  }

  const chips = getMyVoteChips();
 myVoteChipEl.classList.toggle('hidden', chips <= 0);
  myVoteChipEl.classList.toggle('pulsing', canVoteNow());
}

let lastVoteSnapshot = null;
let lastPreparedVotesKey = '';
let queuedVoteAnimations = [];
const pendingVoteAdds = new Map();
function getVoteSnapshot(votesObj){
  const snapshot = new Map();
  const votes = votesObj && typeof votesObj === 'object' ? votesObj : {};
  Object.entries(votes).forEach(([targetUid, voters]) => {
    if(!voters || typeof voters !== 'object') return;
    snapshot.set(targetUid, new Set(Object.keys(voters)));
  });
  return snapshot;
}
function getNewVotes(prev, next){
  const diffs = [];
  if(!prev) return diffs;
  next.forEach((voters, targetUid) => {
    voters.forEach(voterUid => {
      const prevSet = prev.get(targetUid);
      if(!prevSet || !prevSet.has(voterUid)){
        diffs.push({ voterUid, targetUid });
      }
    });
  });
  return diffs;
}
function prepareVoteAnimationsFromRoom(){
  const votesObj = state.room?.votes || {};
  const votesKey = JSON.stringify(votesObj);
  if(votesKey === lastPreparedVotesKey) return;
  lastPreparedVotesKey = votesKey;

  const current = getVoteSnapshot(votesObj);
  if(!lastVoteSnapshot){
    lastVoteSnapshot = current;
    queuedVoteAnimations = [];
    pendingVoteAdds.clear();
    return;
  }
  const newVotes = getNewVotes(lastVoteSnapshot, current);
  if(newVotes.length){
    queuedVoteAnimations = queuedVoteAnimations.concat(newVotes);
    newVotes.forEach(({ targetUid }) => {
      pendingVoteAdds.set(targetUid, (pendingVoteAdds.get(targetUid) || 0) + 1);
    });
  }
  lastVoteSnapshot = current;
}
function getPendingVoteCount(targetUid){
  return pendingVoteAdds.get(targetUid) || 0;
}
function getDisplayedVoteCountFor(targetUid){
  const total = getVoteCountFor(targetUid);
  const pending = getPendingVoteCount(targetUid);
  return Math.max(total - pending, 0);
}
function getVoteChipSizePx(){
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--voteMiniSize'));
  return Number.isFinite(size) ? size : 14;
}
function getVoteChipSourceRect(voterUid){
  const voteChip = document.querySelector(`.other-vote-chip[data-voter-uid="${voterUid}"]`);
  if(voteChip){
    const rect = voteChip.getBoundingClientRect();
    return {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
    };
  }
  const tag = document.querySelector(`.player-tag[data-uid="${voterUid}"]`);
  if(!tag) return null;
  const miniHand = tag.querySelector('.mini-hand');
  const size = getVoteChipSizePx();
  if(miniHand){
    const rect = miniHand.getBoundingClientRect();
    return {
      left: rect.right + 6,
      top: rect.top + (rect.height - size) / 2,
      width: size,
      height: size,
    };
  }
  const tagRect = tag.getBoundingClientRect();
  return {
    left: tagRect.right + 6,
    top: tagRect.top + (tagRect.height - size) / 2,
    width: size,
    height: size,
  };
}
function getVoteChipTargetInfo(targetUid){
  const stack = document.querySelector(`.vote-stack[data-target-uid="${targetUid}"]`);
  if(!stack) return null;
  const rect = stack.getBoundingClientRect();
  const size = getVoteChipSizePx();
  return {
    stack,
    rect: {
      left: rect.left + (rect.width - size) / 2,
      top: rect.top + (rect.height - size) / 2,
      width: size,
      height: size,
    },
  };
}
function finalizeVoteChipArrival(targetUid, stackEl){
  const stack = stackEl && stackEl.isConnected
    ? stackEl
    : document.querySelector(`.vote-stack[data-target-uid="${targetUid}"]`);
  const pending = pendingVoteAdds.get(targetUid) || 0;
  if(pending > 0){
    pendingVoteAdds.set(targetUid, pending - 1);
  }
  if(!stack) return;

  const actualCount = getVoteCountFor(targetUid);
  const currentCount = stack.querySelectorAll('.vote-mini').length;
  if(currentCount < actualCount){
    const v = document.createElement('div');
    v.className = 'vote-mini';
    stack.appendChild(v);
  }
  if((pendingVoteAdds.get(targetUid) || 0) === 0){
    stack.classList.remove('pending');
  }
}
function animateVoteChipFly(voterUid, targetUid){
  if(voterUid === state.userId) return;
  const sourceChip = document.querySelector(`.other-vote-chip[data-voter-uid="${voterUid}"]`);
  if(sourceChip){
    sourceChip.classList.add('is-flying');
  }
  const source = getVoteChipSourceRect(voterUid);
  const targetInfo = getVoteChipTargetInfo(targetUid);
  if(!source || !targetInfo){
    if(sourceChip){
      sourceChip.classList.remove('is-flying');

    }
    return;
  }
  const { stack, rect: target } = targetInfo;

  const fly = document.createElement('div');
  fly.className = 'vote-chip-fly';
  fly.style.left = `${source.left}px`;
  fly.style.top = `${source.top}px`;
  fly.style.width = `${source.width}px`;
  fly.style.height = `${source.height}px`;
 document.body.appendChild(fly);

  const dx = target.left - source.left;
  const dy = target.top - source.top;
 fly.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: 600,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    fly.remove();
    if(sourceChip){
      sourceChip.classList.remove('is-flying');
    }
    finalizeVoteChipArrival(targetUid, stack);
  };
}
function scheduleVoteChipAnimations(){
  const newVotes = queuedVoteAnimations;
  queuedVoteAnimations = [];
  if(!newVotes.length) return;
  requestAnimationFrame(() => {
    newVotes.forEach(({ voterUid, targetUid }) => {
      animateVoteChipFly(voterUid, targetUid);
    });
  });
}



/* =========================
   ★★★ PASSボタン表示条件（ラウンド用）
   - 自分の手番
   - 自分がスイーツ獲得済み
   - 自分の投票が済み（voteChips <= 0）
   - 受け取り指示なし
   - まだ自分がPASSしていない
   ========================= */
function myDoneSweetsAndVote(){
  return hasSweets() && (getMyVoteChips() <= 0);
}
function syncPassTurnState(){
  const turnNo = state.turn?.turnNo ?? null;
  if(turnNo !== state.prevTurnNo){
    state.prevTurnNo = turnNo;
    state.passReadyBlockedTurnNo = null;
    state.lastPassEligible = false;
    if(isMyTurn()){
      state.lastPassEligible = myDoneSweetsAndVote() && !hasReceivedInstruction();
    }
  }
}
function updatePassRoundBtn(){
  const started = !!state.room?.gameStarted;
  const mine = isMyTurn();
  const passed = isPassedPlayerId(state.userId);
  const ending = !!state.game?.roundEnding;
  const eligible = myDoneSweetsAndVote() && !hasReceivedInstruction();
  if(mine){
    if(!state.lastPassEligible && eligible){
      state.passReadyBlockedTurnNo = state.turn?.turnNo ?? null;
    }
    state.lastPassEligible = eligible;
  } else {
    state.lastPassEligible = false;
  }
  const show = started && mine && !ending && !passed && !state.turnEnding && eligible && state.passReadyBlockedTurnNo !== state.turn?.turnNo;
  passRoundBtn.classList.toggle('visible', show);
  passRoundBtn.disabled = !show;
}

/* =========================
   手札レンダー
   ========================= */
function renderMyRole(){
  const started = !!state.room?.gameStarted;
  if(!started){
    myRoleEl.classList.add('hidden');
    myRoleEl.innerHTML = '';
    return;
  }

  const myRole = state.roles?.[state.userId];
  if(!myRole){
    myRoleEl.classList.add('hidden');
    myRoleEl.innerHTML = '';
    return;
  }
  const info = roleToHelp(myRole);
  myRoleEl.classList.remove('hidden');
  myRoleEl.innerHTML = '';
  const img = document.createElement('img');
  img.src = info.img;
  img.alt = info.name;
  myRoleEl.appendChild(img);
}

function renderMySweets(){
  mySweetsEl.innerHTML = '';
  const c = getMySweetsCard();
  if(!c){
    mySweetsEl.classList.add('hidden');
    updateRoundPickUI();
    lastMySweetsSnapshot = null;
    mySweetsFlyAnimatedFor = null;
    return;
  }
  const decidedUids = getDecidedSweetsUids();
  if(decidedUids.includes(state.userId)){
    mySweetsEl.classList.add('hidden');
    mySweetsEl.innerHTML = '';
    updateRoundPickUI();
    return;
  }
  mySweetsFlyAnimatedFor = null;
  mySweetsEl.classList.remove('hidden');
  const img = document.createElement('img');
  img.src = c.img;
  img.alt = `sweets ${c.value ?? ''}`;
  img.onerror = () => { if(c.fallback) img.src = c.fallback; };
  mySweetsEl.appendChild(img);

  // ★ 追加：自分スイーツにも投票ミニを重ねる
  renderMySweetsVoteStack();

  updateRoundPickUI();
  requestAnimationFrame(cacheMySweetsSnapshot);
}

/* ★ カードDOMを作る共通 */
function buildCardEl(cardObj, { extraClass='' } = {}){
  const card = document.createElement('div');
  card.className = 'action-card' + (extraClass ? ` ${extraClass}` : '');
  card.dataset.cardId = cardObj.id;

  const img = document.createElement('img');
  img.className = 'card-img';
  img.src = cardObj.img;
  img.alt = cardObj.name;

  const name = document.createElement('div');
  name.className = 'card-name';
  name.textContent = cardObj.name;

  const frame = document.createElement('div');
  frame.className = 'effect-frame';

  const txt = document.createElement('div');
  txt.className = 'effect-text';
  txt.textContent = cardObj.effectText || '';
  frame.appendChild(txt);

  card.appendChild(img);
  card.appendChild(name);
  card.appendChild(frame);

  requestAnimationFrame(()=> fitEffectText(txt));
  return card;
}

function renderMyReceived(){
  myReceivedEl.innerHTML = '';
  const rec = getMyReceivedCard();
  if(!rec) return;

  const cardEl = buildCardEl(rec, { extraClass:'pulse-only' });
  cardEl.addEventListener('pointerdown', (e) => startDragCard(e, rec, cardEl));
  myReceivedEl.appendChild(cardEl);
}

function renderMyHand(){
  myHandEl.innerHTML = '';

  const myData = state.hands?.[state.userId];
  if(!myData || !Array.isArray(myData.action)) return;

  const receivedExists = hasReceivedInstruction();

  myData.action.forEach(cardObj => {
    const allowThisCard =
      !receivedExists || (cardObj.kind === 'instruction' && cardObj.name === '無視');

    const cardEl = buildCardEl(cardObj);
    if(receivedExists && cardObj.kind === 'instruction' && cardObj.name === '無視'){
      cardEl.classList.add('can-ignore');
    }

    cardEl.addEventListener('pointerdown', (e) => {
      if(!allowThisCard) return;
      startDragCard(e, cardObj, cardEl);
    });

    myHandEl.appendChild(cardEl);
  });
}

function applyMyTurnClasses(){
  const wrap = document.querySelector('.my-hand-wrapper');
  if(!wrap) return;

  const mine = isMyTurn();
  const receivedExists = hasReceivedInstruction();
  const roundPickActive = getRoundPick()?.phase === 'choose';

  wrap.classList.remove('my-turn-free','my-turn-blocked');
  if(!mine || roundPickActive) return;

  if(receivedExists){
    wrap.classList.add('my-turn-blocked');
  }else{
    wrap.classList.add('my-turn-free');
  }
}

function renderHands(){
  renderMyRole();
  renderMySweets();
  renderMyReceived();
  renderMyHand();
  applyMyTurnClasses();
  updateSweetsDeckUI();
  renderMyVoteChip();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  updatePassRoundBtn();
}

/* =========================
   プレイヤー円レンダー
   ========================= */
let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;

function renderMySweetsVoteStack(){
  // スイーツ未所持なら何もしない（＆残骸があれば消す）
  const c = getMySweetsCard();
  const old = mySweetsEl.querySelector('.vote-stack');
  if(old) old.remove();
  if(!c) return;

  const pendingCount = getPendingVoteCount(state.userId);
  const vCount = getDisplayedVoteCountFor(state.userId);
  if(vCount <= 0 && pendingCount <= 0) return;

  const voteStack = document.createElement('div');
  voteStack.className = 'vote-stack';
  voteStack.dataset.targetUid = state.userId;
  if(pendingCount > 0) voteStack.classList.add('pending');

  for(let i=0;i<vCount;i++){
    const v = document.createElement('div');
    v.className = 'vote-mini';
    voteStack.appendChild(v);
  }
  mySweetsEl.appendChild(voteStack);
}


function getVoteCountFor(targetUid){
  const obj = state.room?.votes?.[targetUid] || {};
  return Object.keys(obj).length;
}

function roundedStarPath({R=45, r2=20, round=14, k=0.65, points=5}){
  const pts = [];
  for(let i=0;i<points*2;i++){
    const ang = -Math.PI/2 + i*Math.PI/points;
    const rad = (i%2===0) ? R : r2;
    pts.push({x: Math.cos(ang)*rad, y: Math.sin(ang)*rad, outer: i%2===0});
  }

  const prev0 = pts[pts.length-1], cur0 = pts[0];
  const A0 = insetPoint(prev0, cur0, round);
  let d = `M ${A0.x.toFixed(2)} ${A0.y.toFixed(2)} `;

  for(let i=0;i<pts.length;i++){
    const prev = pts[(i-1+pts.length)%pts.length];
    const cur  = pts[i];
    const next = pts[(i+1)%pts.length];

    if(!cur.outer){
      d += `L ${cur.x.toFixed(2)} ${cur.y.toFixed(2)} `;
      continue;
    }

    const A = insetPoint(prev, cur, round);
    const B = insetPoint(next, cur, round);

    d += `L ${A.x.toFixed(2)} ${A.y.toFixed(2)} `;

    const C1 = { x: A.x + (cur.x - A.x)*k, y: A.y + (cur.y - A.y)*k };
    const C2 = { x: B.x + (cur.x - B.x)*k, y: B.y + (cur.y - B.y)*k };

    d += `C ${C1.x.toFixed(2)} ${C1.y.toFixed(2)} `
      +  `${C2.x.toFixed(2)} ${C2.y.toFixed(2)} `
      +  `${B.x.toFixed(2)} ${B.y.toFixed(2)} `;
  }

  d += "Z";
  return d;

  function insetPoint(target, cur, dist){
    const vx = target.x - cur.x, vy = target.y - cur.y;
    const n = Math.hypot(vx, vy) || 1;
    return { x: cur.x + (vx/n)*dist, y: cur.y + (vy/n)*dist };
  }
}

function createRoundedStarSvg(){
  const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
  svg.setAttribute("class","sweets-number-star");
  svg.setAttribute("viewBox","-60 -60 120 120");
  svg.setAttribute("aria-hidden","true");

  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d", roundedStarPath({R:45, r2:20, round:30, k:0.88}));
  path.setAttribute("fill", "#fde047");
  path.setAttribute("stroke", "#111");
  path.setAttribute("stroke-width", "3");
  path.setAttribute("stroke-linejoin", "round");
  path.setAttribute("stroke-linecap", "round");

  svg.appendChild(path);
  return svg;
}
const decidedSweetsAnimated = new Map();
const DECIDED_MOVE_DURATION_MS = 650;
const DECIDED_CENTER_DELAY_MS = DECIDED_MOVE_DURATION_MS + 1800;
const DECIDED_CENTER_MOVE_DURATION_MS = 650;
const decidedCenterMoveAnimated = new Map();
const decidedCenterMoveTimers = new Map();
let centerMoveBatchTimerId = null;
let centerMoveBatchKey = null;
let decidedRoundKey = null;
let decidedRoundStartAt = null;
let lastMySweetsSnapshot = null;
let mySweetsFlyAnimatedFor = null;

function hasCompletedDecidedMove(uid){
  const ts = decidedSweetsAnimated.get(uid);
  if(typeof ts !== 'number') return false;
  return (Date.now() - ts) > DECIDED_MOVE_DURATION_MS;
}

function applyDecidedSweetsMove(items){
  if(!Array.isArray(items) || !items.length) return;
  const playRect = playCircleEl?.getBoundingClientRect?.();
  if(!playRect || !playRect.width || !playRect.height) return;
  const decidedStartAt = getDecidedStartAtForUids(items.map(item => item.uid).filter(Boolean));

  const playCenter = {
    x: playRect.left + playRect.width / 2,
    y: playRect.top + playRect.height / 2,
  };
  const decidedMoveDistance = 80;

  items.forEach(({ uid, sweetsWrap, circle, rotDeg, skipMove }) => {
    if(!sweetsWrap || !circle) return;
    const alreadyAnimated = uid && decidedSweetsAnimated.has(uid);
    const circleRect = circle.getBoundingClientRect();
    const sweetsRect = sweetsWrap.getBoundingClientRect();
    if(!circleRect.width || !circleRect.height || !sweetsRect.width || !sweetsRect.height) return;

    const circleCenter = {
      x: circleRect.left + circleRect.width / 2,
      y: circleRect.top + circleRect.height / 2,
    };
    const sweetsCenter = {
      x: sweetsRect.left + sweetsRect.width / 2,
      y: sweetsRect.top + sweetsRect.height / 2,
    };

    const dx = playCenter.x - circleCenter.x;
    const dy = playCenter.y - circleCenter.y;
    const len = Math.hypot(dx, dy) || 1;
    const targetX = circleCenter.x + (dx / len) * decidedMoveDistance;
    const targetY = circleCenter.y + (dy / len) * decidedMoveDistance;
    const moveX = targetX - sweetsCenter.x;
    const moveY = targetY - sweetsCenter.y;
    const rotRad = (typeof rotDeg === 'number' ? rotDeg : 0) * Math.PI / 180;
    const localMoveX = moveX * Math.cos(-rotRad) - moveY * Math.sin(-rotRad);
    const localMoveY = moveX * Math.sin(-rotRad) + moveY * Math.cos(-rotRad);

    if(skipMove || alreadyAnimated){
      sweetsWrap.classList.add('decided-static');
    }else{
      sweetsWrap.classList.remove('decided-static');
    }
    sweetsWrap.style.setProperty('--decidedMoveX', `${localMoveX}px`);
    sweetsWrap.style.setProperty('--decidedMoveY', `${localMoveY}px`);
    sweetsWrap.classList.add('decided-move');
    if(uid && !decidedSweetsAnimated.has(uid)){
      decidedSweetsAnimated.set(uid, decidedStartAt);
    }

  });
}

function parseRotationDegrees(value){
  if(!value) return 0;
  const num = parseFloat(value);
  return Number.isFinite(num) ? num : 0;
}

function applyCenterMoveToCard(cardEl, hostEl, rotDeg, startedAt){
  if(!cardEl || !playerCircle) return;
  const circleRect = playerCircle.getBoundingClientRect();
  const cardRect = cardEl.getBoundingClientRect();
  if(!circleRect.width || !circleRect.height || !cardRect.width || !cardRect.height) return;

  const circleCenter = {
    x: circleRect.left + circleRect.width / 2,
    y: circleRect.top + circleRect.height / 2,
  };
  const cardCenter = {
    x: cardRect.left + cardRect.width / 2,
    y: cardRect.top + cardRect.height / 2,
  };
  let moveX = circleCenter.x - cardCenter.x;
  let moveY = circleCenter.y - cardCenter.y;

  if(rotDeg){
    const rotRad = rotDeg * Math.PI / 180;
    const localMoveX = moveX * Math.cos(-rotRad) - moveY * Math.sin(-rotRad);
    const localMoveY = moveX * Math.sin(-rotRad) + moveY * Math.cos(-rotRad);
    moveX = localMoveX;
    moveY = localMoveY;
  }

  cardEl.style.setProperty('--centerMoveX', `${moveX}px`);
  cardEl.style.setProperty('--centerMoveY', `${moveY}px`);
  cardEl.classList.add('center-move');
  if(hostEl){
    hostEl.classList.add('center-move-host');
  }

  if(typeof startedAt === 'number' && (Date.now() - startedAt) > DECIDED_CENTER_MOVE_DURATION_MS){
    cardEl.classList.add('center-static');
  }else{
    cardEl.classList.remove('center-static');
  }
}

function applyCenterMoveForUid(uid){
  const startedAt = decidedCenterMoveAnimated.get(uid);
  const tagEl = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"]`);
  if(tagEl){
    const cardEl = tagEl.querySelector('.selected-sweets-card');
    applyCenterMoveToCard(cardEl, tagEl, 0, startedAt);
  }

  const wrapEl = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"]`);
  if(wrapEl){
    const cardEl = wrapEl.querySelector('.sweets-mini');
    const circle = wrapEl.closest('.otherplayerscircle');
    const rotDeg = circle
      ? parseRotationDegrees(getComputedStyle(circle).getPropertyValue('--rotDeg').trim())
      : 0;
    applyCenterMoveToCard(cardEl, wrapEl, rotDeg, startedAt);
  }
}

function getLatestDecidedAt(uids){
  const list = Array.isArray(uids) ? uids : [];
  const key = [...list].sort().join(',');
  if(decidedRoundStartAt && key === decidedRoundKey){
    return decidedRoundStartAt;
  }
  const times = list
    .map(uid => decidedSweetsAnimated.get(uid))
    .filter(ts => typeof ts === 'number');
  return times.length ? Math.max(...times) : Date.now();
}
function getLatestAppliedDecidedAt(uids){
  const list = Array.isArray(uids) ? uids : [];
  const times = list
    .map(uid => decidedSweetsAnimated.get(uid))
    .filter(ts => typeof ts === 'number');
  return times.length ? Math.max(...times) : Date.now();
}

function waitForDecidedTimestamps(uids, timeoutMs = 1200){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return Promise.resolve();
  const start = Date.now();
  return new Promise(resolve => {
    const tick = () => {
      const missing = list.some(uid => !decidedSweetsAnimated.has(uid));
      if(!missing || (Date.now() - start) >= timeoutMs){
        resolve();
        return;
      }
      setTimeout(tick, 50);
    };
    tick();
  });
}


function scheduleCenterMovesForUids(uids){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return;
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'done') return;
  const allCentered = list.every(uid => decidedCenterMoveAnimated.has(uid));
  if(allCentered) return;
  const key = [...list].sort().join(',');
  if(centerMoveBatchTimerId && centerMoveBatchKey === key) return;
  if(centerMoveBatchTimerId){
    clearTimeout(centerMoveBatchTimerId);
    centerMoveBatchTimerId = null;
  }
  centerMoveBatchKey = key;

  const latestDecidedAt = getLatestDecidedAt(list);
  const delay = Math.max(0, latestDecidedAt + DECIDED_CENTER_DELAY_MS - Date.now());

  centerMoveBatchTimerId = setTimeout(() => {
    centerMoveBatchTimerId = null;
    const startedAt = Date.now();
    list.forEach(uid => {
      if(decidedCenterMoveAnimated.has(uid)) return;
      decidedCenterMoveAnimated.set(uid, startedAt);
      applyCenterMoveForUid(uid);
    });
  }, delay);
}

function ensureDecidedRoundStart(uids){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return;
  const key = [...list].sort().join(',');
  if(decidedRoundKey === key) return;
  decidedRoundKey = key;
  decidedRoundStartAt = Date.now();
}

function getDecidedStartAtForUids(uids){
  const list = Array.isArray(uids) ? uids : [];
  const key = [...list].sort().join(',');
  if(decidedRoundStartAt && key === decidedRoundKey){
    return decidedRoundStartAt;
  }
  return Date.now();
}

function cacheMySweetsSnapshot(){
  const card = getMySweetsCard();
  if(!card || mySweetsEl.classList.contains('hidden')) return;
  const rect = mySweetsEl.getBoundingClientRect();
  if(!rect.width || !rect.height) return;
  lastMySweetsSnapshot = {
    rect,
    cardId: card.id,
  };
}

function animateMySweetsToTag(targetEl, card){
  if(!targetEl || !card || !lastMySweetsSnapshot) return;
  if(mySweetsFlyAnimatedFor === card.id) return;
  const srcRect = lastMySweetsSnapshot.rect;
  const tagEl = targetEl.classList.contains('selected-sweets-tag')
    ? targetEl
    : targetEl.closest('.selected-sweets-tag');
  const dstRect = targetEl.getBoundingClientRect();
  if(!srcRect.width || !srcRect.height || !dstRect.width || !dstRect.height) return;
  let moveYAdjust = 0;
  if(tagEl){
    const moveYValue = getComputedStyle(tagEl).getPropertyValue('--sweetsTagMoveY').trim();
    const parsedMoveY = parseFloat(moveYValue);
    if(Number.isFinite(parsedMoveY)){
      moveYAdjust = parsedMoveY;
    }
  }

  const fly = document.createElement('div');
  fly.className = 'sweets-fly-card';
  fly.style.left = `${srcRect.left}px`;
  fly.style.top = `${srcRect.top}px`;
  fly.style.width = `${srcRect.width}px`;
  fly.style.height = `${srcRect.height}px`;

  const img = document.createElement('img');
  img.src = card.img;
  img.alt = `sweets ${card.value ?? ''}`;
  img.onerror = () => { if(card.fallback) img.src = card.fallback; };
  fly.appendChild(img);

  document.body.appendChild(fly);

  const dx = dstRect.left - srcRect.left;
  const dy = (dstRect.top + moveYAdjust) - srcRect.top;
  const scale = dstRect.width / srcRect.width;

  fly.animate([
    { transform:`translate(0px, 0px) scale(1)` },
    { transform:`translate(${dx}px, ${dy}px) scale(${scale})` },
  ], {
    duration: DECIDED_MOVE_DURATION_MS,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => fly.remove();

  mySweetsFlyAnimatedFor = card.id;
}


function renderPlayerCircle(players){
  playerCircle.innerHTML = '';

  // ★ 中央リーダーボード → ★ playCircle の順で復元
  if(leaderboardBoardEl) playerCircle.appendChild(leaderboardBoardEl);
  playerCircle.appendChild(playCircleEl);

  // ★ 人数でボード画像を切り替え（席に着いてる人数）
  updateLeaderboardBoardByPlayerCount(players?.length || 0);

  if (!players.length) return;

  const n = players.length;
  const radius = 42;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);
  const decidedMoveTargets = [];

  const allPassed = allSeatedPlayersPassed();
  const leaderSeat = state.turn?.leaderSeat ?? null;
  const activeSeat = allPassed ? null : (state.turn?.activeSeat ?? null);
  const roundPick = getRoundPick();
  const roundPickActive = roundPick?.phase === 'choose';
  const roundPickCandidates = roundPickActive && Array.isArray(roundPick.candidates)
    ? roundPick.candidates
    : [];
  const roundPickCanSelect = roundPickActive && roundPick?.leaderId === state.userId;
  const decidedUids = getDecidedSweetsUids();
  const started = !!state.room?.gameStarted;
  if(roundPick?.phase === 'done' && decidedUids.length){
    ensureDecidedRoundStart(decidedUids);
  }

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    // ===== 自分 =====
    if(p.id === state.userId){
      const tag = document.createElement('div');
      tag.className = 'player-tag me';
      if(activeSeat === p.seatIndex) tag.classList.add('active-turn');

      tag.textContent = p.name;
      tag.style.left = `${x}%`;
      tag.style.top = `${y}%`;
      tag.dataset.seat = String(p.seatIndex);
      tag.dataset.uid = p.id;

      playerCircle.appendChild(tag);

      if(leaderSeat !== null && leaderSeat === p.seatIndex){
        const chip = document.createElement('div');
        chip.className = 'leader-chip';
        tag.appendChild(chip);
      }
     if(started && decidedUids.includes(state.userId)){
        const sweetsCard = getSweetsCardByUid(state.userId);
        if(sweetsCard){
          const isCollectHidden = collectedSweetsHidden.has(state.userId);
          const selected = document.createElement('div');
          selected.className = 'selected-sweets-tag';
          let decidedStartedAt = decidedSweetsAnimated.get(state.userId);
          if(typeof decidedStartedAt !== 'number'){
            decidedStartedAt = getDecidedStartAtForUids(decidedUids);
            decidedSweetsAnimated.set(state.userId, decidedStartedAt);
          }
          const canAnimateMySweets = !!(lastMySweetsSnapshot && lastMySweetsSnapshot.cardId === sweetsCard.id);
          const animationCompleted = hasCompletedDecidedMove(state.userId);
          const shouldAnimateMySweets = !animationCompleted
            && canAnimateMySweets
            && mySweetsFlyAnimatedFor !== sweetsCard.id;
          if(animationCompleted || !shouldAnimateMySweets){
            selected.classList.add('decided-static');
          }else{
            selected.classList.add('delayed-show');
          }
          if(isCollectHidden){
            selected.classList.add('collect-hidden');
          }
          selected.dataset.sweetsUid = state.userId;
          const cardWrap = document.createElement('div');
          cardWrap.className = 'selected-sweets-card';
          const img = document.createElement('img');
          img.src = SWEETS_BACK_IMG;
          img.alt = `sweets ${sweetsCard.value ?? ''}`;
          img.onerror = () => { if(sweetsCard.fallback) img.src = sweetsCard.fallback; };
          cardWrap.appendChild(img);

         if(typeof sweetsCard.value !== 'undefined'){
            const valueTag = document.createElement('div');
            valueTag.className = 'sweets-number-tag';
            const star = createRoundedStarSvg();
            const valueText = document.createElement('span');
            valueText.className = 'sweets-number-text';
            valueText.textContent = String(sweetsCard.value);
            valueTag.appendChild(star);
            valueTag.appendChild(valueText);
            cardWrap.appendChild(valueTag);
          }
          selected.appendChild(cardWrap);

         const pendingCount = getPendingVoteCount(state.userId);
          const vCount = getDisplayedVoteCountFor(state.userId);
          if(vCount > 0 || pendingCount > 0){
            const voteStack = document.createElement('div');
            voteStack.className = 'vote-stack';
            voteStack.dataset.targetUid = state.userId;
            if(pendingCount > 0) voteStack.classList.add('pending');
            for(let i=0;i<vCount;i++){
              const v = document.createElement('div');
              v.className = 'vote-mini';
              voteStack.appendChild(v);
            }
            selected.appendChild(voteStack);
         }
          tag.appendChild(selected);
          if(shouldAnimateMySweets){
            requestAnimationFrame(() => {
              animateMySweetsToTag(selected, sweetsCard);
            });
          }
          if(!animationCompleted && shouldAnimateMySweets){
            const remaining = Math.max(0, DECIDED_MOVE_DURATION_MS - (Date.now() - decidedStartedAt));
            setTimeout(() => {
              selected.classList.remove('delayed-show');
            }, remaining);
          }else{
            selected.classList.remove('delayed-show');
          }
         if(decidedCenterMoveAnimated.has(state.userId)){
            requestAnimationFrame(() => {
              applyCenterMoveForUid(state.userId);
            });
          }
        }
      }
      return;
    }


// ===== 他プレイヤー =====
const circle = document.createElement('div');
circle.className = 'otherplayerscircle';
circle.style.left = `${x}%`;
circle.style.top  = `${y}%`;

// ★ 中心方向（内側）ベクトル：(-cos, -sin)
const ux = -Math.cos(angle);
const uy = -Math.sin(angle);

// 内側/外側のオフセット（px）
const innerOff = 20;  // カードを内側へ
const outerOff = 44;  // タグを外側へ

circle.style.setProperty('--inX',  `${ux * innerOff}px`);
circle.style.setProperty('--inY',  `${uy * innerOff}px`);
circle.style.setProperty('--outX', `${-ux * outerOff}px`);
circle.style.setProperty('--outY', `${-uy * outerOff}px`);

// ★ カードの「上辺」が中心を向く回転（CSS rotate）
const rotDeg = (Math.atan2(uy, ux) * 180 / Math.PI) + 90;
circle.style.setProperty('--rotDeg', `${rotDeg}deg`);

const tag = document.createElement('div');
tag.className = 'player-tag in-othercircle';
if(activeSeat === p.seatIndex) tag.classList.add('active-turn');

tag.textContent = p.name;
tag.dataset.seat = String(p.seatIndex);
tag.dataset.uid = p.id;

// 追い出しクリックは今まで通り
const onKick = () => {
  if (!state.roomCode) return;
  if (state.seatedTable !== null) return;

  pendingSeatIndexToSteal = p.seatIndex;
  pendingSeatPlayerIdToSteal = p.id;
  kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
  kickDialog.classList.remove('hidden');
};
circle.onclick = (e) => { e.stopPropagation(); onKick(); };
tag.onclick = (e) => { e.stopPropagation(); onKick(); };

circle.appendChild(tag);


// handData は後でミニ手札にも使うので先に取る
const handData = state.hands?.[p.id];
const roleAssigned = !!state.roles?.[p.id];

if(started && roleAssigned){
  // ★ 内側：スイーツ未獲得なら「正体カードだけ中央」、獲得後は「正体＋スイーツ」
  const cardsRow = document.createElement('div');
  cardsRow.className = 'other-cards-row';

  const hasTheirSweets = !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);

  // 正体（裏）
  const roleMini = document.createElement('div');
  roleMini.className = 'role-mini';

  if(!hasTheirSweets){
    // ★ スイーツ獲得前：正体のみ中央
    cardsRow.classList.add('solo');
    cardsRow.appendChild(roleMini);
  }else{
    // ★ スイーツ獲得後：正体＋スイーツ（投票チップも）
    const sweetsWrap = document.createElement('div');
    sweetsWrap.className = 'sweets-wrap';
    sweetsWrap.dataset.sweetsUid = p.id;
    sweetsWrap.classList.toggle('empty', !hasTheirSweets);
    if(collectedSweetsHidden.has(p.id)){
      sweetsWrap.classList.add('collect-hidden');
    }
    if(roundPickCanSelect && roundPickCandidates.includes(p.id)){
      sweetsWrap.classList.add('roundpick-candidate');
      sweetsWrap.classList.add('roundpick-selectable');
      sweetsWrap.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        startRoundPickDrag(e, p.id);
      });
    }
    if(decidedUids.includes(p.id)){
      decidedMoveTargets.push({
        uid: p.id,
        sweetsWrap,
        circle,
        rotDeg,
        skipMove: hasCompletedDecidedMove(p.id),
      });
    }
    if(decidedUids.includes(p.id) && decidedCenterMoveAnimated.has(p.id)){
      requestAnimationFrame(() => {
        applyCenterMoveForUid(p.id);
      });
    }



    const sweetsMini = document.createElement('div');
    sweetsMini.className = 'sweets-mini';
    sweetsMini.classList.toggle('hidden', !hasTheirSweets);
    sweetsWrap.appendChild(sweetsMini);

    // 投票チップ（スイーツ右に重ね）
    const voteStack = document.createElement('div');
    voteStack.className = 'vote-stack';
    voteStack.dataset.targetUid = p.id;
    const pendingCount = getPendingVoteCount(p.id);
    const vCount = getDisplayedVoteCountFor(p.id);
    if(pendingCount > 0) voteStack.classList.add('pending');
    for(let i=0;i<vCount;i++){
      const v = document.createElement('div');
      v.className = 'vote-mini';
      voteStack.appendChild(v);
    }
    sweetsWrap.appendChild(voteStack);

    // 横並び：正体 → スイーツ
    cardsRow.appendChild(roleMini);
    cardsRow.appendChild(sweetsWrap);
  }

  circle.appendChild(cardsRow);
}



// ★ 他プレイヤー：ミニ手札（タグの下に扇状）はそのまま（欲しければ残す）
if (handData && Array.isArray(handData.action) && handData.action.length){
  const miniHand = document.createElement('div');
  miniHand.className = 'mini-hand';

  const count = handData.action.length;
  const spread = 70;
  const base = (count > 1) ? (-spread/2) : 0;

  handData.action.forEach((_, idx2) => {
    const c = document.createElement('div');
    c.className = 'mini-card';

    const angleDeg2 = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
    c.style.transform = `translate(-50%,0) rotate(${angleDeg2}deg)`;
    c.style.zIndex = String(10 + idx2);
    miniHand.appendChild(c);
  });

  tag.appendChild(miniHand);

}
  if(started && handData && Array.isArray(handData.action) && handData.action.length){
    const voteChip = document.createElement('div');
    voteChip.className = 'other-vote-chip';
    voteChip.dataset.voterUid = p.id;
    const voteChips = getPlayerVoteChips(p.id);
    if(voteChips <= 0){
      voteChip.classList.add('is-empty');
    }
    tag.appendChild(voteChip);
  }

playerCircle.appendChild(circle);

if(leaderSeat !== null && leaderSeat === p.seatIndex){
  const chip = document.createElement('div');
  chip.className = 'leader-chip';
  tag.appendChild(chip);
}
  });
 requestAnimationFrame(() => {
    applyDecidedSweetsMove(decidedMoveTargets);
    if(roundPick?.phase === 'done' && decidedUids.length){
      scheduleCenterMovesForUids(decidedUids);
      decidedUids.forEach((uid) => {
        if(decidedCenterMoveAnimated.has(uid)){
          requestAnimationFrame(() => {
            applyCenterMoveForUid(uid);
          });
        }
      });
    }
  });
  scheduleVoteChipAnimations();
  updateActionDeckUI();
  updateSweetsDeckUI();
}

/* =========================
   ターンUI更新
   ========================= */
function updateTurnUI(){
  if(!state.turn || state.game?.status !== 'playing' || allSeatedPlayersPassed()){
    turnBar.classList.add('hidden');
    turnBadge.textContent = 'TURN';
    const wrap = document.querySelector('.my-hand-wrapper');
    wrap?.classList.remove('my-turn-free','my-turn-blocked');
    renderMySweets();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  const activeP = getPlayerBySeat(state.turn.activeSeat);
  const activeName = activeP?.name ?? '？';
  turnBadge.textContent = isTurnBlocked()
    ? 'シャッフル中…'
    : `手番：${activeName}（${state.turn.activeSeat}）`;

  const show = (state.seatedTable !== null);
  turnBar.classList.toggle('hidden', !show);

  const mine = isMyTurn();
  btnPass.disabled = !mine;

  btnDrawSweets.disabled = true;
  btnVote.disabled = true;

  renderHands();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   4つの手番終了要因（今はパスのみ：既存）
   ========================= */
btnPass.addEventListener('click', async ()=>{
  await endTurn('pass');
});

/* =========================
   ★★★ 右下PASS（ラウンド用）
   - 押したら game/passes[uid]=true
   - その時点で次手番へ（pass済みを飛ばす）
   ========================= */
passRoundBtn.addEventListener('click', async ()=>{
  if(!state.roomCode) return;
  if(!isMyTurn()) return;
  if(!myDoneSweetsAndVote()) return;
  if(hasReceivedInstruction()) return;

  const gamePassRef = ref(db, `rooms/${state.roomCode}/game/passes/${state.userId}`);
  await set(gamePassRef, true);

  await endTurn('roundPass');
});

/* =========================
   ★★★ ラウンド終了判定＆選抜
   ========================= */
function requiredPickCountByPlayers(n){
  if(n <= 4) return 2;
  if(n <= 6) return 3;
  return 4; // 7-8
}
function getLeaderPlayerId(){
  const leaderSeat = state.turn?.leaderSeat ?? null;
  if(leaderSeat == null) return null;
  const p = getPlayerBySeat(leaderSeat);
  return p?.id ?? null;
}
function allSeatedPlayersPassed(){
  const pm = getPassedMap();
  if(!latestPlayers.length) return false;
  return latestPlayers.every(p => !!pm?.[p.id]);
}
function getSweetsCardByUid(uid){
  const hd = state.hands?.[uid];
  const arr = hd?.sweets;
  if(Array.isArray(arr) && arr.length) return arr[0];
  return null;
}
function getSweetsVoteStats(){
  // 各プレイヤー（スイーツ持ち）の票数
  const owners = getSweetsOwners();
  return owners.map(uid => ({
    uid,
    votes: getVoteCountFor(uid),
    card: getSweetsCardByUid(uid),
  })).filter(x => !!x.card);
}
function groupByVotesDesc(items){
  const sorted = [...items].sort((a,b)=>{
    if(b.votes !== a.votes) return b.votes - a.votes;
    return 0;
  });
  // 票数ごとにグループ
  const groups = [];
  for(const it of sorted){
    const last = groups[groups.length-1];
    if(!last || last.votes !== it.votes){
      groups.push({ votes: it.votes, items:[it] });
    }else{
      last.items.push(it);
    }
  }
  return groups;
}

/**
 * ホストだけが「全員PASS」を検知して、選抜フローを開始する
 * - roundEnding が false の時だけ開始
 * - 同票超過があれば roundPick.phase='choose' をセット
 * - 超過がなければ roundPick.phase='done' をセットしてイベント発火
 */
async function maybeHostStartRoundEndFlow(){
  if(!state.roomCode) return;
  if(!state.room?.gameStarted) return;
  if(state.game?.roundEnding) return;
  if(!allSeatedPlayersPassed()) return;

  const nPlayers = latestPlayers.length;
  const need = requiredPickCountByPlayers(nPlayers);

  const stats = getSweetsVoteStats();
  if(!stats.length){
    // スイーツが誰も無い場合は何もしない（仕様外）
    await update(ref(db, `rooms/${state.roomCode}/game`), { roundEnding:true, roundPick:{ phase:'done', selected:[], need:0 } });
    return;
  }

  const groups = groupByVotesDesc(stats);

  const selected = [];
  let remaining = need;

  // 上位グループから順に確定していくが、最後に同票で超過するならリーダー選択へ
  for(const g of groups){
    if(remaining <= 0) break;

    if(g.items.length <= remaining){
      selected.push(...g.items.map(x=>x.uid));
      remaining -= g.items.length;
      continue;
    }

    // ここで同票超過（g.items が remaining を超える）
    const leaderId = getLeaderPlayerId();
    const payload = {
      roundEnding: true,
      roundPick: {
        phase: 'choose',
        need: remaining,
        baseSelected: selected,
        candidates: g.items.map(x=>x.uid),
        leaderSeat: state.turn?.leaderSeat ?? null,
        leaderId,
      }
    };
    await update(ref(db, `rooms/${state.roomCode}/game`), payload);
    return;
  }

  // 超過なしで確定
  const finalSelected = selected.slice(0, need);
  await update(ref(db, `rooms/${state.roomCode}/game`), {
    roundEnding: true,
    roundPick: {
      phase: 'done',
      need: 0,
      selected: finalSelected,
      revealFiredKey: null,
    }
  });

}

/* =========================
   ★ 同票超過：リーダー選択UI
   - game.roundPick.phase === 'choose' のとき
   - leaderId の人だけクリック可能
   ========================= */
function getRoundPick(){
  return state.game?.roundPick || null;
}
function isLeaderMe(){
  const rp = getRoundPick();
  return !!rp && (rp.leaderId === state.userId);
}
function getDecidedSweetsUids(){
  const rp = getRoundPick();
  if(!rp) return [];
  if(rp.phase === 'choose'){
    return Array.isArray(rp.baseSelected) ? rp.baseSelected : [];
  }
  if(rp.phase === 'done'){
    return Array.isArray(rp.selected) ? rp.selected : [];
  }
  return [];
}

function resetCollectedSweetsHiddenCache(){
  if(!state.game?.roundEnding){
    collectedSweetsHidden.clear();
    decidedSweetsAnimated.clear();
    decidedCenterMoveAnimated.clear();
    decidedCenterMoveTimers.forEach((timerId) => clearTimeout(timerId));
    decidedCenterMoveTimers.clear();
    if(centerMoveBatchTimerId){
      clearTimeout(centerMoveBatchTimerId);
      centerMoveBatchTimerId = null;
    }
    centerMoveBatchKey = null;
    decidedRoundKey = null;
    decidedRoundStartAt = null;
    document.querySelectorAll('.collect-hidden').forEach(el => {
      el.classList.remove('collect-hidden');
    });
  }
}





const roundPickDrag = {
  active:false,
  uid:null,
  ghost:null,
  offsetX:0,
  offsetY:0,
  sourceEl:null,
  sourceHidden:false,
  sourceVisibility:'',
  voteChipHidden:false,
  voteChipVisibility:'',
};

function canLeaderDragPick(uid){
  const rp = getRoundPick();
  const candidates = rp && Array.isArray(rp.candidates) ? rp.candidates : [];
  return !!rp && rp.phase === 'choose' && rp.leaderId === state.userId && candidates.includes(uid);
}

function startRoundPickDrag(e, uid){
  if(!canLeaderDragPick(uid)) return;
  e.preventDefault();

  const source = e.currentTarget;
  const r = source.getBoundingClientRect();
  roundPickDrag.active = true;
  roundPickDrag.uid = uid;
  roundPickDrag.offsetX = e.clientX - r.left;
  roundPickDrag.offsetY = e.clientY - r.top;
  roundPickDrag.sourceEl = source;
  roundPickDrag.sourceHidden = true;
  roundPickDrag.sourceVisibility = source.style.visibility;
  source.style.visibility = 'hidden';
  if(uid === state.userId){
    roundPickDrag.voteChipHidden = true;
    roundPickDrag.voteChipVisibility = myVoteChipEl.style.visibility;
    myVoteChipEl.style.visibility = 'hidden';
  }

  const ghost = document.createElement('div');
  ghost.className = 'roundpick-dragging';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${source.offsetWidth}px`;
  ghost.style.height = `${source.offsetHeight}px`;
  ghost.style.transformOrigin = 'center';

  const circle = source.closest('.otherplayerscircle');
  const rotDeg = circle ? getComputedStyle(circle).getPropertyValue('--rotDeg').trim() : '0deg';
  if(uid !== state.userId && rotDeg){
    ghost.style.transform = `rotate(${rotDeg})`;
  }

  const card = getSweetsCardByUid(uid);
  const faceImg = card?.img || card?.fallback || SWEETS_BACK_IMG;
  const bgImg = (uid === state.userId) ? faceImg : SWEETS_BACK_IMG;
  ghost.style.backgroundImage = `url('${bgImg}')`;

  document.body.appendChild(ghost);
  roundPickDrag.ghost = ghost;

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onRoundPickDragMove);
  ghost.addEventListener('pointerup', onRoundPickDragEnd);
  ghost.addEventListener('pointercancel', onRoundPickDragEnd);
}

function onRoundPickDragMove(e){
  if(!roundPickDrag.active || !roundPickDrag.ghost) return;
  const x = e.clientX - roundPickDrag.offsetX;
  const y = e.clientY - roundPickDrag.offsetY;
  roundPickDrag.ghost.style.left = `${x}px`;
  roundPickDrag.ghost.style.top  = `${y}px`;

  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (e.clientX >= pr.left && e.clientX <= pr.right && e.clientY >= pr.top && e.clientY <= pr.bottom);
  playCircleEl.classList.toggle('roundpick-target', inPlay);
}

async function onRoundPickDragEnd(e){
  if(!roundPickDrag.active) return;

  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (e.clientX >= pr.left && e.clientX <= pr.right && e.clientY >= pr.top && e.clientY <= pr.bottom);
  const uid = roundPickDrag.uid;

  cleanupRoundPickDrag();

  if(inPlay && uid){
    await leaderPickOne(uid);
  }
}

function cleanupRoundPickDrag(){
  playCircleEl.classList.remove('roundpick-target');
  if(roundPickDrag.ghost){
    roundPickDrag.ghost.removeEventListener('pointermove', onRoundPickDragMove);
    roundPickDrag.ghost.removeEventListener('pointerup', onRoundPickDragEnd);
    roundPickDrag.ghost.removeEventListener('pointercancel', onRoundPickDragEnd);
    roundPickDrag.ghost.remove();
  }
  if(roundPickDrag.sourceEl && roundPickDrag.sourceHidden){
    roundPickDrag.sourceEl.style.visibility = roundPickDrag.sourceVisibility || '';
  }
  if(roundPickDrag.voteChipHidden){
    myVoteChipEl.style.visibility = roundPickDrag.voteChipVisibility || '';
  }
  roundPickDrag.active = false;
  roundPickDrag.uid = null;
  roundPickDrag.ghost = null;
  roundPickDrag.offsetX = 0;
  roundPickDrag.offsetY = 0;
  roundPickDrag.sourceEl = null;
  roundPickDrag.sourceHidden = false;
  roundPickDrag.sourceVisibility = '';
  roundPickDrag.voteChipHidden = false;
  roundPickDrag.voteChipVisibility = '';
}
function updateRoundPickUI(){
  const rp = getRoundPick();
  const roundPickActive = !!rp && rp.phase === 'choose';
  const candidates = roundPickActive && Array.isArray(rp.candidates) ? rp.candidates : [];
  const leaderCanSelect = roundPickActive && rp.leaderId === state.userId;
  const meIsCandidate = leaderCanSelect && candidates.includes(state.userId);
  const meCanSelect = leaderCanSelect && meIsCandidate;

  mySweetsEl.classList.toggle('roundpick-candidate', meIsCandidate);
  mySweetsEl.classList.toggle('roundpick-selectable', meCanSelect);

  if(meCanSelect){
    mySweetsEl.onpointerdown = (e) => {
      e.stopPropagation();
      startRoundPickDrag(e, state.userId);
    };
  }else{
    mySweetsEl.onpointerdown = null;
  }

}
async function leaderPickOne(uid){
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'choose') return;
  if(rp.leaderId !== state.userId) return;

  const need = Number(rp.need || 0);
  if(need <= 0) return;

  const baseSelected = Array.isArray(rp.baseSelected) ? rp.baseSelected : [];
  const candidates = Array.isArray(rp.candidates) ? rp.candidates : [];

  if(!candidates.includes(uid)) return;

  const nextSelected = [...baseSelected, uid];
  const nextCandidates = candidates.filter(x=>x !== uid);
  const nextNeed = need - 1;

  if(nextNeed > 0){
    await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
      phase:'choose',
      need: nextNeed,
      baseSelected: nextSelected,
      candidates: nextCandidates,
      leaderSeat: rp.leaderSeat ?? null,
      leaderId: rp.leaderId ?? null,
    });
    return;
  }

  await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
    phase:'done',
    need: 0,
    selected: nextSelected,
    revealFiredKey: null,
  });

  // ホストがイベント発火するのが原則だが、念のためリーダーでも発火できるようにする（重複は回避）
  // → ホスト側は roundPick.phase='done' を見て発火しない設計にしていないので、ここは発火しない
  //    代わりに、ホストが subscribeGame で roundEnding=true を見て発火済みのケースがあるので、
  //    ここでは「ホストに任せる」。
}

/* ★ ホスト：roundPick が done になったらイベント発火（未発火なら） */
async function maybeHostFireRoundRevealAfterLeaderPick(){
 if(!state.isHost) return;
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'done') return;
  if(!state.game?.roundEnding) return;

  const selected = Array.isArray(rp.selected) ? rp.selected : [];
  const key = selected.join(',');
  if(rp.revealFiredKey === key) return;

  await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
    revealFiredKey: key,
  });

  const cards = selected.map(uid => getSweetsCardByUid(uid)).filter(Boolean);
  await emitEvent({ type:'roundRevealSweets', selectedUids: selected, cards });
}


/* =========================
   ★★★ ラウンド終了演出（全員）
   - 選ばれたスイーツ（裏）を中央へ集める
   - 中央でシャッフルっぽい動き
   - 表にして中央に横並び（折り返しなし）
   - 3秒表示後、消える
   ========================= */
let _roundAnimRunning = false;
function getRoundCollectCenter(){
  const r = playCircleEl?.getBoundingClientRect?.();
  if(r && r.width && r.height){
    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
  }
  return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
}
function getSweetsSourceRect(uid, fallback){
  const el = document.querySelector(`[data-sweets-uid="${uid}"]`);
  if(el){
    const r = el.getBoundingClientRect();
    if(r && r.width && r.height){
      return r;
    }
  }
  return fallback;
}

function toggleCollectHiddenForUids(uids, hidden){
  const list = Array.isArray(uids) ? uids : [];
  list.forEach(uid => {
    const targets = document.querySelectorAll(`[data-sweets-uid="${uid}"]`);
    targets.forEach(el => {
      el.classList.toggle('collect-hidden', hidden);
    });
    if(hidden){
      collectedSweetsHidden.add(uid);
    }
  });
}


/* =========================
   ★★★ ラウンド終了：回収→シャッフル→拡大表示（全員）
   - ゴースト防止：元位置DOMを collect-hidden で不可視化
   - 二重防止：stopRoundEndFx() + token で排他
   ========================= */

const roundEndFx = {
  token: 0,
  timers: new Set(),
  anims: new Set(),
  nodes: new Set(),
  restores: [],
};

function _fxRememberRestore(fn){
  roundEndFx.restores.push(fn);
}
function _fxSetTimeout(fn, ms, token){
  const id = setTimeout(() => {
    roundEndFx.timers.delete(id);
    if(token !== roundEndFx.token) return;
    fn();
  }, ms);
  roundEndFx.timers.add(id);
  return id;
}
function _fxSleep(ms, token){
  return new Promise(resolve => _fxSetTimeout(resolve, ms, token));
}

/** ★ 強制停止＆後始末（“前の”演出を完全に殺す） */
function stopRoundEndFx(){
  // token更新（これで進行中awaitは全部無効化）
  roundEndFx.token++;

  // timers
  for(const t of roundEndFx.timers) clearTimeout(t);
  roundEndFx.timers.clear();

  // anims
  for(const a of roundEndFx.anims){
    try{ a.cancel(); }catch(_){}
  }
  roundEndFx.anims.clear();

  // nodes
  for(const n of roundEndFx.nodes){
    try{ n.remove(); }catch(_){}
  }
  roundEndFx.nodes.clear();

  // restore（途中停止時だけ元に戻す）
  for(const r of roundEndFx.restores){
    try{ r(); }catch(_){}
  }
  roundEndFx.restores = [];

  // overlay掃除（ゴースト残し防止）
  try{
    roundRevealRow.innerHTML = '';
    roundRevealOverlay.classList.add('hidden');
  }catch(_){}
  resetRoundRevealState();
}


/** ★ “元位置”として最優先で使うDOMを探す（ゴースト防止のため） */
function _pickOriginElForUid(uid){
  // 1) decided表示（タグ上の selected-sweets-tag）
  let el = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"]`);
  if(el) return el;

  // 2) 他プレイヤーのスイーツ枠（sweets-wrap）
  el = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"]`);
  if(el) return el;

  // 3) 自分の手元スイーツ
  if(uid === state.userId && mySweetsEl && !mySweetsEl.classList.contains('hidden')){
    return mySweetsEl;
  }

  return null;
}

/** ★ 元位置を不可視化（“ゴースト”＝残像防止） */
function _hideOriginVisual(uid, originEl){
  if(!originEl) return;

  // sweets-wrap / selected-sweets-tag は既存CSSの collect-hidden を使う
  if(originEl.classList.contains('sweets-wrap') || originEl.classList.contains('selected-sweets-tag')){
    if(!originEl.classList.contains('collect-hidden')){
      originEl.classList.add('collect-hidden');
      collectedSweetsHidden.add(uid);
      _fxRememberRestore(()=> {
        originEl.classList.remove('collect-hidden');
        collectedSweetsHidden.delete(uid);
      });
    }
    return;
  }

  // mySweetsEl など：visibilityで消す（レイアウトは保持）
  const prevVis = originEl.style.visibility;
  originEl.style.visibility = 'hidden';
  collectedSweetsHidden.add(uid);
  _fxRememberRestore(()=> {
    originEl.style.visibility = prevVis;
    collectedSweetsHidden.delete(uid);
  });
}

/** ★ 回収カード（裏）を作成 */
function _createCollectCardAtRect(rect){
  const node = document.createElement('div');
  node.className = 'collect-card';
  node.style.left = `${rect.left}px`;
  node.style.top  = `${rect.top}px`;
  node.style.width  = `${rect.width}px`;
  node.style.height = `${rect.height}px`;
  // collect-card の background はCSSで swsweetsura.jpg になってる前提（既存のまま）
  document.body.appendChild(node);
  roundEndFx.nodes.add(node);
  return node;
}

/** ★ 中央座標（PLAYを中心に。無理なら画面中央） */
function _getCenterPoint(){
  const pr = playCircleEl?.getBoundingClientRect?.();
  if(pr && pr.width && pr.height){
    return { x: pr.left + pr.width/2, y: pr.top + pr.height/2 };
  }
  return { x: window.innerWidth/2, y: window.innerHeight/2 };
}

/** ★ シャッフル演出（中央） */
/** ★ シャッフル演出（sweetshuffle1） */
async function _runSweetShuffle1(token){
  const stage = document.createElement('div');
  stage.className = 'sweets-shuffle-stage';
  document.body.appendChild(stage);
  roundEndFx.nodes.add(stage);

  const OFFSET_X = 4;
  const OFFSET_Y = 4;
  const OUT_X = 78;
  const TILT_BASE = 5;
  const TILT_MORE = 5;
  const DUR_OUT = 220;
  const DUR_IN = 220;
  const PAUSE = 20;
  const LOOPS = 3;
  const base = 'translate(-50%,-50%)';
  const baseFront = `${base} translate(0px,0px) rotate(${TILT_BASE}deg)`;
  const baseBack = `${base} translate(${OFFSET_X}px,${OFFSET_Y}px) rotate(${TILT_BASE}deg)`;
  const outTransform = `${base} translate(${OUT_X}px,0px) rotate(${TILT_BASE + TILT_MORE}deg)`;

  const back = document.createElement('div');
  back.className = 'sweets-shuffle-card';
  back.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  back.style.zIndex = '1';
  back.style.transform = baseBack;

  const front = document.createElement('div');
  front.className = 'sweets-shuffle-card';
  front.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  front.style.zIndex = '2';
  front.style.transform = baseFront;

  stage.appendChild(back);
  stage.appendChild(front);

  const animateOnce = (el, keyframes, options) => {
    const anim = el.animate(keyframes, options);
    roundEndFx.anims.add(anim);
    return new Promise(resolve => {
      anim.onfinish = () => {
        roundEndFx.anims.delete(anim);
        resolve();
      };
      anim.oncancel = () => {
        roundEndFx.anims.delete(anim);
        resolve();
      };
    });
  };

  let frontEl = front;
  let backEl = back;

  for(let i=0;i<LOOPS;i++){
    if(token !== roundEndFx.token) return;
    await animateOnce(frontEl, [
      { transform: baseFront },
      { transform: outTransform },
    ], {
      duration: DUR_OUT,
      easing: 'ease-in-out',
      fill: 'forwards',
    });

    if(token !== roundEndFx.token) return;
    frontEl.style.transform = outTransform;
    frontEl.style.zIndex = '1';
    backEl.style.zIndex = '2';
    backEl.style.transform = baseFront;

    await animateOnce(frontEl, [
      { transform: outTransform },
      { transform: baseBack },
    ], {
      duration: DUR_IN,
      easing: 'ease-in-out',
      fill: 'forwards',
    });

    if(token !== roundEndFx.token) return;
    frontEl.style.transform = baseBack;

    const tmp = frontEl;
    frontEl = backEl;
    backEl = tmp;

    await new Promise(resolve => setTimeout(resolve, PAUSE));
  }

  if(token !== roundEndFx.token) return;
  stage.remove();
  roundEndFx.nodes.delete(stage);
}

async function getSweetsDeckRectForMiniShuffle(){
  if(!sweetsDeckUI) return null;
  let rect = sweetsDeckUI.getBoundingClientRect();
  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }

  const wasCenterHidden = centerDecksEl.classList.contains('hidden');
  const wasSweetsHidden = sweetsDeckUI.classList.contains('hidden');
  const prevCenterVisibility = centerDecksEl.style.visibility;
  const prevSweetsVisibility = sweetsDeckUI.style.visibility;

  centerDecksEl.classList.remove('hidden');
  sweetsDeckUI.classList.remove('hidden');
  centerDecksEl.style.visibility = 'hidden';
  sweetsDeckUI.style.visibility = 'hidden';

  for(let i=0;i<6;i++){
    rect = sweetsDeckUI.getBoundingClientRect();
    if(rect && rect.width > 0 && rect.height > 0){
      break;
    }
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
  }

  centerDecksEl.style.visibility = prevCenterVisibility;
  sweetsDeckUI.style.visibility = prevSweetsVisibility;
  if(wasSweetsHidden) sweetsDeckUI.classList.add('hidden');
  if(wasCenterHidden) centerDecksEl.classList.add('hidden');

  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }
  return null;
}

async function getSweetsExcludedDeckRectForMiniShuffle(){
  if(!sweetsExcludedDeckUI) return null;
  let rect = sweetsExcludedDeckUI.getBoundingClientRect();
  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }

  const wasHidden = sweetsExcludedDeckUI.classList.contains('hidden');
  const prevVisibility = sweetsExcludedDeckUI.style.visibility;
  const prevAnimating = sweetsExcludeAnimating;

 sweetsExcludedDeckUI.style.visibility = prevVisibility;
  sweetsExcludeAnimating = prevAnimating;
  if(wasHidden){
    sweetsExcludedDeckUI.classList.add('hidden');
  } else {
    sweetsExcludedDeckUI.classList.remove('hidden');
  }
  updateSweetsDeckUI();

  for(let i=0;i<6;i++){
    rect = sweetsExcludedDeckUI.getBoundingClientRect();
    if(rect && rect.width > 0 && rect.height > 0){
      break;
    }
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
  }

  sweetsExcludedDeckUI.style.visibility = prevVisibility;
  sweetsExcludeAnimating = prevAnimating;
  if(wasHidden) sweetsExcludedDeckUI.classList.add('hidden');

  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }
  return null;
}

function getPlayerCountForSweetsSplit(){
  const seatOrder = state.game?.seatOrder;
  if(Array.isArray(seatOrder) && seatOrder.length){
    return seatOrder.length;
  }
  if(Array.isArray(latestPlayers) && latestPlayers.length){
    return latestPlayers.length;
  }
  const tables = state.room?.tables;
  if(tables && typeof tables === 'object'){
    return Object.values(tables).filter(t => t && t.playerId).length;
  }
  return 0;
}

async function getSweetsDeckForMiniShuffle(){
  const deck = state.room?.decks?.sweets;
  if(Array.isArray(deck) && deck.length){
    return deck;
  }
  if(!state.roomCode) return deck;
  try{
    const snap = await get(ref(db, `rooms/${state.roomCode}/decks/sweets`));
    const data = snap.val();
    if(Array.isArray(data)) return data;
  }catch(_){}
  return deck;
}

async function animateSweetsExcludeMove(fromRect, toRect, totalCount, keepCount){
  const moveCount = Math.max(0, totalCount - keepCount);
  if(moveCount <= 0) return;

  sweetsExcludeAnimating = true;
  setSweetsCountOverrides(totalCount, 0);
  updateSweetsDeckUI();

  const dx = toRect.left - fromRect.left;
  const dy = toRect.top - fromRect.top;
  const duration = 260;

  const card = document.createElement('div');
  card.className = 'sweets-move-card';
  card.style.width = `${fromRect.width}px`;
  card.style.height = `${fromRect.height}px`;
  card.style.left = `${fromRect.left}px`;
  card.style.top = `${fromRect.top}px`;
  document.body.appendChild(card);

  const anim = card.animate([
    { transform: 'translate(0px,0px) rotate(0deg)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(90deg)` },
  ], {
    duration,
    easing: 'ease-in-out',
    fill: 'forwards',
  });

  await new Promise(resolve => {
    anim.onfinish = resolve;
    anim.oncancel = resolve;
  });
  card.remove();

  sweetsExcludeAnimating = false;
  setSweetsCountOverrides(keepCount, moveCount, 5000);
  updateSweetsDeckUI();
}

async function maybeHostApplySweetsSplit(deck, playerCount){
  if(!state.isHost || !state.roomCode) return;
  const currentExcluded = state.room?.decks?.sweetsExcluded;
  if(Array.isArray(currentExcluded) && currentExcluded.length) return;
  const keepCount = clamp(playerCount + 2, 0, Array.isArray(deck) ? deck.length : 0);
  if(!Array.isArray(deck) || deck.length <= keepCount) return;

  const { sweets, excluded } = splitSweetsDeck(deck, playerCount);
  const decksRef = ref(db, `rooms/${state.roomCode}/decks`);
  await update(decksRef, { sweets, sweetsExcluded: excluded });
}

async function runMiniSweetsShuffleAtStart(){
  if(miniShuffleRunning) return;
  turnBlockedByShuffle = true;
  updateTurnUI();
  try{
    const rect = await getSweetsDeckRectForMiniShuffle();
    if(!rect){
      const deck = await getSweetsDeckForMiniShuffle();
      const totalCount = Array.isArray(deck) ? deck.length : 0;
      const playerCount = getPlayerCountForSweetsSplit();
      const keepCount = clamp(playerCount + 2, 0, totalCount);
      const moveCount = Math.max(0, totalCount - keepCount);
      if(moveCount > 0){
        sweetsExcludeAnimating = true;
        setSweetsCountOverrides(keepCount, moveCount, 5000);
        updateSweetsDeckUI();
        sweetsExcludeAnimating = false;
      }
      await maybeHostApplySweetsSplit(deck, playerCount);
      await hostGrantTurnAfterMiniShuffle();
      return;
    }

    const token = ++miniShuffleToken;
    miniShuffleRunning = true;
    updateSweetsDeckUI();

    const cardSample = sweetsDeckUI.querySelector('.card');
    const cardStyle = cardSample ? getComputedStyle(cardSample) : null;
    const cardRadius = cardStyle?.borderRadius || '7px';
    const cardBorder = cardStyle?.border || '1px solid rgba(0,0,0,.18)';
    const cardShadow = cardStyle?.boxShadow || 'none';

    const stage = document.createElement('div');
    stage.className = 'sweets-shuffle-stage';
    stage.style.left = `${rect.left + rect.width / 2}px`;
    stage.style.top = `${rect.top + rect.height / 2}px`;
    stage.style.width = `${rect.width}px`;
    stage.style.height = `${rect.height}px`;
    document.body.appendChild(stage);

    try{
      const BASE_W = 120;
      const BASE_H = 170;
      const scale = Math.min(rect.width / BASE_W, rect.height / BASE_H);
      const OFFSET_X = 4 * scale;
      const OFFSET_Y = 4 * scale;
      const OUT_X = 78 * scale;
      const TILT_BASE = 5;
      const TILT_MORE = 5;
      const DUR_OUT = 220;
      const DUR_IN = 220;
      const PAUSE = 20;
      const LOOPS = 3;
      const base = 'translate(-50%,-50%)';
      const baseFront = `${base} translate(0px,0px) rotate(${TILT_BASE}deg)`;
      const baseBack = `${base} translate(${OFFSET_X}px,${OFFSET_Y}px) rotate(${TILT_BASE}deg)`;
      const outTransform = `${base} translate(${OUT_X}px,0px) rotate(${TILT_BASE + TILT_MORE}deg)`;

      const createCard = (zIndex, transform) => {
        const el = document.createElement('div');
        el.className = 'sweets-shuffle-card';
        el.style.width = `${rect.width}px`;
        el.style.height = `${rect.height}px`;
        el.style.borderRadius = cardRadius;
        el.style.border = cardBorder;
        el.style.boxShadow = cardShadow;
        el.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
        el.style.zIndex = String(zIndex);
        el.style.transform = transform;
        return el;
      };

      const back = createCard(1, baseBack);
      const front = createCard(2, baseFront);
      stage.appendChild(back);
      stage.appendChild(front);

      const animateOnce = (el, keyframes, options) => new Promise(resolve => {
        const anim = el.animate(keyframes, options);
        anim.onfinish = resolve;
        anim.oncancel = resolve;
      });

      let frontEl = front;
      let backEl = back;

      for(let i=0;i<LOOPS;i++){
        if(token !== miniShuffleToken) return;
        await animateOnce(frontEl, [
          { transform: baseFront },
          { transform: outTransform },
        ], {
          duration: DUR_OUT,
          easing: 'ease-in-out',
          fill: 'forwards',
        });

        if(token !== miniShuffleToken) return;
        frontEl.style.transform = outTransform;
        frontEl.style.zIndex = '1';
        backEl.style.zIndex = '2';
        backEl.style.transform = baseFront;

        await animateOnce(frontEl, [
          { transform: outTransform },
          { transform: baseBack },
        ], {
          duration: DUR_IN,
          easing: 'ease-in-out',
          fill: 'forwards',
        });

        if(token !== miniShuffleToken) return;
        frontEl.style.transform = baseBack;

        const tmp = frontEl;
        frontEl = backEl;
        backEl = tmp;

        await new Promise(resolve => setTimeout(resolve, PAUSE));
      }
    } finally {
      stage.remove();
      if(token === miniShuffleToken){
        miniShuffleRunning = false;
        updateSweetsDeckUI();
      }
    }
    if(token !== miniShuffleToken) return;

    const deck = await getSweetsDeckForMiniShuffle();
    const totalCount = Array.isArray(deck) ? deck.length : 0;
    const playerCount = getPlayerCountForSweetsSplit();
    const keepCount = clamp(playerCount + 2, 0, totalCount);
    const moveCount = Math.max(0, totalCount - keepCount);

    const targetRect = await getSweetsExcludedDeckRectForMiniShuffle();
    if(rect && targetRect && moveCount > 0){
      await animateSweetsExcludeMove(rect, targetRect, totalCount, keepCount);
    } else if(moveCount > 0){
      setSweetsCountOverrides(keepCount, moveCount, 5000);
      updateSweetsDeckUI();
    }

    await maybeHostApplySweetsSplit(deck, playerCount);
    if(token !== miniShuffleToken) return;
    await hostGrantTurnAfterMiniShuffle();
  } finally {
    turnBlockedByShuffle = false;
    updateTurnUI();
  }
}

async function animateRoundEndReveal(cards, selectedUids){
  if(_roundAnimRunning){
    stopRoundEndFx();
    _roundAnimRunning = false;
  }
  _roundAnimRunning = true;

  try{
    stopRoundEndFx();
    const token = roundEndFx.token;

    document.querySelectorAll('.collect-card').forEach(el => el.remove());
    roundRevealRow.innerHTML = '';
    roundRevealOverlay.classList.add('hidden');

    const uids = Array.isArray(selectedUids) ? selectedUids : [];
    ensureDecidedRoundStart(uids);
    scheduleCenterMovesForUids(uids);

    await waitForDecidedTimestamps(uids);
    const latestDecidedAt = getLatestAppliedDecidedAt(uids);    const centerMoveStartAt = latestDecidedAt + DECIDED_CENTER_DELAY_MS;
    const shuffleStartAt = centerMoveStartAt + 1200;
    const waitMs = Math.max(0, shuffleStartAt - Date.now());
    if(waitMs > 0){
      await new Promise(resolve => setTimeout(resolve, waitMs));
    }
    if(token !== roundEndFx.token) return;

    uids.forEach(uid => {
      const origin = _pickOriginElForUid(uid);
      _hideOriginVisual(uid, origin);
    });

    await _runSweetShuffle1(token);
    if(token !== roundEndFx.token) return;

    roundRevealRow.innerHTML = '';
    (Array.isArray(cards) ? cards : []).forEach(card => {
      const el = document.createElement('div');
      el.className = 'roundreveal-card';
      const img = document.createElement('img');
      img.src = card?.img || card?.fallback || SWEETS_BACK_IMG;
      img.alt = `sweets ${card?.value ?? ''}`;
      img.onerror = () => { if(card?.fallback) img.src = card.fallback; };
     el.appendChild(img);
      roundRevealRow.appendChild(el);
    });
    markRoundRevealStarted();
    roundRevealOverlay.classList.remove('hidden');

    await new Promise(resolve => setTimeout(resolve, 2800));
    if(token !== roundEndFx.token) return;

    roundRevealOverlay.classList.add('hidden');
    roundRevealRow.innerHTML = '';
    markRoundRevealFinished();

    for(const restore of roundEndFx.restores){
      try{ restore(); }catch(_){}
    }
    roundEndFx.restores = [];
  } finally {
    _roundAnimRunning = false;
    if(roundRevealState.started && !roundRevealState.finished){
      markRoundRevealFinished();
    }
  }
}

/* =========================
   ドラッグ＆ドロップ（アクションカード）
   ========================= */
const drag = {
  active:false,
  card:null,
  el:null,
  offsetX:0, offsetY:0,
  originRect:null,
  lastClientX:null,
  lastClientY:null,
};

function canUseOnPlayCircle(card){
  if(card.kind !== 'instruction') return true;
  if(INSTRUCTION_NEED_TARGET.has(card.name)) return false;
  return true;
}
function canUseOnOtherPlayer(card){
  if(card.kind !== 'instruction') return false;
  return true;
}
function canStartUseCard(cardObj){
  if(!isMyTurn()) return false;
  if(getRoundPick()?.phase === 'choose') return false;
  const receivedExists = hasReceivedInstruction();
  if(!receivedExists) return true;
  const isReceived = (getMyReceivedCard()?.id === cardObj.id);
  if(isReceived) return true;

  const isIgnore = (cardObj.kind === 'instruction' && cardObj.name === '無視');
  return isIgnore;
}

let hoverOtherCircle = null;
function clearOtherCircleHint(){
  if(!hoverOtherCircle) return;
  hoverOtherCircle.classList.remove('hint-ok','hint-ng');
  hoverOtherCircle = null;
}
function updateOtherCircleHint(x,y,cardObj){
  clearOtherCircleHint();
  const el = document.elementFromPoint(x,y);
  const c = el?.closest?.('.otherplayerscircle');
  if(!c) return;

  const ok = canUseOnOtherPlayer(cardObj);
  c.classList.add(ok ? 'hint-ok' : 'hint-ng');
  hoverOtherCircle = c;
}

function getDropTarget(x,y){
  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (x>=pr.left && x<=pr.right && y>=pr.top && y<=pr.bottom);
  if(inPlay) return { type:'playCircle' };

  const el = document.elementFromPoint(x,y);
  const circle = el?.closest?.('.otherplayerscircle');
  if(circle){
    const tag = circle.querySelector('.player-tag');
    if(tag){
      const seat = Number(tag.dataset.seat);
      const uid = tag.dataset.uid;
      return { type:'otherCircle', seat, uid };
    }
  }

  const tag = el?.closest?.('.player-tag');
  if(tag){
    const seat = Number(tag.dataset.seat);
    const uid = tag.dataset.uid;
    return { type:'playerTag', seat, uid };
  }

  return { type:'none' };
}

function startDragCard(e, cardObj, cardEl){
  if(!canStartUseCard(cardObj)) return;
  e.preventDefault();

  drag.active = true;
  drag.card = cardObj;
  drag.el = cardEl;
  drag.originRect = cardEl.getBoundingClientRect();

  const r = drag.originRect;
  drag.offsetX = e.clientX - r.left;
  drag.offsetY = e.clientY - r.top;
  drag.lastClientX = e.clientX;
  drag.lastClientY = e.clientY;

  cardEl.classList.add('dragging');
  cardEl.style.left = `${r.left}px`;
  cardEl.style.top  = `${r.top}px`;

  cardEl.setPointerCapture(e.pointerId);

  playCircleEl.classList.toggle('hint-ok', canUseOnPlayCircle(cardObj));
  playCircleEl.classList.toggle('hint-ng', !canUseOnPlayCircle(cardObj));

  cardEl.addEventListener('pointermove', onDragMove);
  cardEl.addEventListener('pointerup', onDragEnd);
  cardEl.addEventListener('pointercancel', onDragEnd);
}

function onDragMove(e){
  if(!drag.active) return;
  const x = e.clientX - drag.offsetX;
  const y = e.clientY - drag.offsetY;
  drag.lastClientX = e.clientX;
  drag.lastClientY = e.clientY;
  drag.el.style.left = `${x}px`;
  drag.el.style.top  = `${y}px`;

  updateOtherCircleHint(e.clientX, e.clientY, drag.card);
}

async function onDragEnd(e){
  if(!drag.active) return;

  const cardObj = drag.card;
  const drop = getDropTarget(e.clientX, e.clientY);

  playCircleEl.classList.remove('hint-ok','hint-ng');
  clearOtherCircleHint();

  if(drop.type === 'playCircle'){
    const ok = canUseOnPlayCircle(cardObj);
    if(!ok){ snapBack(); return; }

    await playCardToCircle(cardObj);
    cleanupDrag();
    return;
  }

  if(drop.type === 'otherCircle'){
    if(cardObj.kind !== 'instruction'){ snapBack(); return; }
    await giveInstructionToPlayer(cardObj, drop.seat, drop.uid);
    cleanupDrag();
    return;
  }

  if(drop.type === 'playerTag'){
    const isSelf = (drop.uid === state.userId);
    if(cardObj.kind !== 'instruction'){ snapBack(); return; }
    if(isSelf && !INSTRUCTION_CAN_SELF.has(cardObj.name)){ snapBack(); return; }
    if(isSelf){
      await playCardToCircle(cardObj);
      cleanupDrag();
      return;
    }
    snapBack();
    return;
  }

  snapBack();
}

function snapBack(){
  const el = drag.el;
  el.animate([
    { transform:'translate(0,0) scale(1.02)' },
    { transform:'translate(0,0) scale(1.0)' }
  ], { duration: 120, easing:'ease-out' });

  el.style.left = '';
  el.style.top  = '';
  el.classList.remove('dragging');

  cleanupDrag();
}

function cleanupDrag(){
  if(!drag.el) return;
  drag.el.removeEventListener('pointermove', onDragMove);
  drag.el.removeEventListener('pointerup', onDragEnd);
  drag.el.removeEventListener('pointercancel', onDragEnd);

  drag.active = false;
  drag.card = null;
  drag.el = null;
  drag.originRect = null;
  drag.lastClientX = null;
  drag.lastClientY = null;
}

/* =========================
   ★ ブロック解除（無視使用時）
   ========================= */
async function consumeReceivedInstruction(){
  if(!state.roomCode) return;
  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const rec = Array.isArray(myData.received) ? myData.received : [];
  if(!rec.length) return;

  await update(myRef, { received: [] });
}

/* =========================
   カード使用：プレイサークル
   ========================= */
async function playCardToCircle(cardObj){
  if(!state.roomCode) return;
  if(!isMyTurn()) return;

  const receivedExists = hasReceivedInstruction();
  const isIgnore = (cardObj.kind === 'instruction' && cardObj.name === '無視');

  const rec = getMyReceivedCard();
  const isReceived = (rec && rec.id === cardObj.id);

  if(isReceived){
    const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
    await update(myRef, { received: [] });

    const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
    const disSnap = await get(disRef);
    const discard = disSnap.val() || [];
    await set(disRef, [...discard, cardObj]);

    await emitEvent({ type:'revealCard', card: cardObj });
    await runActionCardEffect(cardObj);

    await endTurn('playReceivedInstruction');
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, cardObj]);

  await emitEvent({ type:'revealCard', card: cardObj });

  if(receivedExists && isIgnore){
    await consumeReceivedInstruction();
    await endTurn('ignore_clear_received');
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  await runActionCardEffect(cardObj);
  await endTurn('playAction');
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

async function runActionCardEffect(cardObj){
  return;
}

/* =========================
   指示カード：他プレイヤーへ渡す
   ========================= */
async function giveInstructionToPlayer(cardObj, targetSeat, targetUid){
  if(!state.roomCode) return;
  if(!isMyTurn()) return;

  if(!canUseOnOtherPlayer(cardObj)){
    return;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const toRef = ref(db, `rooms/${state.roomCode}/hands/${targetUid}`);
  const nextReceived = [cardObj];
  await update(toRef, { received: nextReceived });

  const fromSeat = state.turn?.activeSeat ?? state.seatedTable;
  await emitEvent({ type:'flyBackCard', fromSeat, toSeat: targetSeat });

  await runInstructionCardEffect(cardObj, targetUid);

  await endTurn('giveInstruction_received');
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}
async function runInstructionCardEffect(cardObj, targetUid){
  return;
}

/* =========================
   ★ スイーツ：山札クリック → 一覧表示
   ========================= */
let sweetsPanelLocked = false;

function canOpenSweetsPicker(){
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(hasReceivedInstruction()) return false;
  if(hasSweets()) return false;
  const deck = state.room?.decks?.sweets;
  if(!Array.isArray(deck) || !deck.length) return false;
  return true;
}

function openSweetsPicker(){
  const deck = state.room?.decks?.sweets;
  if(!Array.isArray(deck) || !deck.length) return;

  sweetsPanelLocked = true;
  btnSweetsClose.disabled = true;

  const sorted = [...deck].sort((a,b)=> (a.value ?? 0) - (b.value ?? 0));
  const cols = Math.ceil(sorted.length / 2);
  sweetsGrid.style.gridTemplateColumns = `repeat(${cols}, 90px)`;

  sweetsGrid.innerHTML = '';
  sorted.forEach(cardObj => {
    const el = document.createElement('div');
    el.className = 'sweets-pick-card';
    el.dataset.cardId = cardObj.id;

    const img = document.createElement('img');
    img.src = cardObj.img;
    img.alt = `sweets ${cardObj.value ?? ''}`;
    img.onerror = () => { if(cardObj.fallback) img.src = cardObj.fallback; };

    el.appendChild(img);
    el.addEventListener('pointerdown', (e) => startDragSweets(e, cardObj, el));
    sweetsGrid.appendChild(el);
  });

  sweetsBackdrop.classList.remove('hidden');
}

function closeSweetsPicker(){
  if(sweetsPanelLocked) return;
  sweetsBackdrop.classList.add('hidden');
}
btnSweetsClose.addEventListener('click', closeSweetsPicker);
sweetsBackdrop.addEventListener('click', (e) => {
  if(e.target === sweetsBackdrop) closeSweetsPicker();
});

sweetsDeckUI.addEventListener('click', () => {
  if(!canOpenSweetsPicker()) return;
  openSweetsPicker();
});

/* =========================
   ★ スイーツ：ドラッグ → dropZone で獲得
   ========================= */
const sweetsDrag = {
  active:false,
  card:null,
  srcEl:null,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
};

function startDragSweets(e, cardObj, srcEl){
  if(!canOpenSweetsPicker()) return;
  e.preventDefault();

  sweetsDrag.active = true;
  sweetsDrag.card = cardObj;
  sweetsDrag.srcEl = srcEl;
  const r = srcEl.getBoundingClientRect();
  sweetsDrag.offsetX = e.clientX - r.left;
  sweetsDrag.offsetY = e.clientY - r.top;
  sweetsDrag.lastClientX = e.clientX;
  sweetsDrag.lastClientY = e.clientY;

  const ghost = srcEl.cloneNode(true);
  ghost.classList.add('sweets-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  sweetsDrag.ghost = ghost;
  sweetsDrag.srcEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onSweetsDragMove);
  ghost.addEventListener('pointerup', onSweetsDragEnd);
  ghost.addEventListener('pointercancel', onSweetsDragEnd);
}

function onSweetsDragMove(e){
  if(!sweetsDrag.active || !sweetsDrag.ghost) return;
  const x = e.clientX - sweetsDrag.offsetX;
  const y = e.clientY - sweetsDrag.offsetY;
  sweetsDrag.lastClientX = e.clientX;
  sweetsDrag.lastClientY = e.clientY;
  sweetsDrag.ghost.style.left = `${x}px`;
  sweetsDrag.ghost.style.top  = `${y}px`;

  if(sweetsDropZone){
    const zoneR = sweetsDropZone.getBoundingClientRect();
    const inZone = (e.clientX >= zoneR.left && e.clientX <= zoneR.right && e.clientY >= zoneR.top && e.clientY <= zoneR.bottom);
    sweetsDropZone.classList.toggle('active', inZone);
  }
}

async function onSweetsDragEnd(e){
  if(!sweetsDrag.active) return;

  const gx = e.clientX;
  const gy = e.clientY;

  const zoneR = sweetsDropZone?.getBoundingClientRect();
  const inDropZone = zoneR
    ? (gx >= zoneR.left && gx <= zoneR.right && gy >= zoneR.top && gy <= zoneR.bottom)
    : false;

  if(inDropZone){
    await acquireSweetsCard(sweetsDrag.card);
    cleanupSweetsDrag();
    return;
  }

  cleanupSweetsDrag();
}

function cleanupSweetsDrag(){
  if(sweetsDrag.ghost){
    sweetsDrag.ghost.removeEventListener('pointermove', onSweetsDragMove);
    sweetsDrag.ghost.removeEventListener('pointerup', onSweetsDragEnd);
    sweetsDrag.ghost.removeEventListener('pointercancel', onSweetsDragEnd);
    sweetsDrag.ghost.remove();
  }
  if(sweetsDrag.srcEl){
    sweetsDrag.srcEl.style.visibility = '';
  }
  sweetsDropZone?.classList.remove('active');
  sweetsDrag.active = false;
  sweetsDrag.card = null;
  sweetsDrag.srcEl = null;
  sweetsDrag.ghost = null;
  sweetsDrag.offsetX = 0;
  sweetsDrag.offsetY = 0;
  sweetsDrag.lastClientX = null;
  sweetsDrag.lastClientY = null;
}

async function acquireSweetsCard(cardObj){
  if(!state.roomCode) return;
  if(!canOpenSweetsPicker()) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const already = Array.isArray(myData.sweets) && myData.sweets.length;
  if(already) return;

  const deckRef = ref(db, `rooms/${state.roomCode}/decks/sweets`);
  const deckSnap = await get(deckRef);
  const deck = deckSnap.val() || [];
  const exists = Array.isArray(deck) && deck.some(c => c.id === cardObj.id);
  if(!exists) return;

  const nextDeck = deck.filter(c => c.id !== cardObj.id);

  await set(deckRef, nextDeck);
  await update(myRef, { sweets: [cardObj] });

  sweetsPanelLocked = false;
  btnSweetsClose.disabled = false;
  sweetsBackdrop.classList.add('hidden');

  await endTurn('drawSweets');

  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   ★ 投票：チップドラッグ → swarea へドロップ
   ========================= */
const voteDrag = {
  active:false,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
  sourceEl:null,
};
let hoverSwarea = null;

function clearSwareaHint(){
  if(!hoverSwarea) return;
  hoverSwarea.classList.remove('hint-ok','hint-ng');
  hoverSwarea = null;
}
function updateSwareaHint(x,y){
  clearSwareaHint();
  const el = document.elementFromPoint(x,y);
  const area = el?.closest?.('.sweets-wrap');   // ★変更
  if(!area) return;

  const ok = !area.classList.contains('empty');
  area.classList.add(ok ? 'hint-ok' : 'hint-ng');
  hoverSwarea = area;
}
function getVoteDropTarget(x,y){
  const el = document.elementFromPoint(x,y);
  const wrap = el?.closest?.('.sweets-wrap');   // ★変更
  if(!wrap) return { type:'none' };

  // ★ tagは祖先じゃないので、otherplayerscircle から uid を取る
  const circle = wrap.closest('.otherplayerscircle');
  const tag = circle?.querySelector('.player-tag');
  const uid = tag?.dataset?.uid || null;
  if(!uid) return { type:'none' };

  const handData = state.hands?.[uid];
  const hasTheirSweets = !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);

  return { type:'swwrap', uid, ok: hasTheirSweets };
}

function startDragVoteChip(e){
  if(!canVoteNow()) return;
  e.preventDefault();

  const r = myVoteChipEl.getBoundingClientRect();
  voteDrag.active = true;
  voteDrag.sourceEl = myVoteChipEl;
  voteDrag.offsetX = e.clientX - r.left;
  voteDrag.offsetY = e.clientY - r.top;
  voteDrag.lastClientX = e.clientX;
  voteDrag.lastClientY = e.clientY;

  const ghost = myVoteChipEl.cloneNode(true);
  ghost.classList.remove('hidden');
  ghost.classList.add('vote-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  voteDrag.ghost = ghost;
  voteDrag.sourceEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onVoteDragMove);
  ghost.addEventListener('pointerup', onVoteDragEnd);
  ghost.addEventListener('pointercancel', onVoteDragEnd);
}

function onVoteDragMove(e){
  if(!voteDrag.active || !voteDrag.ghost) return;
  const x = e.clientX - voteDrag.offsetX;
  const y = e.clientY - voteDrag.offsetY;
  voteDrag.lastClientX = e.clientX;
  voteDrag.lastClientY = e.clientY;
  voteDrag.ghost.style.left = `${x}px`;
  voteDrag.ghost.style.top  = `${y}px`;
  updateSwareaHint(e.clientX, e.clientY);
}

async function onVoteDragEnd(e){
  if(!voteDrag.active) return;

  const drop = getVoteDropTarget(e.clientX, e.clientY);
  clearSwareaHint();

  if(drop.type === 'swwrap' && drop.ok){   // ★変更
    await castVote(drop.uid);
  }

  cleanupVoteDrag();
}

function cleanupVoteDrag(){
  if(voteDrag.ghost){
    voteDrag.ghost.removeEventListener('pointermove', onVoteDragMove);
    voteDrag.ghost.removeEventListener('pointerup', onVoteDragEnd);
    voteDrag.ghost.removeEventListener('pointercancel', onVoteDragEnd);
    voteDrag.ghost.remove();
  }
  if(voteDrag.sourceEl){
    voteDrag.sourceEl.style.visibility = '';
  }
  voteDrag.active = false;
  voteDrag.ghost = null;
  voteDrag.offsetX = 0;
  voteDrag.offsetY = 0;
  voteDrag.lastClientX = null;
  voteDrag.lastClientY = null;
  voteDrag.sourceEl = null;
}

function syncFloatingDragPositions(){
  if(drag.active && drag.el && drag.lastClientX !== null && drag.lastClientY !== null){
    const x = drag.lastClientX - drag.offsetX;
    const y = drag.lastClientY - drag.offsetY;
    drag.el.style.left = `${x}px`;
    drag.el.style.top  = `${y}px`;
    updateOtherCircleHint(drag.lastClientX, drag.lastClientY, drag.card);
  }

  if(sweetsDrag.active && sweetsDrag.ghost && sweetsDrag.lastClientX !== null && sweetsDrag.lastClientY !== null){
    const x = sweetsDrag.lastClientX - sweetsDrag.offsetX;
    const y = sweetsDrag.lastClientY - sweetsDrag.offsetY;
    sweetsDrag.ghost.style.left = `${x}px`;
    sweetsDrag.ghost.style.top  = `${y}px`;
  }

  if(voteDrag.active && voteDrag.ghost && voteDrag.lastClientX !== null && voteDrag.lastClientY !== null){
    const x = voteDrag.lastClientX - voteDrag.offsetX;
    const y = voteDrag.lastClientY - voteDrag.offsetY;
    voteDrag.ghost.style.left = `${x}px`;
    voteDrag.ghost.style.top  = `${y}px`;
    updateSwareaHint(voteDrag.lastClientX, voteDrag.lastClientY);
  }
}

mainEl.addEventListener('scroll', syncFloatingDragPositions, { passive: true });
window.addEventListener('resize', syncFloatingDragPositions);

async function castVote(targetUid){
  if(!state.roomCode) return;
  if(!canVoteNow()) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const chips = (typeof myData.voteChips === 'number') ? myData.voteChips : 1;
  if(chips <= 0) return;

  // 1) 自分のチップ消費（手元から消える）
  await update(myRef, { voteChips: chips - 1 });

  // 2) 投票記録（ターゲットの右側に表示される）
  await set(ref(db, `rooms/${state.roomCode}/votes/${targetUid}/${state.userId}`), true);

  // 3) これは1投票（手番終了）
  await endTurn('vote');

  renderMyVoteChip();
  updatePassRoundBtn();
}

/* ★ 投票チップ：pointerdown */
myVoteChipEl.addEventListener('pointerdown', startDragVoteChip);

/* =========================
   Seat UI（既存）
   ========================= */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* =========================
   追い出しダイアログ（既存）
   ========================= */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   ホストUI（既存）
   ========================= */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  resetLocalGameEffects();
  await hostGameStart();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/roles`)),
    remove(ref(db, `${base}/game`)),
    remove(ref(db, `${base}/decks`)),
    remove(ref(db, `${base}/discard`)),
    remove(ref(db, `${base}/events`)),
    remove(ref(db, `${base}/votes`)),
    remove(ref(db, `${base}/gameStarted`)),
  ]);

  resetLocalGameEffects();
  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
});

/* =========================
   Join（既存）
   ========================= */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeRoles();
  subscribeGame();
  subscribeEvents();

  syncSeatUI();

  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});


</script>

</body>
</html>
