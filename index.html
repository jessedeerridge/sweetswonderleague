<!DOCTYPE html>    
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>スイーツワンダーリーグ</title>
<style>
  :root{
    --leaderChipSize: 21.6px;
    --leaderChipOffset: 22px;
  }
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn:disabled{opacity:.45; cursor:not-allowed;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* ★ main背景：入室前/入室後で切替 */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('swtop.jpg'); }
  main.joined{ background-image:url('swmain.jpg'); }

  /* ★ 着席ポップ */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* ★ ホスト人数選択中：参加者に出す黒ポップ（下固定） */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

/* ★ プレイヤー円配置用（拡大：直径だいたい400前後） */
.player-circle{
  position:relative;
  width:min(300px, 92vw);
  height:min(400px, 92vw);
  margin:20px auto 0;
  border-radius:50%;
  box-sizing:border-box;
  border:none;
}



  /* ★ 中央：プレイサークル（※スイーツ山札クリックのため pointer-events を有効に） */
  .play-circle{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:120px;height:120px;border-radius:50%;
    background:transparent;
    pointer-events:auto;
border:transparent;
  }
  .required-sweets-tag{
    position:absolute;
    left:50%;
    top:calc(50% + 25px);
    transform:translate(-50%,-50%);
    font-size:12px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,247,224,.92);
    border:2px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
    pointer-events:none;
    z-index:7;
  }
  .play-circle::after{
    content:'PLAY';
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    font-weight:900;font-size:12px;letter-spacing:.08em;opacity:.65;
    pointer-events:none;
display:none;

  }
.play-circle.hint-ok {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* 薄い透明グレー */
}

.play-circle.hint-ng {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* 薄い透明グレー */
}

.play-circle.roundpick-target {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* 薄い透明グレー */
}


  /* =========================
     ★★ 中央：アクション山札（左）＋スイーツ山札（右）
     ========================= */
  .center-decks{
    position:absolute;
    left:50%; top:50%;
  transform:translate(-50%,-50%) translateY(60px); /* ← ここを増やすほど下がる */
    display:flex;
    gap:14px;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }
  .center-decks.hidden{display:none;}

  /* アクション山札（見た目専用） */
  .action-deck{
    position:relative;
    width:28px; height:40px;
    pointer-events:none;
  }
  .action-deck.hidden{display:none;}
  .action-deck .stack{position:absolute; inset:0;}
  .action-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swactionura.jpg') center/cover no-repeat;
    box-shadow:none;
  }
  .action-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
  .action-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
  .action-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
  .action-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
  .action-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
  display:none;
  }

  /* スイーツ山札（クリック可能） */
 .sweets-deck{
    position:relative;
    width:28px; height:40px;
    pointer-events:auto;
    cursor:pointer;
    user-select:none;
    touch-action:none;
  }
  .sweets-deck-wrap{
    position:relative;
    width:28px;
    height:40px;
  }
  .sweets-deck-wrap .sweets-deck{
    position:absolute;
    inset:0;
  }
  .sweets-deck.hidden{display:none;}
  .sweets-deck .stack{position:absolute; inset:0;}
  .sweets-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:none;
  }
  .sweets-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
  .sweets-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
  .sweets-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
  .sweets-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
  .sweets-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
   line-height:1.1;
    pointer-events:none;
  }
  .sweets-exclude-deck{
    position:absolute;
    right:-43px;
    top:0px;
    width:28px;
    height:40px;
    pointer-events:none;
    user-select:none;
  }
  .sweets-exclude-deck.hidden{display:none;}
  .sweets-exclude-deck .stack{position:absolute; inset:0;}
  .sweets-exclude-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:none;
    transform:rotate(90deg);
    transform-origin:center;
  }
  .sweets-exclude-deck .card.c2{ transform:translate(1px,-1px) rotate(90deg); opacity:.95; }
  .sweets-exclude-deck .card.c3{ transform:translate(2px,-2px) rotate(90deg); opacity:.90; }
  .sweets-exclude-deck .card.c4{ transform:translate(3px,-3px) rotate(90deg); opacity:.86; }
  .sweets-exclude-deck .card.c5{ transform:translate(4px,-4px) rotate(90deg); opacity:.82; }
  .sweets-exclude-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
    pointer-events:none;
  }
/* 除外札全体を少し薄く */
#sweetsExcludedDeckUI{
  opacity: .50;   /* 好みで調整 */
}

/* ✅ 除外デッキ：出現を「傾き＋フェード」で */
.sweets-exclude-deck{
  /* ふわっと出すための基準状態 */
  opacity: 1;
  visibility: visible;
  transform: translateX(0px) rotate(0deg) scale(1);
  will-change: opacity, transform;
  transition:
    opacity .22s ease,
    transform .22s cubic-bezier(.22,.84,.44,1),
    visibility 0s linear 0s;
}

/* ✅ 重要：.hidden を display:none にさせず、アニメ可能な隠し方に上書き */
.sweets-exclude-deck.hidden{
  display: block;                 /* ← これが肝。display:none を殺す */
  opacity: 0;
  visibility: hidden;
  transform: translateX(10px) rotate(-25deg) scale(.85); /* ← “傾く”の正体 */
  transition:
    opacity .18s ease,
    transform .18s ease,
    visibility 0s linear .18s;    /* ← フェード後に不可視へ */
}


  /* ★ 自分のターンだけ「大小アニメ（鼓動）」 */
  @keyframes pulseCard {
    0%{transform:scale(1);}
    50%{transform:scale(1.06);}
    100%{transform:scale(1);}
  }
 @keyframes pulseCardStrong {
    0%{transform:scale(1);}
    50%{transform:scale(1.12);}
    100%{transform:scale(1);}
  }
  .sweets-move-card{
    position:fixed;
    left:0;
    top:0;
    width:28px;
    height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.2);
    z-index:620;
    pointer-events:none;
    will-change:transform;
  }

  @keyframes sweetsDecidedMove {
    from{transform:translateY(0);}
    to{transform:translateY(-60px);}
  }
  @keyframes sweetsTagMove {
    from{transform:translate(-50%,0);}
    to{transform:translate(-50%, var(--sweetsTagMoveY));}
  }
  @keyframes sweetsDecidedMoveMy {
    from{transform:translateY(0);}
    to{transform:translateY(-30px);}
  }
/* ✅ スイーツ山札専用：鼓動（例：強め） */
@keyframes pulseSweetsDeck {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.4); } /* ← 強さ（例：1.06〜1.14） */
  100% { transform: scale(1); }
}
  .sweets-deck.pulsing{ animation:pulseSweetsDeck 1.05s ease-in-out infinite; }
  .sweets-deck.pulsing:hover{ animation:none; transform:scale(1.14); }

  /* ★★ 他プレイヤー：ネームタグ＋カード周りを円で囲む（otherplayerscircle） */
 .otherplayerscircle{
    position:absolute;
    left:0; top:0;
    width:126px; height:126px;
    transform:translate(-50%,-50%);
    border-radius:50%;
    border:2px solid transparent;
    background:transparent;
    display:flex;align-items:center;justify-content:center;
    box-sizing:border-box;
  }
  .otherplayerscircle.hint-ok{ border-color:rgba(34,197,94,.75); }
  .otherplayerscircle.hint-ng{ border-color:rgba(239,68,68,.75); }

  /* ★★ 手番：プレイヤーサークルを青く表示 */
  .otherplayerscircle.active-turn{
    border-color:rgba(59,130,246,.65);
    background:transparent;
  }
  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:var(--tagFill, #f8f8f8);
    border:1px solid var(--tagBorder, #ddd);font-size:12px;white-space:nowrap;
    color:var(--tagText, #111);
    display:flex;align-items:center;gap:6px;
  }
  .player-tag.me{
    transform:translate(-50%,-50%) translateY(45px);
  }
  /* ★ 手番の青枠：ネームタグ輪郭の外側 */
  .player-tag.active-turn{
    outline:none;
  }

  /* otherplayerscircle 内のタグは「中央配置」扱い */
  .player-tag.in-othercircle{
    position:relative;
    transform:none;
    left:auto; top:auto;
  }

  /* =========================
     ★ ネームタグ&投票チップ デザイン（8種）
     ========================= */
  .tag-chip-style-1{
    --tagFill: linear-gradient(180deg, #e0f2fe 0%, #bae6fd 100%);
    --tagBorder: #ffffff;
    --tagText: #0f172a;
    --voteChipFill: linear-gradient(135deg, #bae6fd 0%, #7dd3fc 100%);
    --voteChipStroke: #ffffff;
  }
  .tag-chip-style-2{
    --tagFill: repeating-linear-gradient(45deg, #f97316 0 6px, #7c2d12 6px 12px);
    --tagBorder: #7c2d12;
    --tagText: #fff7ed;
    --voteChipFill: repeating-linear-gradient(45deg, #f97316 0 4px, #7c2d12 4px 8px);
    --voteChipStroke: #7c2d12;
  }
  .tag-chip-style-3{
    --tagFill: radial-gradient(circle at 20% 30%, #f9a8d4 0 12%, transparent 13%),
      radial-gradient(circle at 80% 70%, #f9a8d4 0 12%, transparent 13%),
      linear-gradient(180deg, #ecfdf5 0%, #d1fae5 100%);
    --tagBorder: #10b981;
    --tagText: #065f46;
    --voteChipFill: radial-gradient(circle at 30% 30%, #f9a8d4 0 18%, transparent 19%),
      linear-gradient(180deg, #d1fae5 0%, #a7f3d0 100%);
    --voteChipStroke: #10b981;
  }
  .tag-chip-style-4{
    --tagFill: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 60%, #c4b5fd 100%);
    --tagBorder: #a78bfa;
    --tagText: #4c1d95;
    --voteChipFill: linear-gradient(135deg, #ddd6fe 0%, #c4b5fd 100%);
    --voteChipStroke: #a78bfa;
  }
  .tag-chip-style-5{
    --tagFill: repeating-linear-gradient(90deg, #fef9c3 0 8px, #fde68a 8px 16px);
    --tagBorder: #f59e0b;
    --tagText: #92400e;
    --voteChipFill: repeating-linear-gradient(90deg, #fef9c3 0 6px, #fde68a 6px 12px);
    --voteChipStroke: #f59e0b;
  }
  .tag-chip-style-6{
    --tagFill: linear-gradient(160deg, #fef2f2 0%, #fecaca 60%, #fca5a5 100%);
    --tagBorder: #ef4444;
    --tagText: #7f1d1d;
    --voteChipFill: linear-gradient(160deg, #fecaca 0%, #fca5a5 100%);
    --voteChipStroke: #ef4444;
  }
  .tag-chip-style-7{
    --tagFill: linear-gradient(135deg, #cffafe 0%, #99f6e4 100%);
    --tagBorder: #14b8a6;
    --tagText: #0f766e;
    --voteChipFill: linear-gradient(135deg, #99f6e4 0%, #5eead4 100%);
    --voteChipStroke: #14b8a6;
  }
  .tag-chip-style-8{
    --tagFill: repeating-linear-gradient(135deg, #fce7f3 0 6px, #fbcfe8 6px 12px);
    --tagBorder: #ec4899;
    --tagText: #9d174d;
    --voteChipFill: repeating-linear-gradient(135deg, #fbcfe8 0 5px, #f472b6 5px 10px);
    --voteChipStroke: #ec4899;
  }

/* ★ リーダーチップ（1.2倍） */
.leader-chip{
  position:absolute;
  right:calc(-1 * var(--leaderChipOffset));
  top:50%;
  width:var(--leaderChipSize);
  height:var(--leaderChipSize);
  transform:translateY(-50%);
  background:url('swleader.png') center/contain no-repeat;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.35));
  pointer-events:none;
}
.leader-chip-fly{
  position:fixed;
  z-index:720;
  pointer-events:none;
}
.leader-chip-hidden{
  opacity:0;
}

@keyframes leaderPickPulse{
  0%{ scale:1; }
  50%{ scale:1.12; }
  100%{ scale:1; }
}
.leader-pick-candidate{
  animation:leaderPickPulse 1.1s ease-in-out infinite;
  transform-origin:center;
}
.leader-pick-selectable{
  cursor:pointer;
}

.leader-pick-pop{
  position:fixed;
  left:50%;
  bottom:10px;
  transform:translateX(-50%);
  background:#fde047;
  color:#92400e;
  font-weight:900;
  padding:10px 16px;
  border-radius:14px;
  border:2px solid #f59e0b;
  box-shadow:0 14px 30px rgba(0,0,0,.25);
  z-index:280;
  white-space:nowrap;
}
.leader-pick-pop.hidden{display:none;}
.action-pop{
  display:flex;
  flex-direction:column;
  gap:6px;
  align-items:center;
  text-align:center;
  white-space:normal;
  max-width:min(90vw, 360px);
}
.action-pop .action-pop-actions{
  display:flex;
  gap:8px;
  justify-content:center;
  flex-wrap:wrap;
}
.action-pop .action-pop-text{
  font-weight:900;
}
.scout-reveal-overlay{
  position:fixed;inset:0;
  background:rgba(0,0,0,.55);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:260;
}
.scout-reveal-overlay.hidden{display:none;}
.scout-reveal-grid{
  display:flex;
  flex-wrap:nowrap;
  gap:12px;
  max-width:92vw;
  overflow-x:auto;
  padding:8px 12px;
}
.scout-reveal-grid .action-card{
  position:relative;
  inset:auto;
  transform:none;
  cursor:default;
  width:140px;
  height:210px;
}
.scout-reveal-grid .action-card .card-name{
  font-size:11px;
}
.scout-reveal-grid .action-card .effect-text{
  font-size:10px;
}
.mini-hand.scout-selectable{
  animation:scoutPulse 1.1s ease-in-out infinite;
}
@keyframes scoutPulse{
  0%{ transform:translateX(-50%) scale(1); }
  50%{ transform:translateX(-50%) scale(1.4); }
  100%{ transform:translateX(-50%) scale(1); }
}


  /* 他プレイヤー：正体カード（裏） */
.role-mini{
  position:absolute;
  left:-34px; top:50%;
  transform:translateY(-50%);
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  pointer-events:none;
  overflow:visible;
}
.role-mini .role-mini-frame{
  position:absolute;
  inset:0;
  border-radius:inherit;
  overflow:hidden;
}
.role-mini img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}
  .player-tag .other-role-mini.wiretap-selectable{
  pointer-events:auto;
  cursor:pointer;
  animation:pulseRoleMini 1.05s ease-in-out infinite;
  transform-origin:center;
}
@keyframes pulseRoleMini{
  0%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1); }
  50%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1.4); }
  100%{ transform:translate(var(--roleMiniX), var(--roleMiniY)) scale(1); }
}
.action-deal-card{
  position:fixed;
  left:0;
  top:0;
  background:url('swactionura.jpg') center/cover no-repeat;
  border:1px solid rgba(0,0,0,.18);
  border-radius:7px;
  box-shadow:0 10px 24px rgba(0,0,0,.18);
  pointer-events:none;
  z-index:720;
  will-change:transform;
}
  /* ★★ 他プレイヤー：ミニスイーツ（裏）＋周りを円で囲む＝swarea */
/* 他プレイヤー：スイーツ枠（山札と同サイズ） */
.sweets-area{
  position:absolute;
  left:-66px; top:50%;
  transform:translateY(-50%);
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:2px solid rgba(0,0,0,.22);
  background:rgba(255,255,255,.10);
  display:flex;
  align-items:center;
  justify-content:center;
  box-sizing:border-box;
  pointer-events:auto;

}
.sweets-area.empty{
  border-style:dashed;
  opacity:.35;
}
.sweets-area.hint-ok{ border-color:rgba(34,197,94,.75); }
.sweets-area.hint-ng{ border-color:rgba(239,68,68,.75); }

.sweets-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swsweetsura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}
.sweets-mini.hidden{display:none;}

/* 投票チップ（他プレイヤーのスイーツ右側に重ねる） */
.vote-stack{
  position:absolute;
  right:-22px;
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-wrap:wrap;

  width:calc(var(--voteMiniSize) * 2 + 6px); /* 2列 */
  gap:3px;
  justify-content:flex-start;
  align-items:center;
  pointer-events:none;
}

.vote-mini{
  width:var(--voteMiniSize);
  height:var(--voteMiniSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 6px 14px rgba(0,0,0,.18);
}


  /* 他プレイヤーのミニカード（ネームタグの下に扇状） */
.player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:60px;height:30px;pointer-events:none;
  }
 .player-tag .other-role-mini{
    position:absolute;
    left:50%;
    top:100%;
    --roleMiniX: calc(-50% - 40px);
    --roleMiniY: -3px;
    transform:translate(var(--roleMiniX), var(--roleMiniY));
    box-sizing:border-box;
    pointer-events:none;
  }
  .player-tag.right-side .other-role-mini{
    --roleMiniX: calc(-50% + 40px);
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:url('swactionura.jpg') center/cover no-repeat;
  transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }
  .role-mini .other-vote-chip{
    position:absolute;
    right:-6px;
    bottom:-6px;
    width:var(--voteMiniSize);
    height:var(--voteMiniSize);
    border-radius:50%;
    border:2px solid var(--voteChipStroke);
    background:var(--voteChipFill);
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    pointer-events:none;
  }
  .vote-chip-fly{
    position:fixed;
    left:0;
    top:0;
    width:var(--voteMiniSize);
    height:var(--voteMiniSize);
    border-radius:50%;
    border:2px solid var(--voteChipStroke);
    background:var(--voteChipFill);
    box-shadow:0 12px 28px rgba(0,0,0,.25);
    pointer-events:none;
    z-index:999;
    will-change:transform;
  }
  .vote-stack.animating{
    opacity:0;
  }
  .wiretap-arrow{
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:950;
  }
  .wiretap-arrow svg{
    width:100%;
    height:100%;
  }
  .wiretap-arrow line{
    stroke:#111;
    stroke-width:2;
    stroke-dasharray:6 6;
  }
  .wiretap-arrow .wiretap-eye{
    position:fixed;
    transform:translate(-50%,-50%);
    font-size:20px;
  }
  /* 自分の手札表示（大きめ横並び） */
  .my-hand-wrapper{margin-top:40px;text-align:center; position:relative;}
  .my-hand-title{display:none;}
  .my-area{
    display:flex;gap:10px;justify-content:center;align-items:flex-start;
    margin-top:-6px;
  }

  /* ★ 自分の正体カード（自分のアクションカードの左側） */
  .my-role{
    width:78px;height:118px;border-radius:12px;border:1px solid #ddd;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    background:#fff;
    overflow:hidden;
    flex:0 0 auto;
  }
  .my-role img{width:100%;height:100%;object-fit:cover;display:block;}

  /* ★★ 自分のスイーツ（正体カードの左／同サイズ） */
  .my-sweets{
    width:78px;height:118px;border-radius:12px;border:1px solid #ddd;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    background:#fff;
    overflow:visible;
    flex:0 0 auto;
  }
  .my-sweets.collect-hidden{
    opacity:0;
    visibility:hidden;
  }
  .my-sweets.hidden{display:none;}  .my-sweets img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
    border-radius:inherit;
  }
  /* =========================
     ★ 受け取った指示カードスロット（正体カードの左）
     ========================= */
  .my-received-slot{
    flex:0 0 auto;
    display:flex;align-items:flex-start;justify-content:center;gap:8px;flex-wrap:wrap;
  }

  .my-hand{
    display:flex;justify-content:center;gap:10px;flex-wrap:wrap;
    min-height:130px;
  }

  /* ★ アクションカード（自分の手札） */
  .action-card{
    position:relative;
    width:90px;height:135px;border-radius:12px;border:1px solid #ddd;background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    overflow:hidden;
    user-select:none;
    touch-action:none;
    cursor:grab;
    transform-origin:center;
  }
  .action-card:active{cursor:grabbing;}
  .action-card img.card-img{
    position:absolute;inset:0;width:100%;height:100%;object-fit:cover;
    display:block;
  }
  .action-card .card-name{
    position:absolute;left:8px;top:6px;
    font-weight:900;font-size:14px;
    color:#1d4ed8;
    text-shadow:0 2px 6px rgba(255,255,255,.7);
    pointer-events:none;
    display:none;
  }

  .action-card .effect-frame{
    position:absolute;
    left:0;
    right:0;
    top:70%;
    bottom:0px;
    background:rgb(195,179,237);
    border-top:1px solid rgba(0,0,0,.15);
border-radius:0px;
    padding:2px 2px 2px;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    box-sizing:border-box;
    pointer-events:none;
  }
  .action-card .effect-text{
    width:100%;
    font-weight:800;
    line-height:1.2;
    color:#111;
    font-size:13px;
    word-break:break-word;
    hyphens:auto;
    overflow:hidden;
  }
  .my-turn-free .action-card{ animation:pulseCard 1.05s ease-in-out infinite; }
  .my-turn-free .action-card:hover{ animation:none; transform:scale(1.08); }

  /* ★ 受け取り指示カードがある間：通常手札は無効＆アニメ停止 */
  .my-turn-blocked .my-hand .action-card{
    animation:none !important;
    cursor:not-allowed;
    filter:grayscale(.25);
    opacity:.72;
  }

  /* ★ 指示カードスロット内のカードだけ鼓動させる */
  .my-turn-blocked .my-received-slot .action-card.pulse-only{
    animation:pulseCard 1.05s ease-in-out infinite;
    cursor:grab;
    filter:none;
    opacity:1;
  }
  .my-turn-blocked .my-received-slot .action-card.pulse-only:hover{
    animation:none;
    transform:scale(1.08);
  }

  /* ★ 無視カード：ブロック中でも鼓動＆使用可（手札内） */
  .my-turn-blocked .my-hand .action-card.can-ignore{
    animation:pulseCard 1.05s ease-in-out infinite !important;
    cursor:grab !important;
    filter:none !important;
    opacity:1 !important;
  }
  .my-turn-blocked .my-hand .action-card.can-ignore:hover{
    animation:none !important;
    transform:scale(1.08);
  }
  .my-turn-selecting .action-card{
    animation:none !important;
    cursor:not-allowed;
    filter:grayscale(.25);
    opacity:.72;
  }

  /* ★ ドラッグ中の見た目 */
  .dragging{
    position:fixed !important;
    z-index:9999 !important;
    margin:0 !important;
    animation:none !important;
    pointer-events:none;
  }

  /* ★ 追い出し確認ダイアログ */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* ★ ホスト用 設定ボタン（右下固定） */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* ★ 設定ポップ（ホスト専用パネル） */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  /* 詳細情報消す用 */
  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  /* =========================
     ★ 左下「？」ボタン
     ========================= */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  /* ★ ヘルプ一覧ポップ */
  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
  }
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
    overflow:hidden;
  }
  .role-card img{width:100%;height:100%;object-fit:cover;display:block;}
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  /* =========================
     ★ ターン操作バー
     ========================= */
  .turn-bar{
    position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
    z-index:228;
    display:flex; gap:8px; align-items:center; justify-content:center;
    background:rgba(255,255,255,.85);
    border:1px solid #ddd;
    border-radius:999px;
    padding:6px 10px;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    backdrop-filter: blur(6px);
  }
  .turn-bar.hidden{display:none;}
  .turn-badge{
    font-size:12px;font-weight:900;opacity:.85;
    padding:4px 8px;border-radius:999px;border:1px solid #ddd;background:#fff;
  }

  /* =========================
     ★ 全員に見せる「中央拡大」(1秒)
     ========================= */
  .reveal-overlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:500;
  }
  .reveal-overlay.hidden{display:none;}
 .reveal-card{
    width:min(calc(var(--myCardW) * 4), 78vw);
    aspect-ratio: 2 / 3;
    border-radius:18px;
    border:none;
    box-shadow:none;
    background:transparent;
    overflow:hidden;
    position:relative;
  }
  .reveal-card img{width:100%;height:100%;object-fit:cover;display:block;border:none;background:transparent;}
  .reveal-card .label{
    position:absolute; left:10px; top:10px;
    font-weight:900; color:#1d4ed8;
    text-shadow:0 2px 10px rgba(255,255,255,.75);
  }
  .reveal-card .label.hidden{display:none;}
  .reveal-card .effect-frame{
    position:absolute;
    left:0;
    right:0;
    top:70%;
    bottom:0;
    background:rgb(195,179,237);
    border-top:1px solid rgba(0,0,0,.15);
    padding:6px 8px;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    box-sizing:border-box;
    pointer-events:none;
  }
  .reveal-card .effect-frame.hidden{display:none;}
  .reveal-card .effect-text{
    width:100%;
    font-weight:800;
    line-height:1.3;
    color:#111;
    font-size:16px;
    word-break:break-word;
    hyphens:auto;
    overflow:hidden;
  }

  /* ★ 指示カード移動アニメ用（小さい裏カード） */
 .fly-card{
    position:fixed;
    width:22px;height:32px;border-radius:6px;
    border:1px solid rgba(0,0,0,.2);
    background:url('swactionura.jpg') center/cover no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.25);
    z-index:520;
    pointer-events:none;
  }
  .sweets-fly-card{
    position:fixed;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 10px 24px rgba(0,0,0,.22);
    background:#fff;
    overflow:hidden;
    z-index:540;
    pointer-events:none;
    transform-origin:top left;
  }
  .sweets-fly-card img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }


  /* ★ 自分の手札サイズ統一（60x90） */
  :root{
    --myCardW: 60px;
    --myCardH: 90px;
    --myCardR: 10px;
  }
  .my-role{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }
  .action-card{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }
  .my-sweets{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }

  /* =========================
     ★ スイーツ一覧（ローカル表示）
     ========================= */
  .sweets-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; flex-direction:column;
    align-items:center; justify-content:flex-start;
    z-index:560;
    padding:16px;
    gap:12px;
    overflow:auto;
  }
  .sweets-backdrop.hidden{display:none;}
  .sweets-panel{
    width:min(760px, calc(100% - 32px));
    background:#fff;
    border:1px solid #ddd;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
    position:sticky;
    top:140px;
  }
  .sweets-panel-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .sweets-panel-title{
    font-weight:900;font-size:14px;
  }
  .sweets-panel-body{
    padding:12px;
    overflow:auto;
    max-height:min(70vh, 640px);
  }
  .sweets-grid{
    display:grid;
    gap:10px;
    justify-content:center;
    align-content:center;
  }
  .sweets-pick-card{
    width:90px; height:135px;
    border-radius:12px;
    border:1px solid #ddd;
    background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    overflow:hidden;
    position:relative;
    cursor:grab;
    user-select:none;
    touch-action:none;
    animation:pulseCardStrong 1.05s ease-in-out infinite;
    transform-origin:center;
  }
  .sweets-pick-card.restricted{
    animation:none;
    cursor:not-allowed;
    opacity:.55;
    filter:grayscale(.2);
  }
  .sweets-pick-card:active{cursor:grabbing;}
  .sweets-pick-card:hover{ animation:none; transform:scale(1.12); }
  .sweets-pick-card img{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    display:block;
  }

  /* ★ スイーツドラッグ中の見た目 */
 .sweets-dragging{
    position:fixed !important;
    z-index:99999 !important;
    pointer-events:none;
    animation:none !important;
  }
  .sweets-drop-zone{
    width:min(800px, calc(100% - 32px));
    min-height:200px;
    border:transparent;
    border-radius:14px;
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:transparent;
    text-align:center;
    padding:8px 12px;
    margin-top:130px;
  }
  .sweets-drop-zone.active{
    border-color:transparent;
    color:transparent;
    background:transparent;
  }

  /* =========================
     ★ 投票チップ（自分の手元：全カードの右側）
     ========================= */
/* 投票チップ（自分の手元：全カードの右側） */
.vote-chip{
  width:var(--voteChipSize);
  height:var(--voteChipSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 10px 24px rgba(0,0,0,.18);
  flex:0 0 auto;
  align-self:flex-start;
  cursor:grab;
  user-select:none;
  touch-action:none;
  position:relative;
  transition:transform .2s ease;
}
/* ✅ 投票チップ専用：鼓動を弱める */
@keyframes pulseVoteChip {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.5); } /* ← ここが強さ（例：1.04〜1.10） */
  100% { transform: scale(1); }
}

.vote-chip.hidden{display:none;}
.vote-chip:active{cursor:grabbing;}
.vote-chip.pulsing{ animation:pulseVoteChip 1.05s ease-in-out infinite; }
.vote-chip.pulsing:hover{ animation:none; transform:scale(1.10); } /* ← hover拡大も投票専用に調整 */


/* 既存の「V」文字は消す（デザイン統一） */
.vote-chip::after{ content:''; }


  .vote-dragging{
    position:fixed !important;
    z-index:999999 !important;
    pointer-events:none;
    animation:none !important;
  }

  .roundpick-dragging{
    position:fixed !important;
    z-index:999999 !important;
    pointer-events:none;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.35);
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    background:#fff center/cover no-repeat;
  }



  /* =========================
     ★★★ ここから PASS & ラウンド終了演出 ★★★
     ========================= */

  /* 右下：丸いPASSボタン（紫・白字） */
  .pass-round-btn{
    position:fixed;
    right:16px;
    bottom:16px;
    width:64px;
    height:64px;
    border-radius:50%;
    border:1px solid rgba(255,255,255,.25);
    background:#7c3aed;           /* 紫 */
    color:#fff;
    font-weight:900;
    letter-spacing:.06em;
    box-shadow:0 14px 34px rgba(0,0,0,.25);
    cursor:pointer;
    z-index:235;                  /* hostSettingsBtnより上でもOK */
    display:none;
    user-select:none;
  }
  .pass-round-btn.visible{display:grid; place-items:center;}
  .pass-round-btn:active{transform:scale(.98);}
  .pass-round-btn:disabled{opacity:.5; cursor:not-allowed; transform:none;}

  /* 収集アニメ用：中央に集まる裏カード */
  .collect-card{
    position:fixed;
    width:90px;
    height:135px;
    border-radius:7px;
    border:1px solid rgba(255,255,255,.25);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    z-index:610;
    pointer-events:none;
    transform-origin:center;
  }

  /* 最終公開（複数） */
  .roundreveal-overlay{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);
    background:transparent;
    z-index:620;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:6px;
    pointer-events:none;
  }
  .roundreveal-overlay.hidden{display:none;}
  .roundreveal-row{
    display:flex;
    gap:30px;
    align-items:center;
    justify-content:center;
    flex-wrap:nowrap;          /* 折り返しなし */
    overflow:auto;
    padding:6px;
  }
  .roundreveal-card{
    width:min(240px, 32vw);
    aspect-ratio:2/3;
    border-radius:18px;
    border:none;
    box-shadow:none;
    background:transparent;
    overflow:hidden;
    flex:0 0 auto;
    transform:scale(1.02);
  }
  .roundreveal-card img{width:100%;height:100%;object-fit:cover;display:block;}

:root{
  --deckCardW: 28px;
  --deckCardH: 40px;
  --deckCardR: 7px;

  /* 投票チップ（自分/他人 共通） */
  /* 自分（ドラッグ用） */
  --voteChipSize: 22px;

  /* 他プレイヤーに乗る小さいやつ */
  --voteMiniSize: 14px;

  --voteChipFill: rgba(196, 181, 253, .92);
  --voteChipStroke: rgba(255,255,255,.95);
}

/* =========================
   ★★ 他プレイヤー：内側に「正体＋スイーツ」横並び（平行）
   - JSから --inX/--inY/--rotDeg を渡す
   ========================= */
.otherplayerscircle{ --inX:0px; --inY:0px; --outX:0px; --outY:0px; --rotDeg:0deg; }

/* タグ（外側へ） */
.player-tag.in-othercircle{
  position:absolute;
  left:50%; top:50%;
  transform:translate(-50%,-50%) translate(var(--outX), var(--outY));
}

/* 内側カード列（回転して「上が中心を向く」） */
.other-cards-row{
  position:absolute;
  left:50%; top:50%;
  transform:
    translate(-50%,-50%)
    translate(var(--inX), var(--inY))
    rotate(var(--rotDeg));
  display:flex;
  gap:8px;
  align-items:center;
  justify-content:center;
  pointer-events:none; /* 見た目専用（投票などにしたいなら外す） */
}

/* 正体ミニ（裏） */
.role-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swroleura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}

/* スイーツ枠（裏カード＋投票チップ重ね） */
.sweets-wrap{
  position:relative;
  width:calc(var(--deckCardW) + 20px);
  height:calc(var(--deckCardH) + 20px);
  border-radius:calc(var(--deckCardR) + 6px);
  border:transparent;
  background:rgba(255,255,255,.10);
  box-sizing:border-box;
  display:flex; align-items:center; justify-content:center;
  transition:transform .6s ease;
  --decidedMoveX: 0px;
  --decidedMoveY: 0px;
}

.sweets-wrap.empty{
  border-style:dashed;
  opacity:.35;
}
.sweets-wrap.hint-ok{
  border-color:transparent;
  background: rgba(200, 200, 200, 0.3);
}
.sweets-wrap.hint-ng{
  border-color:rgba(239,68,68,.75);
  background: rgba(200, 200, 200, 0.3);
}
.sweets-wrap.roundpick-candidate{
  animation:pulseSweetsDeck 1.05s ease-in-out infinite;
}
.sweets-wrap.roundpick-selectable{
  cursor:pointer;
}
.sweets-wrap.roundpick-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
.sweets-wrap.decided-move{
  transform:translate(var(--decidedMoveX), var(--decidedMoveY));
}
.sweets-wrap.decided-move.decided-static{
  transition:none;
}
.sweets-wrap.center-move-host{
  border-color:transparent;
  background:transparent;
}
.sweets-wrap.collect-hidden{
  border-color:transparent;
  background:transparent;
}
.sweets-wrap.collect-hidden .sweets-mini{
  opacity:0;
}

.sweets-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swsweetsura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  --centerMoveX: 0px;
  --centerMoveY: 0px;
}
.sweets-mini.hidden{display:none;}
.sweets-mini.center-move{
  transition:transform .6s ease;
  transform:translate(var(--centerMoveX), var(--centerMoveY));
}
.sweets-mini.center-move.center-static{
  transition:none;
}

.my-sweets.roundpick-candidate{
  animation:pulseCardStrong 1.05s ease-in-out infinite;
}
.my-sweets.roundpick-selectable{
  cursor:pointer;
}
.my-sweets.roundpick-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
.my-sweets.roundpick-selectable:hover ~ .vote-chip,
.my-sweets.roundpick-selectable:active ~ .vote-chip{
  transform:scale(1.12);
}
.my-sweets.decided-move{
  transform:translateY(-30px);
  animation:sweetsDecidedMoveMy .6s ease;
}

/* 投票チップ（スイーツの右側に重ねる） */
.vote-stack{
  position:absolute;
  right:-22px;
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-wrap:wrap;
  width:calc(var(--voteMiniSize) * 2 + 6px); /* 2列 */
  gap:3px;
  justify-content:flex-start;
  align-items:center;
  pointer-events:none;
}

.selected-sweets-tag{
  position:absolute;
  left:50%;
  bottom:100%;
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  overflow:visible;
  --sweetsTagMoveY:-30px;
  transform:translate(-50%, var(--sweetsTagMoveY));
  animation:sweetsTagMove .6s ease;
  pointer-events:none;
}
.selected-sweets-tag.delayed-show{
  opacity:0;
  visibility:hidden;
}
.selected-sweets-tag.decided-static{
  animation:none;
}



.selected-sweets-tag.collect-hidden .selected-sweets-card{
  border-color:transparent;
  background:transparent;
  box-shadow:none;
}
.selected-sweets-tag.collect-hidden img{
  opacity:0;
}
.selected-sweets-tag.collect-hidden .sweets-number-tag{
  opacity:0;
}
.selected-sweets-card{
  position:relative;
  width:100%;
  height:100%;
  border-radius:inherit;
  border:1px solid rgba(0,0,0,.18);
  background:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  --centerMoveX: 0px;
  --centerMoveY: 0px;
}
.selected-sweets-card.center-move{
  transition:transform .6s ease;
  transform:translate(var(--centerMoveX), var(--centerMoveY));
}
.selected-sweets-card.center-move.center-static{
  transition:none;
}
.selected-sweets-card img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
  border-radius:inherit;

}
.selected-sweets-card .sweets-number-tag{
  position:absolute;
  right:9px;
  top:-12px;

  /* 少し大きくして余裕を作る */
  width:34px;
  height:34px;

  display:grid;
  place-items:center;

  font-weight:900;
  font-size:13px;
  line-height:1;
  color:#111;

  text-shadow:0 1px 0 rgba(255,255,255,.6);
}
.selected-sweets-card .sweets-number-star{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:0;
  pointer-events:none;
}
.selected-sweets-card .sweets-number-text{
  position:relative;
  z-index:1;
  transform:translateZ(0) translateY(-1px);
}


/* 下の手番バーだけ消して、右下PASSは残す */
#turnBar{
  display:none !important;
}
/* 投票ドロップのため：内側カード列はポインターを通す */
.other-cards-row{ pointer-events:auto; }

/* ドロップ判定したいのはスイーツ枠なので、ここも明示しておく */
.sweets-wrap{ pointer-events:auto; }


/* 自分のスイーツにも投票ミニを重ねるため */
.my-sweets{ position:relative; }

/* 自分スイーツ上の投票（右に重ね） */
.my-sweets .vote-stack{
  right:-22px;                 /* 少しだけ内側に寄せる（好みで調整OK） */
  top:10%;
  transform:translateY(-50%);
}
/* ★ 自分のスイーツ上の投票チップだけ「手元チップと同サイズ」にする */
.my-sweets .vote-stack{
  width:calc(var(--voteChipSize) * 2 + 6px); /* 2列レイアウトも同サイズ基準に */
}

.my-sweets .vote-stack .vote-mini{
  width:var(--voteChipSize);
  height:var(--voteChipSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 10px 24px rgba(0,0,0,.18);
}

/* =========================
   ★★ 選抜スイーツ：回収→シャッフル（中央）
   ========================= */
.sweets-shuffle-stage{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:160px;
  height:220px;
  z-index:615;
  pointer-events:none;
}
.sweets-shuffle-card{
  position:absolute;
  left:50%;
  top:50%;
  width:120px;
  height:170px;
  transform:translate(-50%,-50%);
  border-radius:12px;
  border:1px solid rgba(255,255,255,.25);
  box-shadow:0 16px 44px rgba(0,0,0,.35);
  background:center/cover no-repeat;
  will-change:transform, opacity;
}

/* =========================
   ★ 中央：リーダーボード（長方形 5:3.3）
   ========================= */
.leaderboard-board{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:min(120px, 78vw);
  aspect-ratio: 5 / 3.3;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.18);
  background:rgba(255,255,255,.18);
  box-shadow:0 10px 24px rgba(0,0,0,.12);
  overflow:hidden;
  pointer-events:none;
  z-index:4; /* play-circleより下/上は好みで */
}
.leaderboard-board.hidden{display:none;}
.leaderboard-board img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

/* play-circle を前面に（中央ボードの上に乗せる） */
.play-circle{ z-index:6; }
/* ✅ leaderboardより前面に出したいUIのレイヤーを上げる */
.otherplayerscircle{ z-index: 7; }   /* 他プレイヤーの円ごと前へ */
.player-tag{ z-index: 8; }          /* ネームタグ前へ */
.other-cards-row{ z-index: 8; }     /* 内側カード列も前へ */

/* 選抜スイーツ表示（selected card）をさらに前へ */
.selected-sweets-tag{ z-index: 9; }

/* チップ系も前へ（投票チップ/投票スタック） */
.vote-chip{ z-index: 9; }           /* 自分の投票チップ（念のため） */
.vote-stack{ z-index: 9; }          /* 付随する投票チップ群 */

/* ※ leaderboardは現状のままでもOK（z-index:4） */

/* =========================
   ★ 中央：ラウンドチップ枠（3つ横並び）
   - z-indexに頼らず、DOM順で前面化（leaderboardの後ろに置く）
   ========================= */
.round-chips{
  position:absolute;
  left:50%;
top:calc(50% - 6.5px);  
  transform:translate(-50%,-50%);
  display:flex;
  gap:10.5px;
  align-items:center;
  justify-content:center;
  pointer-events:none; /* クリック不要なら none（必要になったらautoに） */
}

.round-chip-slot{
  width:22px;
  height:22px;
  border-radius:50%;
  border:transparent;
  background:transparent;
  box-shadow:0 6px 14px rgba(0,0,0,.10) inset;
  position:relative;
  overflow:hidden;
}

.round-chip-slot::after{
  /* 今は目印（後で消してOK） */
  content: attr(data-round);
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  font-weight:900;
  font-size:10px;
  opacity:.55;
display:none;

}

.round-chip-img{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

.round-chip-img.hidden{ display:none; }


</style>
</head>
<body>

<header>
  <h1>スイーツワンダーリーグ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">

  <!-- ★ 中央：リーダーボード（人数で画像切替） -->
<div id="leaderboardBoard" class="leaderboard-board hidden" aria-hidden="true">
  <img id="leaderboardImg" alt="leaderboard" />

  <!-- ★ 中央：ラウンドチップ枠（R1/R2/R3）※leaderboardより後に置く＝前面に描画される -->
  <div id="roundChips" class="round-chips" aria-label="ラウンドチップ">
    <div class="round-chip-slot" data-round="1" aria-label="ラウンド1">
      <img class="round-chip-img hidden" alt="round1" />
    </div>
    <div class="round-chip-slot" data-round="2" aria-label="ラウンド2">
      <img class="round-chip-img hidden" alt="round2" />
    </div>
    <div class="round-chip-slot" data-round="3" aria-label="ラウンド3">
      <img class="round-chip-img hidden" alt="round3" />
    </div>
  </div>
</div>


      <div id="playCircle" class="play-circle">
        <div id="requiredSweetsTag" class="required-sweets-tag hidden">🍰0</div>
        <!-- ★ 中央：アクション山札（左）＋スイーツ山札（右） -->
        <div id="centerDecks" class="center-decks hidden" aria-hidden="false">
          <div id="actionDeckUI" class="action-deck hidden" aria-hidden="true">
            <div class="stack" aria-hidden="true">
              <div class="card c5"></div>
              <div class="card c4"></div>
              <div class="card c3"></div>
              <div class="card c2"></div>
              <div class="card c1"></div>
            </div>
            <div id="actionDeckCount" class="count">0</div>
          </div>

         <div class="sweets-deck-wrap">
            <div id="sweetsDeckUI" class="sweets-deck hidden" aria-label="スイーツ山札">
              <div class="stack" aria-hidden="true">
                <div class="card c5"></div>
                <div class="card c4"></div>
                <div class="card c3"></div>
                <div class="card c2"></div>
                <div class="card c1"></div>
              </div>
              <div id="sweetsDeckCount" class="count">0</div>
            </div>
            <div id="sweetsExcludedDeckUI" class="sweets-exclude-deck hidden" aria-label="スイーツ除外山札">
              <div class="stack" aria-hidden="true">
                <div class="card c5"></div>
                <div class="card c4"></div>
                <div class="card c3"></div>
                <div class="card c2"></div>
                <div class="card c1"></div>
              </div>
              <div id="sweetsExcludedDeckCount" class="count">0</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>

      <!-- ★ ownarea -->
      <div class="my-area" id="myArea">
        <!-- ★ 受け取った指示カード（正体カードの左） -->
        <div id="myReceived" class="my-received-slot"></div>

        <!-- ★ 自分のスイーツ（正体カードの左・同サイズ） -->
        <div id="mySweets" class="my-sweets hidden"></div>

        <div id="myRole" class="my-role hidden"></div>
        <div id="myHand" class="my-hand"></div>

        <!-- ★ 投票チップ（全所有カードより右） -->
        <div id="myVoteChip" class="vote-chip hidden" aria-label="投票チップ"></div>
      </div>
    </div>
  </div>
</main>

<!-- ★ 参加者：ホスト人数選択中ポップ -->
<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>
<div id="leaderPickPop" class="leader-pick-pop hidden">最多票の中からリーダーを選んでください。</div>
<div id="actionExplainPop" class="leader-pick-pop action-pop hidden"></div>
<div id="actionConfirmPop" class="leader-pick-pop action-pop hidden">
  <div id="actionConfirmText" class="action-pop-text"></div>
  <div class="action-pop-actions">
    <button id="actionConfirmYes" class="btn primary">はい</button>
    <button id="actionConfirmNo" class="btn">いいえ</button>
  </div>
</div>
<div id="scoutRevealOverlay" class="scout-reveal-overlay hidden">
  <div id="scoutRevealGrid" class="scout-reveal-grid"></div>
</div>
<div id="scoutCloseConfirmPop" class="leader-pick-pop action-pop hidden">
  <div class="action-pop-text">閉じてもいいですか。</div>
  <div class="action-pop-actions">
    <button id="scoutCloseYes" class="btn primary">はい</button>
    <button id="scoutCloseNo" class="btn">いいえ</button>
  </div>
</div>

<!-- 着席ポップ -->
<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<!-- 既存プレイヤー追い出し確認ポップ -->
<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<!-- ホスト専用 設定ボタン（⚙） -->
<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<!-- ★ ヘルプボタン（？） -->
<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<!-- ★ ヘルプ一覧ポップ -->
<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<!-- 設定ポップ（スタート＋リセット） -->
<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で正体カード＋アクションカード配布＋手番決定。<br>
    「リセット」で人数選択へ戻します（内容は後で）。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ★ ターン操作バー（既存） -->
<div id="turnBar" class="turn-bar hidden">
  <span id="turnBadge" class="turn-badge">TURN</span>
  <button id="btnPass" class="btn">パス</button>
  <button id="btnDrawSweets" class="btn" disabled>スイーツドロー（後で）</button>
  <button id="btnVote" class="btn" disabled>投票（後で）</button>
</div>

<!-- ★ 右下：丸いPASSボタン（ラウンド用） -->
<button id="passRoundBtn" class="pass-round-btn" type="button" aria-label="PASS">PASS</button>

<!-- ★ 中央拡大表示（全員、1秒） -->
<div id="revealOverlay" class="reveal-overlay hidden">
  <div class="reveal-card">
    <img id="revealImg" alt="" />
    <div id="revealLabel" class="label"></div>
    <div id="revealEffectFrame" class="effect-frame hidden">
      <div id="revealEffect" class="effect-text"></div>
    </div>
  </div>
</div>


<!-- ★ スイーツ一覧（ローカル表示） -->
<div id="sweetsBackdrop" class="sweets-backdrop hidden">
  <div class="sweets-panel" role="dialog" aria-modal="true" aria-label="スイーツ一覧">
    <div class="sweets-panel-header">
      <div class="sweets-panel-title">スイーツ（下にドラッグ）</div>
      <button id="btnSweetsClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="sweets-panel-body">
      <div id="sweetsGrid" class="sweets-grid"></div>
    </div>
  </div>
  <div id="sweetsDropZone" class="sweets-drop-zone" aria-label="スイーツ獲得エリア">
    ここにカードを出すと獲得
  </div>
</div>

<!-- ★ ラウンド終了：公開（複数） -->
<div id="roundRevealOverlay" class="roundreveal-overlay hidden" aria-hidden="true">
  <div id="roundRevealRow" class="roundreveal-row"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove,
  push, onChildAdded, serverTimestamp
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* =========================
   Firebase
   ========================= */
const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};
const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

// ★ userId をタブ単位で固定（タブごとに別ID）
const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

/* =========================
   状態
   ========================= */
const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  turnEnding: false,
  passReadyBlockedTurnNo: null,
  lastPassEligible: false,
  prevTurnNo: null,

  room: {},
  hands: {},
  roles: {},
  game: {},
  turn: null,
};
let latestPlayers = [];
const TAG_CHIP_STYLES = [
  'tag-chip-style-1',
  'tag-chip-style-2',
  'tag-chip-style-3',
  'tag-chip-style-4',
  'tag-chip-style-5',
  'tag-chip-style-6',
  'tag-chip-style-7',
  'tag-chip-style-8',
];
const collectedSweetsHidden = new Set();
let miniShuffleRunning = false;
let miniShuffleToken = 0;
let sweetsExcludeAnimating = false;
let sweetsDeckCountOverride = null;
let sweetsExcludedCountOverride = null;
let sweetsOverrideClearTimer = null;
let currentGameSessionId = null;
let eventsSubscribedAt = 0;
let turnBlockedByShuffle = false;
let leaderPickApplyTimer = null;
let leaderPickApplyKey = null;
let lastLeaderSeat = null;
let actionSelection = null;
const revealedRoleUids = new Set();
let pendingWiretapZoomUid = null;
/* =========================
   DOM
   ========================= */
const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');
const leaderPickPop = document.getElementById('leaderPickPop');
const actionExplainPop = document.getElementById('actionExplainPop');
const actionConfirmPop = document.getElementById('actionConfirmPop');
const actionConfirmText = document.getElementById('actionConfirmText');
const actionConfirmYes = document.getElementById('actionConfirmYes');
const actionConfirmNo = document.getElementById('actionConfirmNo');
const scoutRevealOverlay = document.getElementById('scoutRevealOverlay');
const scoutRevealGrid = document.getElementById('scoutRevealGrid');
const scoutCloseConfirmPop = document.getElementById('scoutCloseConfirmPop');
const scoutCloseYes = document.getElementById('scoutCloseYes');
const scoutCloseNo = document.getElementById('scoutCloseNo');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const playCircleEl = document.getElementById('playCircle');
const myHandEl = document.getElementById('myHand');
const myRoleEl = document.getElementById('myRole');
const myReceivedEl = document.getElementById('myReceived');
const mySweetsEl = document.getElementById('mySweets');
const myAreaEl = document.getElementById('myArea');
const myVoteChipEl = document.getElementById('myVoteChip');
const leaderboardBoardEl = document.getElementById('leaderboardBoard');
const leaderboardImgEl   = document.getElementById('leaderboardImg');

const centerDecksEl = document.getElementById('centerDecks');
const requiredSweetsTagEl = document.getElementById('requiredSweetsTag');

/* ✅ 追加：ラウンドチップ（R1/R2/R3） */
const roundChipsEl = document.getElementById('roundChips');
const roundChipImgEls = Array.from(document.querySelectorAll('#roundChips .round-chip-img'));


/* 中央の山札UI */
const actionDeckUI = document.getElementById('actionDeckUI');
const actionDeckCountEl = document.getElementById('actionDeckCount');
const sweetsDeckUI = document.getElementById('sweetsDeckUI');
const sweetsDeckCountEl = document.getElementById('sweetsDeckCount');
const sweetsExcludedDeckUI = document.getElementById('sweetsExcludedDeckUI');
const sweetsExcludedDeckCountEl = document.getElementById('sweetsExcludedDeckCount');


/* スイーツ一覧（ローカル） */
const sweetsBackdrop = document.getElementById('sweetsBackdrop');
const sweetsDropZone = document.getElementById('sweetsDropZone');
const btnSweetsClose = document.getElementById('btnSweetsClose');
const sweetsGrid = document.getElementById('sweetsGrid');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

/* ヘルプ */
const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

/* ターン操作バー */
const turnBar = document.getElementById('turnBar');
const turnBadge = document.getElementById('turnBadge');
const btnPass = document.getElementById('btnPass');
const btnDrawSweets = document.getElementById('btnDrawSweets');
const btnVote = document.getElementById('btnVote');

/* 右下PASS（ラウンド用） */
const passRoundBtn = document.getElementById('passRoundBtn');

/* ラウンド公開（複数） */
const roundRevealOverlay = document.getElementById('roundRevealOverlay');
const roundRevealRow = document.getElementById('roundRevealRow');

/* 中央拡大（単体） */
const revealOverlay = document.getElementById('revealOverlay');
const revealImg = document.getElementById('revealImg');
const revealLabel = document.getElementById('revealLabel');
const revealEffectFrame = document.getElementById('revealEffectFrame');
const revealEffect = document.getElementById('revealEffect');

/* =========================
   ユーティリティ
   ========================= */
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}
function shuffle(arr){
  const a = [...arr];
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function now(){ return Date.now(); }

/* ✅ 追加：勝利点テーブル（人数×ラウンド） */
function getRoundWinThreshold(playerCount, roundNo){
  const r = clamp(roundNo ?? 1, 1, 3);
  if(playerCount <= 4)  return [8,10,12][r-1];
  if(playerCount <= 6)  return [12,14,16][r-1];
  return [16,18,20][r-1]; // 7〜8人想定
}

/* ✅ 追加：選ばれたスイーツ合計点（cards配列のvalue合計） */
function calcSweetsTotalPoints(cards){
  const arr = Array.isArray(cards) ? cards : [];
  return arr.reduce((sum, c) => {
    const v =
      (c && typeof c.value === 'number') ? c.value :
      (c && typeof c.name === 'string') ? (parseInt(c.name, 10) || 0) :
      0;
    return sum + v;
  }, 0);
}

/* ✅ 追加：roundchip表示（game.roundChipsを反映） */
function renderRoundChipsFromGame(){
  if(!roundChipImgEls || !roundChipImgEls.length) return;
  const chips = (state.game && typeof state.game === 'object' && state.game.roundChips) ? state.game.roundChips : {};
  roundChipImgEls.forEach((img, idx) => {
    const r = String(idx + 1);
    const src = chips?.[r] || chips?.[idx + 1] || null; // 数字キー/文字キー両対応
    if(src){
      img.src = src;
      img.classList.remove('hidden');
    }else{
      img.removeAttribute('src');
      img.classList.add('hidden');
    }
  });
}



const roundRevealState = {
  started: false,
  finished: false,
  startedAt: null,
  finishedAt: null,
};

function resetRoundRevealState(){
  roundRevealState.started = false;
  roundRevealState.finished = false;
  roundRevealState.startedAt = null;
  roundRevealState.finishedAt = null;
}

function markRoundRevealStarted(){
  roundRevealState.started = true;
  roundRevealState.startedAt = now();
  roundRevealState.finished = false;
  roundRevealState.finishedAt = null;
}

function markRoundRevealFinished(){
  roundRevealState.finished = true;
  roundRevealState.finishedAt = now();
}

async function waitForRoundRevealCompletion(timeoutMs = 10000){
  const start = now();
  while(true){
    if(roundRevealState.started && roundRevealState.finished) return true;
    if(timeoutMs && now() - start > timeoutMs) return false;
    await sleep(50);
  }
}

function resetLocalGameEffects(){
  stopRoundEndFx();
  resetRoundRevealState();
  resetCollectedSweetsHiddenCache();

  miniShuffleToken += 1;
  miniShuffleRunning = false;
  sweetsExcludeAnimating = false;
  turnBlockedByShuffle = false;

  if(revealTimer){
    clearTimeout(revealTimer);
    revealTimer = null;
  }
  revealOverlay.classList.add('hidden');

  clearActionSelection();
  revealedRoleUids.clear();
  pendingWiretapZoomUid = null;

  if(sweetsOverrideClearTimer){
    clearTimeout(sweetsOverrideClearTimer);
    sweetsOverrideClearTimer = null;
  }
  sweetsDeckCountOverride = null;
  sweetsExcludedCountOverride = null;

  document.querySelectorAll('.sweets-shuffle-stage, .sweets-move-card, .collect-card')
    .forEach(el => el.remove());

  roundRevealRow.innerHTML = '';
  roundRevealOverlay.classList.add('hidden');

  updateActionDeckUI();
  updateSweetsDeckUI();
}


function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function setLeaderboardImageBase(base){
  if(!leaderboardImgEl) return;
  // 既定は .jpg → ダメなら .png → .webp
  leaderboardImgEl.dataset.base = base;
  leaderboardImgEl.dataset.try = 'jpg';
  leaderboardImgEl.src = `${base}.jpg`;
}
if (leaderboardImgEl){
  leaderboardImgEl.addEventListener('error', () => {
    const base = leaderboardImgEl.dataset.base || '';
    const tried = leaderboardImgEl.dataset.try || 'jpg';
    if(!base) return;

    if(tried === 'jpg'){
      leaderboardImgEl.dataset.try = 'png';
      leaderboardImgEl.src = `${base}.png`;
      return;
    }
    if(tried === 'png'){
      leaderboardImgEl.dataset.try = 'webp';
      leaderboardImgEl.src = `${base}.webp`;
      return;
    }
    // ここまで来たら諦めて非表示（無限エラー防止）
    leaderboardBoardEl?.classList.add('hidden');
  });
}

function updateLeaderboardBoardByPlayerCount(n){
  if(!leaderboardBoardEl || !leaderboardImgEl) return;

  let base = null;
  if(n >= 1 && n <= 4) base = 'swleaderboard1';
  else if(n >= 5 && n <= 6) base = 'swleaderboard2';
  else if(n >= 7 && n <= 8) base = 'swleaderboard3';

  if(!base){
    leaderboardBoardEl.classList.add('hidden');
    leaderboardBoardEl.setAttribute('aria-hidden','true');
    return;
  }

  leaderboardBoardEl.classList.remove('hidden');
  leaderboardBoardEl.setAttribute('aria-hidden','false');

  // 同じbaseなら張り替えない
  if(leaderboardImgEl.dataset.base !== base){
    setLeaderboardImageBase(base);
  }
}


/* =========================
   ★ 中央：アクション山札UI
   ========================= */
function updateActionDeckUI(){
  const deck = state.room?.decks?.action;
  const count = Array.isArray(deck) ? deck.length : 0;

  const started = !!state.room?.gameStarted;
  centerDecksEl.classList.toggle('hidden', !started);

  actionDeckUI.classList.toggle('hidden', !started);
  actionDeckCountEl.textContent = String(count);

  const stackN =
    count >= 20 ? 5 :
    count >= 12 ? 4 :
    count >= 6  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = actionDeckUI.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

/* =========================
   ★ 中央：スイーツ山札UI（残り枚数/山札感/鼓動）
   ========================= */
function getMySweetsCard(){
  const myData = state.hands?.[state.userId];
  const arr = myData?.sweets;
  if(Array.isArray(arr) && arr.length) return arr[0];
  return null;
}
function hasSweets(){
  return !!getMySweetsCard();
}
function clearSweetsCountOverridesIfSynced(liveCount, liveExcluded){
  if(sweetsDeckCountOverride === null && sweetsExcludedCountOverride === null) return;
  if(sweetsDeckCountOverride === liveCount && sweetsExcludedCountOverride === liveExcluded){
    sweetsDeckCountOverride = null;
    sweetsExcludedCountOverride = null;
    if(sweetsOverrideClearTimer){
      clearTimeout(sweetsOverrideClearTimer);
      sweetsOverrideClearTimer = null;
    }
  }
}
function setSweetsCountOverrides(deckCount, excludedCount, autoClearMs = 0){
  sweetsDeckCountOverride = deckCount;
  sweetsExcludedCountOverride = excludedCount;
  if(sweetsOverrideClearTimer){
    clearTimeout(sweetsOverrideClearTimer);
    sweetsOverrideClearTimer = null;
  }
  if(autoClearMs > 0){
    sweetsOverrideClearTimer = setTimeout(() => {
      sweetsDeckCountOverride = null;
      sweetsExcludedCountOverride = null;
      sweetsOverrideClearTimer = null;
      updateSweetsDeckUI();
    }, autoClearMs);
  }
}
function updateDeckStackUI(deckEl, count){
  if(!deckEl) return;
  const stackN =
    count >= 10 ? 5 :
    count >= 8  ? 4 :
    count >= 5  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = deckEl.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

function updateSweetsDeckUI(){
  const deck = state.room?.decks?.sweets;
  const excludedDeck = state.room?.decks?.sweetsExcluded;
  const liveCount = Array.isArray(deck) ? deck.length : 0;
  const liveExcluded = Array.isArray(excludedDeck) ? excludedDeck.length : 0;

  clearSweetsCountOverridesIfSynced(liveCount, liveExcluded);

  const count = sweetsDeckCountOverride ?? liveCount;
  const excludedCount = sweetsExcludedCountOverride ?? liveExcluded;


  const started = !!state.room?.gameStarted;
  centerDecksEl.classList.toggle('hidden', !started);

  sweetsDeckUI.classList.toggle('hidden', !started || miniShuffleRunning);
  sweetsExcludedDeckUI.classList.toggle('hidden', !started || miniShuffleRunning || (!sweetsExcludeAnimating && excludedCount <= 0));
  sweetsDeckCountEl.textContent = String(count);

 sweetsExcludedDeckCountEl.textContent = String(excludedCount);

  updateDeckStackUI(sweetsDeckUI, count);
  updateDeckStackUI(sweetsExcludedDeckUI, excludedCount);


  const instructionNames = getActiveInstructionNames();
  const sweetsAllowed = instructionNames.has('応援') || instructionNames.has('脅迫') || instructionNames.size === 0;
  const pulsing = isMyTurn() && !hasSweets() && sweetsAllowed && !isActionSelectionActive();
  sweetsDeckUI.classList.toggle('pulsing', pulsing);
}

function getRequiredSweetsCount(){
  const nPlayers = latestPlayers.length;
  if(nPlayers <= 0) return 0;
  const baseNeed = requiredPickCountByPlayers(nPlayers);
  const rp = getRoundPick();
  const remaining = Number(rp?.need ?? NaN);
  if(rp?.phase === 'choose' && Number.isFinite(remaining) && remaining > 0){
    return remaining;
  }
  return baseNeed;
}

function updateRequiredSweetsTag(){
  if(!requiredSweetsTagEl) return;
  const started = !!state.room?.gameStarted;
  const hasPlayers = latestPlayers.length > 0;
  requiredSweetsTagEl.classList.toggle('hidden', !(started && hasPlayers));
  if(!(started && hasPlayers)) return;
  const count = getRequiredSweetsCount();
  requiredSweetsTagEl.textContent = `🍰${count}`;
}


/* =========================
   ヘルプ（正体カード）
   ========================= */
function roleToHelp(role){
  if(role === 'usakoma'){
    return { name:"うさこま", img:"swsweetsurakoma.jpg", text:"（説明は後で）" };
  }
  if(role === 'uragiri'){
    return { name:"裏切り者", img:"swsweetsuragiri.jpg", text:"（説明は後で）" };
  }
  return { name:"不明", img:"swroleura.jpg", text:"" };
}
function renderHelpList(){
  helpBody.innerHTML = '';
  const list = [
    { name:"うさこま", img:"swsweetsurakoma.jpg", text:"（説明は後で）" },
    { name:"裏切り者", img:"swsweetsuragiri.jpg", text:"（説明は後で）" },
  ];
  list.forEach((r) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    const img = document.createElement('img');
    img.src = r.img;
    img.alt = r.name;
    card.appendChild(img);

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;

    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

/* =========================
   Seat 復元
   ========================= */
async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

/* =========================
   subscribe
   ========================= */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();

    updateActionDeckUI();
    updateSweetsDeckUI();
    updateRequiredSweetsTag();
    renderHands();
    renderMyVoteChip();
renderMySweetsVoteStack();
    updatePassRoundBtn();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex),
        tagChipStyle: t.tagChipStyle || null,
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
updateLeaderboardBoardByPlayerCount(players.length); 
    updatePassRoundBtn();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
    updatePassRoundBtn();
  });
}
function subscribeRoles(){
  const rolesRef = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderHands();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    const prevLeaderSeat = state.turn?.leaderSeat ?? null;
    state.game = snap.val() || {};
    state.turn = state.game.turn || null;
    state.turnEnding = false;
    const nextSessionId = state.game?.sessionId || null;
    const sessionChanged = nextSessionId !== currentGameSessionId;
    if(sessionChanged){
      resetLocalGameEffects();
      currentGameSessionId = nextSessionId;
    } else {
      resetCollectedSweetsHiddenCache();
    }
    syncPassTurnState();
    updateTurnUI();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    renderRoundChipsFromGame();

    // ★ ホスト：全員PASSになったらラウンド終了処理へ
    if(state.isHost){
      maybeHostStartRoundEndFlow().catch(()=>{});
      maybeHostFireRoundRevealAfterLeaderPick().catch(()=>{});
      maybeHostApplyLeaderPick();
    }
    // ★ リーダー選択UI更新（同票解決）
    updateRoundPickUI();
    updateLeaderPickUI();
    updatePassRoundBtn();

    const nextLeaderSeat = state.turn?.leaderSeat ?? null;
    if(prevLeaderSeat !== null && nextLeaderSeat !== null && prevLeaderSeat !== nextLeaderSeat){
      requestAnimationFrame(() => animateLeaderChipMove(prevLeaderSeat, nextLeaderSeat));
    }
    lastLeaderSeat = nextLeaderSeat;
  });
}
function subscribeEvents(){
  const evRef = ref(db, `rooms/${state.roomCode}/events`);
  eventsSubscribedAt = now();
 onChildAdded(evRef, async snap => {
    const key = snap.key;
    const ev = snap.val();
    if(!ev) return;
    const expectedSessionId = state.game?.sessionId || currentGameSessionId || null;
    if(ev.sessionId){
      if(expectedSessionId && ev.sessionId !== expectedSessionId) return;
      if(!currentGameSessionId) currentGameSessionId = ev.sessionId;
    }
    if(!expectedSessionId && !currentGameSessionId) return;
   const isStaleEvent = typeof ev.at === 'number' && eventsSubscribedAt && ev.at < eventsSubscribedAt;
    if(isStaleEvent && ['miniSweetsShuffleStart','roundRevealSweets','revealCard','flyBackCard','wiretapArrow'].includes(ev.type)) return;
    if(ev.type === 'revealCard'){
      showReveal(ev.card);
    }
    if(ev.type === 'flyBackCard'){
      animateFlyBackCard(ev.fromSeat, ev.toSeat);
    }
   if(ev.type === 'dealActionCard'){
      const delayMs = (typeof ev.delayMs === 'number') ? ev.delayMs : 0;
      animateActionDealCard(ev.toSeat, delayMs);
    }
    if(ev.type === 'actionDrawToHand'){
      const delayMs = (typeof ev.delayMs === 'number') ? ev.delayMs : 0;
      animateActionDrawToHand(ev.toUid, ev.toSeat, delayMs);
    }
    if(ev.type === 'wiretapArrow'){
      if(ev.fromUid !== state.userId && ev.fromSeat !== null && ev.toSeat !== null){
        showWiretapArrow(ev.fromSeat, ev.toSeat);
      }
    }

    // ★ ラウンド終了演出（全員）
    if(ev.type === 'roundRevealSweets'){
      // ev.cards: 表にするカード配列（スイーツカード）
      await animateRoundEndReveal(ev.cards || [], ev.selectedUids || []);
  await animateReturnAllFieldSweetsToDeck();
  // ✅ その直後：除外札を「縦になって」山札へ回収
  await animateReturnExcludedDeckToSweetsDeck();
  await hostFinalizeReturnSweetsToDeck(ev.cards || []);

    }
    if(ev.type === 'miniSweetsShuffleStart'){
      await runMiniSweetsShuffleAtStart(ev);
    }

    if(state.isHost){
      maybeHostStartRoundEndFlow().catch(()=>{});
    }
  });
}

function normalizeTagChipStyle(styleClass){
  return TAG_CHIP_STYLES.includes(styleClass) ? styleClass : null;
}
function applyTagChipStyle(el, styleClass){
  if(!el) return;
  TAG_CHIP_STYLES.forEach(style => el.classList.remove(style));
  const normalized = normalizeTagChipStyle(styleClass);
  if(normalized) el.classList.add(normalized);
}
function getTagChipStyleByUid(uid){
  if(!uid) return null;
  const tables = state.room?.tables;
  if(!tables || typeof tables !== 'object') return null;
  const entry = Object.values(tables).find(t => t && t.playerId === uid);
  return normalizeTagChipStyle(entry?.tagChipStyle);
}
function pickRandomTagChipStyle(tables){
  const used = new Set();
  Object.values(tables || {}).forEach((t) => {
    if(t && normalizeTagChipStyle(t.tagChipStyle)){
      used.add(t.tagChipStyle);
    }
  });
  const available = TAG_CHIP_STYLES.filter(style => !used.has(style));
  const pool = available.length ? available : TAG_CHIP_STYLES;
  return pool[Math.floor(Math.random() * pool.length)];
}

/* =========================
   ターン管理（PASS対応：passした人は飛ばす）
   ========================= */
function getSeatedSeatOrder(){
  return latestPlayers.map(p => p.seatIndex).sort((a,b)=>a-b);
}
function getPlayerBySeat(seatIndex){
  return latestPlayers.find(p => p.seatIndex === seatIndex) || null;
}
function getPlayerByUid(uid){
  return latestPlayers.find(p => p.id === uid) || null;
}
function getSeatByUid(uid){
  const fromPlayers = getPlayerByUid(uid);
  if(fromPlayers) return fromPlayers.seatIndex;
  const tables = state.room?.tables;
  if(tables && typeof tables === 'object'){
    const entry = Object.entries(tables).find(([, t]) => t && t.playerId === uid);
    if(entry){
      return Number(entry[0]);
    }
  }
  return null;
}
function getPassedMap(){
  const p = state.game?.passes;
  return (p && typeof p === 'object') ? p : {};
}
function isPassedPlayerId(uid){
  const pm = getPassedMap();
  return !!pm?.[uid];
}
function isTurnBlocked(){
  return !!turnBlockedByShuffle;
}

async function hostGrantTurnAfterMiniShuffle(){
  if(!state.isHost || !state.roomCode) return;
  if(state.game?.turn) return;
  const seats = getSeatedSeatOrder();
  if(!seats.length) return;
  const leaderSeat = seats[Math.floor(Math.random() * seats.length)];
  const leaderIdx = seats.indexOf(leaderSeat);
  const nextSeat = seats[(leaderIdx + 1) % seats.length];
  const player = getPlayerBySeat(nextSeat);
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await set(turnRef, {
    activeSeat: nextSeat,
    activePlayerId: player?.id ?? null,
    startSeat: nextSeat,
    leaderSeat: leaderSeat,
   turnNo: 1,
    updatedAt: serverTimestamp(),
  });
}

async function hostRestartTurnAfterActionDeal(leaderSeat){
  if(!state.isHost || !state.roomCode) return;
  if(leaderSeat == null) return;

  const base = `rooms/${state.roomCode}/game`;
  const gameSnap = await get(ref(db, base));
  const gameNow = gameSnap.val() || {};
  const seatOrder = Array.isArray(gameNow.seatOrder) && gameNow.seatOrder.length
    ? gameNow.seatOrder
    : getSeatedSeatOrder();
  if(!seatOrder.length) return;

  const leaderIdx = seatOrder.indexOf(leaderSeat);
  const nextSeat = (leaderIdx === -1)
    ? seatOrder[0]
    : seatOrder[(leaderIdx + 1) % seatOrder.length];
  const nextPlayer = getPlayerBySeat(nextSeat);

  await update(ref(db, base), {
    passes: {},
    roundEnding: false,
    roundPick: null,
    leaderPick: null,
    turn: {
      activeSeat: nextSeat,
      activePlayerId: nextPlayer?.id ?? null,
      startSeat: nextSeat,
      leaderSeat: leaderSeat,
      turnNo: 1,
      updatedAt: serverTimestamp(),
    },
  });
}

function getNextOccupiedSeatSkippingPassed(currentSeat){
  const seats = getSeatedSeatOrder();
  if(!seats.length) return null;

  const startIdx = seats.indexOf(currentSeat);
  const begin = (startIdx === -1) ? 0 : startIdx;

  for(let step=1; step<=seats.length; step++){
    const s = seats[(begin + step) % seats.length];
    const p = getPlayerBySeat(s);
    if(!p) continue;
    if(!isPassedPlayerId(p.id)) return s;
  }
  // 全員pass済みなら、通常はここに来ない（ラウンド終了に入る）
  return seats[(begin + 1) % seats.length];
}
function isMyTurn(){
  if(!state.turn) return false;
  if(isTurnBlocked()) return false;
  if(state.game?.roundEnding) return false;
  if(allSeatedPlayersPassed()) return false;
  return (state.turn.activePlayerId === state.userId);
}

async function endTurn(reason){
  if(!state.roomCode || !state.turn) return;
  if(!isMyTurn()) return;

  state.turnEnding = true;
  updatePassRoundBtn();

  await discardReceivedInstructionsForTurn();

  const nextSeat = getNextOccupiedSeatSkippingPassed(state.turn.activeSeat);
  if(nextSeat == null) return;

  const nextP = getPlayerBySeat(nextSeat);
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await update(turnRef, {
    activeSeat: nextSeat,
    activePlayerId: nextP?.id || null,
    lastEndReason: reason,
    updatedAt: serverTimestamp(),
    turnNo: (state.turn.turnNo || 1) + 1,
  });
}

/* =========================
   デッキ構築（アクションカード）
   ========================= */
const ACTION_COUNTS_BASE = [
  { name:'監禁', count:1, kind:'normal' },
  { name:'盗聴', count:1, kind:'normal' },
  { name:'世代交代', count:1, kind:'normal' },
  { name:'宣伝', count:1, kind:'normal' },

  { name:'強奪', count:2, kind:'normal' },
  { name:'偵察', count:100, kind:'normal' },
  { name:'ひらめき', count:2, kind:'normal' },
  { name:'仕込み', count:2, kind:'normal' },
  { name:'交換', count:2, kind:'normal' },
  { name:'試行錯誤',     count:2, kind:'normal' },
  { name:'事故',     count:2, kind:'normal' },
  { name:'激推し',     count:4, kind:'normal' },
  { name:'無視', count:2, kind:'instruction' },


  { name:'応援', count:4, kind:'instruction' },
  { name:'賄賂', count:4, kind:'instruction' },
  { name:'脅迫', count:4, kind:'instruction' },

];
const ACTION_COUNTS_7P = [
  { name:'強奪', count:1, kind:'normal' },
  { name:'偵察', count:1, kind:'normal' },
  { name:'ひらめき', count:1, kind:'normal' },
  { name:'仕込み', count:1, kind:'normal' },
  { name:'交換', count:1, kind:'normal' },
  { name:'試行錯誤',     count:1, kind:'normal' },
  { name:'事故',     count:1, kind:'normal' },
  { name:'激推し',     count:1, kind:'normal' },
  { name:'無視', count:1, kind:'instruction' },


  { name:'応援', count:1, kind:'instruction' },
  { name:'賄賂', count:1, kind:'instruction' },
  { name:'脅迫', count:1, kind:'instruction' },
];
const INSTRUCTION_NEED_TARGET = new Set(['応援','脅迫','賄賂','無視']);
const INSTRUCTION_CAN_SELF = new Set(['無視']);

function cardNameToImg(name){
  if(name === '') return 'blank.jpg';
  return `${name}.jpg`;
}
function buildActionDeck(playerCount){
  const list = [];
  const counts = [...ACTION_COUNTS_BASE, ...(playerCount >= 7 ? ACTION_COUNTS_7P : [])];
  counts.forEach(def => {
    for(let i=0;i<def.count;i++){
      list.push({
        id: crypto.randomUUID(),
        name: def.name,
        kind: def.kind,
        img: cardNameToImg(def.name),
        backImg: `swactionura.jpg`,
        effectText: getActionEffectText(def.name),
      });
    }
  });
  return shuffle(list);
}
function getActionEffectText(cardName){
  const map = {
    '監禁': '選んだプレイヤーの前に置かれているスイーツは出品できない。',
    '盗聴': '選んだプレイヤーの正体カードを見る。',
    '世代交代': 'リーダーになる。',
    '宣伝': '選んだプレイヤーのスイーツを公開する。',
    '強奪': '置かれている任意の投票チップを1つ移動させる。',
    '偵察': '選んだプレイヤーのアクションカードを見る。',
    'ひらめき': '除外した山札からスイーツを作る。',
    '仕込み': 'アクションカードを1枚ひく。',
    '交換': '選んだプレイヤーとスイーツを交換する。',
    '試行錯誤': '一番上の除外カードをレシピに加える。そしてレシピから1枚選んで除外する。',
    '激推し': '新たな投票チップを得て、投票する。',
    '事故': '選んだプレイヤーのスイーツをレシピに戻す。',
    '応援': '渡されたら、次の手番で一番数字が大きいスイーツを作る。',
    '脅迫': '渡されたら、次の手番で一番数字が小さいスイーツを作る。',
    '賄賂': '渡されたら、次の手番で受け取った相手のスイーツに投票する。',
    '無視': '渡られたら、他の指示を無視できる。自分で使ったら、手番が終わる。',
  };
  return map[cardName] ?? '（効果は後で）';
}

/* =========================
   ★ スイーツデッキ構築
   ========================= */
const SWEETS_BACK_IMG = 'swsweetsura.jpg';

function buildSweetsPool(){
  const base = [
    { value:0, img:'sw0.jpg', fallback:'sw1.jpg' },
    { value:1, img:'sw1.jpg' },
    { value:2, img:'sw2.jpg' },
    { value:3, img:'sw3.jpg' },
    { value:3, img:'sw3(2).jpg' },
    { value:4, img:'sw4.jpg' },
    { value:4, img:'sw4(2).jpg' },
    { value:5, img:'sw5.jpg' },
    { value:5, img:'sw5(2).jpg' },
    { value:6, img:'sw6.jpg' },
    { value:7, img:'sw7.jpg' },
    { value:8, img:'sw8.jpg' },
  ];
  return base.map(b => ({
    id: crypto.randomUUID(),
    kind: 'sweets',
    value: b.value,
    name: String(b.value),
    img: b.img,
    backImg: SWEETS_BACK_IMG,
    fallback: b.fallback || null,
  }));
}
function buildSweetsDeck(playerCount){
  const pool = buildSweetsPool();
  return shuffle(pool);
}
function splitSweetsDeck(deck, playerCount){
  const total = Array.isArray(deck) ? deck.length : 0;
  const keepCount = clamp(playerCount + 2, 0, total);
  if(!Array.isArray(deck) || total <= keepCount){
    return { sweets: Array.isArray(deck) ? deck : [], excluded: [] };
  }
  const shuffled = shuffle([...deck]);
  return {
    sweets: shuffled.slice(0, keepCount),
    excluded: shuffled.slice(keepCount),
  };
}

/* =========================
   正体カード配布
   ========================= */
function buildRolePool(n){
  const usakoma = Math.ceil(n/2);
  const uragiri = Math.floor(n/2);
  const pool = [];
  for(let i=0;i<usakoma;i++) pool.push('usakoma');
  for(let i=0;i<uragiri;i++) pool.push('uragiri');
  return shuffle(pool);
}

/* =========================
   ゲーム開始（ホストのみ）
   ========================= */
async function hostGameStart(){
  if(!state.isHost || !state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? {
      id: t.playerId,
      name: t.playerName || '名無し',
      seatIndex: Number(seatIndex)
    } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex-b.seatIndex);

  if(players.length === 0) return;

  const seats = players.map(p=>p.seatIndex).sort((a,b)=>a-b);

  let actionDeck = buildActionDeck(players.length);
  const sweetsDeck = buildSweetsDeck(players.length);

  const hands = {};
  players.forEach(p => {
    hands[p.id] = {
      action: actionDeck.splice(0, 3),
      sweets: [],
      received: [],
      voteChips: 1,
    };
  });

  const pool = buildRolePool(players.length);
 const roles = {};
  players.forEach((p, i) => { roles[p.id] = pool[i]; });

  const base = `rooms/${state.roomCode}`;
  const gameSessionId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  await update(ref(db, `${base}/game`), { turn: null });
  await update(ref(db, `${base}`), { gameStarted: true });
  await remove(ref(db, `${base}/events`));
  await set(ref(db, `${base}/hands`), {});
  await set(ref(db, `${base}/roles`), {});
  await set(ref(db, `${base}/discard`), { action: [] });

  await set(ref(db, `${base}/decks`), { action: actionDeck, sweets: sweetsDeck, sweetsExcluded: [] });



  await Promise.all([
    set(ref(db, `${base}/hands`), hands),
    set(ref(db, `${base}/roles`), roles),
  ]);

  await set(ref(db, `${base}/votes`), {});
  await set(ref(db, `${base}/game`), {
    status: 'playing',
    startedAt: serverTimestamp(),
    sessionId: gameSessionId,
    seatOrder: seats,
    passes: {},               // ★ ラウンドPASS
    roundEnding: false,       // ★ ラウンド終了中フラグ
    roundPick: null,          // ★ 同票解決状態
    leaderPick: null,         // ★ リーダー移行状態
    actionDealKey: null,      // ★ リーダー配布の重複防止
    roundNo: 1,
    roundChips: {},
    turn: null

  });

  await emitEvent({ type: 'miniSweetsShuffleStart', reason: 'gameStart', sessionId: gameSessionId });

  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   イベント（全員演出用）
   ========================= */
async function emitEvent(payload){
  if(!state.roomCode) return;
  const evRef = ref(db, `rooms/${state.roomCode}/events`);
  const sessionId = payload.sessionId ?? currentGameSessionId ?? state.game?.sessionId ?? null;
  const eventPayload = { ...payload, at: now() };
  if(sessionId) eventPayload.sessionId = sessionId;
  await push(evRef, eventPayload);
}


/* =========================
   中央拡大（全員1秒）
   ========================= */
let revealTimer = null;
function showReveal(card){
  if(!card) return;
  revealImg.src = card.img || '';
  revealLabel.textContent = card.name || '';
  const isActionCard = card.kind === 'normal' || card.kind === 'instruction';
  revealLabel.classList.toggle('hidden', isActionCard || !card.name);
  const effectText = card.effectText || card.text || '';
  revealEffect.textContent = effectText;
  revealEffectFrame.classList.toggle('hidden', !effectText);
  revealOverlay.classList.remove('hidden');
  if(revealTimer) clearTimeout(revealTimer);
  revealTimer = setTimeout(()=>{
    revealOverlay.classList.add('hidden');
  }, 1800);
}







/* =========================
   指示カード：裏カード移動アニメ（全員）
   ========================= */
function animateFlyBackCard(fromSeat, toSeat){
  const fromEl = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  const toEl   = document.querySelector(`.player-tag[data-seat="${toSeat}"]`);
  if(!fromEl || !toEl) return;

  const fr = fromEl.getBoundingClientRect();
  const tr = toEl.getBoundingClientRect();

  const fly = document.createElement('div');
  fly.className = 'fly-card';
  fly.style.left = `${fr.right + 6}px`;
  fly.style.top  = `${fr.top + fr.height/2 - 16}px`;
  document.body.appendChild(fly);

  const toX = (tr.right + 6) - (fr.right + 6);
  const toY = (tr.top + tr.height/2 - 16) - (fr.top + fr.height/2 - 16);

  fly.animate([
    { transform:`translate(0px,0px) scale(1)`, opacity:1 },
    { transform:`translate(${toX}px,${toY}px) scale(1.05)`, opacity:1 }
  ], {
    duration: 520,
    easing: 'cubic-bezier(.22,.84,.44,1)'
  }).onfinish = () => fly.remove();
}

/* =========================
   文字を枠内に収める
   ========================= */
function fitEffectText(el){
  if(!el) return;
  const box = el.parentElement;
  if(!box) return;

  const styles = getComputedStyle(box);
  const paddingTop = parseFloat(styles.paddingTop) || 0;
  const paddingBottom = parseFloat(styles.paddingBottom) || 0;
  const availableHeight = box.clientHeight - paddingTop - paddingBottom;

  const maxSize = 13;
  const minSize = 6;
  let size = maxSize;
  el.style.fontSize = size + 'px';

  while(size > minSize && el.scrollHeight > availableHeight){
    size -= 1;
    el.style.fontSize = size + 'px';
  }
}

/* =========================
   ★ 受け取り指示カード
   ========================= */
function getMyReceivedCards(){
  const myData = state.hands?.[state.userId];
  const rec = myData?.received;
  return Array.isArray(rec) ? rec : [];
}
function hasReceivedInstruction(){
  return getMyReceivedCards().length > 0;
}
function hasReceivedIgnoreCard(cards = getMyReceivedCards()){
  return cards.some(card => card?.name === '無視');
}
function getActiveInstructionCards(){
  const cards = getMyReceivedCards();
  if(!cards.length) return [];
  if(hasReceivedIgnoreCard(cards)) return [];
  const active = [];
  const sweetsMissing = !hasSweets();
  const canBribe = getMyVoteChips() > 0;
  cards.forEach(card => {
    if(card?.name === '応援' || card?.name === '脅迫'){
      if(sweetsMissing) active.push(card);
    } else if(card?.name === '賄賂'){
      if(canBribe) active.push(card);
    }
  });
  return active;
}
function isInstructionTurnBlocked(){
  return isMyTurn() && getActiveInstructionCards().length > 0 && !isActionSelectionActive();
}
function getActiveInstructionNames(){
  return new Set(getActiveInstructionCards().map(card => card?.name));
}
function getActiveBribeTargetUid(){
  const card = getActiveInstructionCards().find(c => c?.name === '賄賂');
  if(card?.fromUid) return card.fromUid;
  if(card?.fromSeat != null){
    const p = getPlayerBySeat(card.fromSeat);
    return p?.id ?? null;
  }
  return null;
}


/* =========================
   ★ スイーツ回収（拡大表示終了後）
   - 場のスイーツ（selected / 非selected）を山札へ
   - その直後、除外札は縦になって山札へ
   ========================= */

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

async function waitUntilHidden(el, timeoutMs = 4500){
  const start = Date.now();
  while(Date.now() - start < timeoutMs){
    if(!el || el.classList.contains('hidden')) return;
    await sleep(50);
  }
}

function isVisibleRect(el){
  if(!el) return false;
  const r = el.getBoundingClientRect();
  return !!(r.width && r.height);
}

function isFieldElement(el){
  if(!el) return false;
  // オーバーレイ中のカードは対象外
  if(el.closest('#roundRevealOverlay')) return false;
  if(el.closest('#revealOverlay')) return false;
  if(el.closest('#sweetsBackdrop')) return false;
  return isVisibleRect(el);
}

function getSweetsDeckTargetRect(){
  if(!sweetsDeckUI) return null;
  const r = sweetsDeckUI.getBoundingClientRect();
  if(!r.width || !r.height) return null;
  return {
    x: r.left + r.width/2,
    y: r.top + r.height/2,
    w: r.width,
    h: r.height,
    raw: r
  };
}

function getCollectAnimationSnapshot(el){
  if(!el) return null;
  const rect = el.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  const width = el.offsetWidth || rect.width;
  const height = el.offsetHeight || rect.height;
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  const hostCircle = el.closest('.otherplayerscircle');
  const rotValue = hostCircle ? getComputedStyle(hostCircle).getPropertyValue('--rotDeg').trim() : '0deg';
  const rotateDeg = parseRotationDegrees(rotValue);

  return {
    left: centerX - width / 2,
    top: centerY - height / 2,
    width,
    height,
    rotateDeg,
  };
}

function normalizeRotationDegrees(fromDeg, toDeg){
  const from = Number.isFinite(fromDeg) ? fromDeg : 0;
  const to = Number.isFinite(toDeg) ? toDeg : 0;
  const diff = ((from - to + 540) % 360) - 180;
  return to + diff;
}

function animateOneCardToDeck(srcRect, target, { delay = 0, rotateFrom = 0, rotateTo = 0 } = {}){
  if(!srcRect || !srcRect.width || !srcRect.height || !target) return Promise.resolve();

  const fly = document.createElement('div');
  fly.className = 'collect-card';
  fly.style.left = `${srcRect.left}px`;
  fly.style.top  = `${srcRect.top}px`;
  fly.style.width  = `${srcRect.width}px`;
  fly.style.height = `${srcRect.height}px`;
  fly.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  fly.style.zIndex = '999999';
  document.body.appendChild(fly);

  const dx = target.x - (srcRect.left + srcRect.width/2);
  const dy = target.y - (srcRect.top  + srcRect.height/2);

  const scaleX = target.w / srcRect.width;
  const scaleY = target.h / srcRect.height;
  const scale  = Math.min(scaleX, scaleY);

  const normalizedRotateFrom = normalizeRotationDegrees(rotateFrom, rotateTo);

  return new Promise(resolve => {
    fly.animate([
      { transform:`translate(0px,0px) rotate(${normalizedRotateFrom}deg) scale(1)`, opacity:1 },
      { transform:`translate(0px,0px) rotate(${rotateTo}deg) scale(1)`, opacity:1, offset:0.55 },
      { transform:`translate(${dx}px,${dy}px) rotate(${rotateTo}deg) scale(${scale})`, opacity:0.92 },
    ],{
      duration: 780,
      delay,
      easing: 'cubic-bezier(.22,.84,.44,1)',
      fill: 'forwards'
    }).onfinish = () => {
      fly.remove();
      resolve();
    };
  });
}

async function animateReturnAllFieldSweetsToDeck(){

  // 「拡大公開が実行済み & 終了済み」を待つ
  const revealDone = await waitForRoundRevealCompletion();
  if(!revealDone) return;
  await sleep(800);

  const target = getSweetsDeckTargetRect();
  if(!target) return;

  const sources = [];

  // 1) selected（ネームタグ上の selected-sweets-card）
  document.querySelectorAll('.selected-sweets-card').forEach(cardEl => {
    if(!isFieldElement(cardEl)) return;
    sources.push({
      el: cardEl,
      host: cardEl.closest('.selected-sweets-tag') || cardEl,
      uid: (cardEl.closest('.selected-sweets-tag')?.dataset?.sweetsUid) || null
    });
  });

  // 2) 非selected（他プレイヤーの sweets-wrap 内 sweets-mini）
  document.querySelectorAll('.sweets-wrap .sweets-mini').forEach(miniEl => {
    if(!isFieldElement(miniEl)) return;
    sources.push({
      el: miniEl,
      host: miniEl.closest('.sweets-wrap') || miniEl,
      uid: (miniEl.closest('.sweets-wrap')?.dataset?.sweetsUid) || null
    });
  });

  // 3) 自分のスイーツ（手元表示が残っている場合も回収）
  const myImg = mySweetsEl?.querySelector('img');
  if(myImg && isFieldElement(myImg)){
    sources.push({
      el: myImg,
      host: mySweetsEl,
      uid: state.userId || null
    });
  }

  if(!sources.length) return;

  // フリッカー防止：render側でも消えるように（既存キャッシュを利用）
  sources.forEach(s => { if(s.uid) collectedSweetsHidden.add(s.uid); });

  // 元DOMを先に不可視化（回収中に二重に見えないように）
  sources.forEach(s => {
    if(s.host?.classList) s.host.classList.add('collect-hidden');
    else if(s.el) s.el.style.visibility = 'hidden';
  });

  // 回収アニメ（少しだけズラして気持ちよく）
  const tasks = sources.map((s, i) => {
    const snapshot = getCollectAnimationSnapshot(s.el);
    if(!snapshot) return Promise.resolve();
    return animateOneCardToDeck(snapshot, target, { delay: i * 35, rotateFrom: snapshot.rotateDeg, rotateTo: 0 });
  });

  await Promise.all(tasks);
}

async function animateReturnExcludedDeckToSweetsDeck(){
  // 「その直後」
  await sleep(30);

  // 除外が無いなら何もしない
  const excludedDeck = state.room?.decks?.sweetsExcluded;
  const liveExcluded = Array.isArray(excludedDeck) ? excludedDeck.length : 0;
  const excludedCount = (sweetsExcludedCountOverride ?? liveExcluded);
  if(excludedCount <= 0) return;

  const target = getSweetsDeckTargetRect();
  if(!target) return;

  if(!sweetsExcludedDeckUI || !isVisibleRect(sweetsExcludedDeckUI)) return;
  const exRect = sweetsExcludedDeckUI.getBoundingClientRect();

  // UIを一瞬隠して「飛ぶ1枚」だけ見せる（見た目重複防止）
  const prevVis = sweetsExcludedDeckUI.style.visibility;
  sweetsExcludedDeckUI.style.visibility = 'hidden';

  // 横(90deg) → 縦(0deg) になりつつ山札へ
  await animateOneCardToDeck(exRect, target, { delay: 0, rotateFrom: 90, rotateTo: 0 });

  sweetsExcludedDeckUI.style.visibility = prevVis;
}

// ✅ ホストだけ：ラウンド終了後に「全スイーツ（selected/非selected/手元）＋除外」をDB上で山札へ戻す
async function hostFinalizeReturnSweetsToDeck(revealedCards = []){
  if(!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;

  // 最新を取り直す（stateのズレ対策）
  const [handsSnap, decksSnap, votesSnap, tablesSnap, gameSnap] = await Promise.all([
    get(ref(db, `${base}/hands`)),
    get(ref(db, `${base}/decks`)),
    get(ref(db, `${base}/votes`)),
    get(ref(db, `${base}/tables`)),
    get(ref(db, `${base}/game`)),
  ]);

  const gameNow = gameSnap.val() || {};


  const hands = handsSnap.val() || {};
  const decks = decksSnap.val() || {};
  const votes = votesSnap.val() || {};
  const tables = tablesSnap.val() || {};
  const deckSweets = Array.isArray(decks.sweets) ? decks.sweets : [];
  const excluded   = Array.isArray(decks.sweetsExcluded) ? decks.sweetsExcluded : [];

  // 返すカードを「id」でユニーク化（重複防止）
  const returned = new Map();
  const add = (c) => {
    if(!c || !c.id) return;
    if(!returned.has(c.id)) returned.set(c.id, c);
  };

  // ① イベントで公開されたカード（selected/非selectedの実体になっている想定）
  (Array.isArray(revealedCards) ? revealedCards : []).forEach(add);

  // ② hands に残っているスイーツ（手元含む）も全部回収（これが枚数不足の主因）
  Object.values(hands).forEach(h => {
    const arr = h?.sweets;
    if(Array.isArray(arr)) arr.forEach(add);
  });

  // ③ 除外も山札へ戻す（今回の仕様）
  excluded.forEach(add);

  const returnedIds = new Set(returned.keys());

  // 既に山札に紛れ込んでいた場合でも二重化しないよう、先に除去してから足す
  const baseDeck = deckSweets.filter(c => !(c && c.id && returnedIds.has(c.id)));
  const newDeck  = shuffle([...baseDeck, ...Array.from(returned.values())]);

  // hands の sweets を全員ぶん空にする
  for(const uid of Object.keys(hands)){
    if(hands[uid] && Array.isArray(hands[uid].sweets)){
      hands[uid].sweets = [];
    }
  }

  // DB反映（decksは部分更新でOK）
  const leaderSeatNow = gameNow.turn?.leaderSeat ?? null;
  const leaderId = leaderSeatNow != null ? (tables?.[leaderSeatNow]?.playerId ?? null) : null;
  const voteCounts = Object.entries(votes)
    .map(([uid, voters]) => ({
      uid,
      count: (voters && typeof voters === 'object') ? Object.keys(voters).length : 0,
    }))
    .filter(entry => entry.count > 0);
  const maxVotes = voteCounts.length ? Math.max(...voteCounts.map(v => v.count)) : 0;
  const topVoteUids = voteCounts.filter(v => v.count === maxVotes).map(v => v.uid);
  const leaderPickStartAt = Date.now();
  let leaderPickPayload = null;
  if(topVoteUids.length === 1){
    leaderPickPayload = {
      phase: 'auto',
      decidedId: topVoteUids[0],
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }else if(topVoteUids.length === 2 && leaderId && topVoteUids.includes(leaderId)){
    const nextLeaderId = topVoteUids.find(uid => uid !== leaderId);
    leaderPickPayload = {
      phase: 'auto',
      decidedId: nextLeaderId || null,
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }else if(topVoteUids.length >= 2){
    leaderPickPayload = {
      phase: 'choose',
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }

  await update(ref(db, base), {
    'hands': hands,
    'decks/sweets': newDeck,
    'decks/sweetsExcluded': [],   // 除外は空に
    'game/leaderPick': leaderPickPayload,
    'game/actionDealKey': null,
    /* ✅ 追加：ここから勝敗判定→roundchip→round+1 */
    ...( (() => {
      const playerCount = Array.isArray(gameNow.seatOrder) ? gameNow.seatOrder.length : (latestPlayers?.length || 0);
      const currentRound = (typeof gameNow.roundNo === 'number') ? gameNow.roundNo : 1;

      const pts = calcSweetsTotalPoints(revealedCards);          // 選ばれたスイーツ合計点
      const th  = getRoundWinThreshold(playerCount || 1, currentRound);
      const win = pts >= th;

      // roundchipは1〜3のスロットにのみ描画（キーは "1","2","3" で持つ）
      const prev = (gameNow.roundChips && typeof gameNow.roundChips === 'object') ? gameNow.roundChips : {};
      const nextChips = { ...prev };
      if(currentRound >= 1 && currentRound <= 3){
        nextChips[String(currentRound)] = win ? 'winchip.png' : 'losechip.png';
      }

      return {
        'game/roundChips': nextChips,
        'game/roundNo': currentRound + 1,          // 処理が終わった後で +1
        'game/lastRoundPoints': pts,               // （任意：デバッグ用。不要なら消してOK）
        'game/lastRoundThreshold': th,             // （任意：デバッグ用）
      };
    })() )

  });

  if(!leaderPickPayload){
    await set(ref(db, `${base}/votes`), {});
  }
}


/* =========================
   ★ 投票（チップ表示＆条件）
   ========================= */
function getMyVoteChips(){
  const myData = state.hands?.[state.userId] || {};
  const v = myData.voteChips;
  return (typeof v === 'number') ? v : 1;
}
function getPlayerVoteChips(uid){
  const data = state.hands?.[uid] || {};
  const v = data.voteChips;
  return (typeof v === 'number') ? v : 1;
}
function getSweetsOwners(){
  return latestPlayers
    .filter(p => {
      const hd = state.hands?.[p.id];
      return !!(hd && Array.isArray(hd.sweets) && hd.sweets.length);
    })
    .map(p => p.id);
}
function canVoteNow(){
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(isActionSelectionActive()) return false;
  if(getMyVoteChips() <= 0) return false;
  const activeInstructions = getActiveInstructionCards();
  const bribeTargetUid = getActiveBribeTargetUid();
  if(activeInstructions.length && !bribeTargetUid) return false;
  if(bribeTargetUid){
    const targetData = state.hands?.[bribeTargetUid];
    const hasTargetSweets = !!(targetData && Array.isArray(targetData.sweets) && targetData.sweets.length);
    return hasTargetSweets;
  }
  return getSweetsOwners().length >= 1;
}
function renderMyVoteChip(){
  const started = !!state.room?.gameStarted;
  applyTagChipStyle(myVoteChipEl, getTagChipStyleByUid(state.userId));
  if(!started){
    myVoteChipEl.classList.add('hidden');
    myVoteChipEl.classList.remove('pulsing');
    return;
  }

  const chips = getMyVoteChips();
 myVoteChipEl.classList.toggle('hidden', chips <= 0);
  myVoteChipEl.classList.toggle('pulsing', canVoteNow());
}

let lastVoteSnapshot = null;
function getVoteSnapshot(votesObj){
  const snapshot = new Map();
  const votes = votesObj && typeof votesObj === 'object' ? votesObj : {};
  Object.entries(votes).forEach(([targetUid, voters]) => {
    if(!voters || typeof voters !== 'object') return;
    snapshot.set(targetUid, new Set(Object.keys(voters)));
  });
  return snapshot;
}
function getNewVotes(prev, next){
  const diffs = [];
  if(!prev) return diffs;
  next.forEach((voters, targetUid) => {
    voters.forEach(voterUid => {
      const prevSet = prev.get(targetUid);
      if(!prevSet || !prevSet.has(voterUid)){
        diffs.push({ voterUid, targetUid });
      }
    });
  });
  return diffs;
}
function getVoteChipSizePx(){
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--voteMiniSize'));
  return Number.isFinite(size) ? size : 14;
}
function buildVoteStackEl(targetUid){
  const voterIds = getVoteVoterIds(targetUid);
  if(!voterIds.length) return null;
  const voteStack = document.createElement('div');
  voteStack.className = 'vote-stack';
  voteStack.dataset.targetUid = targetUid;
  voterIds.forEach((voterUid) => {
    const v = document.createElement('div');
    v.className = 'vote-mini';
    applyTagChipStyle(v, getTagChipStyleByUid(voterUid));
    voteStack.appendChild(v);
  });
  return voteStack;
}
function getVoteChipSourceRect(voterUid){
  const tag = document.querySelector(`.player-tag[data-uid="${voterUid}"]`);
  if(!tag) return null;
  const chip = tag.querySelector(`.other-vote-chip[data-voter-uid="${voterUid}"]`);
  if(chip){
    const rect = chip.getBoundingClientRect();
    return {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
    };
  }
  const roleMini = tag.querySelector('.role-mini');
  const size = getVoteChipSizePx();
  if(roleMini){
    const rect = roleMini.getBoundingClientRect();
    return {
      left: rect.right - 6 - size,
      top: rect.bottom - 6 - size,
      width: size,
      height: size,
    };
  }
  return null;
}
function getVoteChipTargetInfo(targetUid){
  const stack = document.querySelector(`.vote-stack[data-target-uid="${targetUid}"]`);
  if(!stack) return null;
  const rect = stack.getBoundingClientRect();
  const size = getVoteChipSizePx();
  return {
    stack,
    rect: {
      left: rect.left + (rect.width - size) / 2,
      top: rect.top + (rect.height - size) / 2,
      width: size,
      height: size,
    },
  };
}
function animateVoteChipFly(voterUid, targetUid){
  if(voterUid === state.userId) return;
  const source = getVoteChipSourceRect(voterUid);
  const targetInfo = getVoteChipTargetInfo(targetUid);
  if(!source || !targetInfo) return;
  const { stack, rect: target } = targetInfo;

  const fly = document.createElement('div');
  fly.className = 'vote-chip-fly';
  applyTagChipStyle(fly, getTagChipStyleByUid(voterUid));
  fly.style.left = `${source.left}px`;
  fly.style.top = `${source.top}px`;
  fly.style.width = `${source.width}px`;
  fly.style.height = `${source.height}px`;
  document.body.appendChild(fly);

  const dx = target.left - source.left;
  const dy = target.top - source.top;
  stack.classList.add('animating');
  fly.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: 600,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    fly.remove();
    stack.classList.remove('animating');
  };
}
function scheduleVoteChipAnimations(){
  const current = getVoteSnapshot(state.room?.votes || {});
  if(!lastVoteSnapshot){
    lastVoteSnapshot = current;
    return;
  }
  const newVotes = getNewVotes(lastVoteSnapshot, current);
  lastVoteSnapshot = current;
  if(!newVotes.length) return;
  requestAnimationFrame(() => {
    newVotes.forEach(({ voterUid, targetUid }) => {
      animateVoteChipFly(voterUid, targetUid);
    });
  });
}



/* =========================
   ★★★ PASSボタン表示条件（ラウンド用）
   - 自分の手番
   - 自分がスイーツ獲得済み
   - 自分の投票が済み（voteChips <= 0）
   - 受け取り指示なし
   - まだ自分がPASSしていない
   ========================= */
function myDoneSweetsAndVote(){
  return hasSweets() && (getMyVoteChips() <= 0);
}
function syncPassTurnState(){
  const turnNo = state.turn?.turnNo ?? null;
  if(turnNo !== state.prevTurnNo){
    state.prevTurnNo = turnNo;
    state.passReadyBlockedTurnNo = null;
    state.lastPassEligible = false;
    if(isMyTurn()){
      state.lastPassEligible = myDoneSweetsAndVote() && getActiveInstructionCards().length === 0;
    }
  }
}
function updatePassRoundBtn(){
  const started = !!state.room?.gameStarted;
  const mine = isMyTurn();
  const passed = isPassedPlayerId(state.userId);
  const ending = !!state.game?.roundEnding;
  const eligible = myDoneSweetsAndVote() && getActiveInstructionCards().length === 0;
  if(mine){
    if(!state.lastPassEligible && eligible){
      state.passReadyBlockedTurnNo = state.turn?.turnNo ?? null;
    }
    state.lastPassEligible = eligible;
  } else {
    state.lastPassEligible = false;
  }
  const show = started && mine && !ending && !passed && !state.turnEnding && eligible && state.passReadyBlockedTurnNo !== state.turn?.turnNo;
  passRoundBtn.classList.toggle('visible', show);
  passRoundBtn.disabled = !show;
}

/* =========================
   手札レンダー
   ========================= */
function renderMyRole(){
  const started = !!state.room?.gameStarted;
  if(!started){
    myRoleEl.classList.add('hidden');
    myRoleEl.innerHTML = '';
    return;
  }

  const myRole = state.roles?.[state.userId];
  if(!myRole){
    myRoleEl.classList.add('hidden');
    myRoleEl.innerHTML = '';
    return;
  }
  const info = roleToHelp(myRole);
  myRoleEl.classList.remove('hidden');
  myRoleEl.innerHTML = '';
  const img = document.createElement('img');
  img.src = info.img;
  img.alt = info.name;
  myRoleEl.appendChild(img);
}

function renderMySweets(){
  mySweetsEl.innerHTML = '';
  applyTagChipStyle(mySweetsEl, getTagChipStyleByUid(state.userId));
  const c = getMySweetsCard();
  if(!c){
    mySweetsEl.classList.add('hidden');
    updateRoundPickUI();
    lastMySweetsSnapshot = null;
    mySweetsFlyAnimatedFor = null;
    return;
  }
  if(collectedSweetsHidden.has(state.userId)){
    mySweetsEl.classList.add('hidden');
    mySweetsEl.innerHTML = '';
    updateRoundPickUI();
    return;
  }
  const decidedUids = getDecidedSweetsUids();
  if(decidedUids.includes(state.userId)){
    mySweetsEl.classList.add('hidden');
    mySweetsEl.innerHTML = '';
    updateRoundPickUI();
    return;
  }
  mySweetsFlyAnimatedFor = null;
  mySweetsEl.classList.remove('hidden');
  const img = document.createElement('img');
  img.src = c.img;
  img.alt = `sweets ${c.value ?? ''}`;
  img.onerror = () => { if(c.fallback) img.src = c.fallback; };
  mySweetsEl.appendChild(img);

  // ★ 追加：自分スイーツにも投票ミニを重ねる
  renderMySweetsVoteStack();

  updateRoundPickUI();
  requestAnimationFrame(cacheMySweetsSnapshot);
}

/* ★ カードDOMを作る共通 */
function buildCardEl(cardObj, { extraClass='' } = {}){
  const card = document.createElement('div');
  card.className = 'action-card' + (extraClass ? ` ${extraClass}` : '');
  card.dataset.cardId = cardObj.id;

  const img = document.createElement('img');
  img.className = 'card-img';
  img.src = cardObj.img;
  img.alt = cardObj.name;

  const name = document.createElement('div');
  name.className = 'card-name';
  name.textContent = cardObj.name;

  const frame = document.createElement('div');
  frame.className = 'effect-frame';

  const txt = document.createElement('div');
  txt.className = 'effect-text';
  txt.textContent = cardObj.effectText || '';
  frame.appendChild(txt);

  card.appendChild(img);
  card.appendChild(name);
  card.appendChild(frame);

  requestAnimationFrame(()=> fitEffectText(txt));
  return card;
}

function renderMyReceived(){
  myReceivedEl.innerHTML = '';
  const recCards = getMyReceivedCards();
  if(!recCards.length) return;

  const activeIds = new Set(getActiveInstructionCards().map(card => card.id));
  recCards.forEach(rec => {
    const pulse = activeIds.has(rec.id) && rec.name !== '賄賂';
    const cardEl = buildCardEl(rec, { extraClass: pulse ? 'pulse-only' : '' });
    cardEl.addEventListener('pointerdown', (e) => startDragCard(e, rec, cardEl));
    myReceivedEl.appendChild(cardEl);
  });
}

function renderMyHand(){
  myHandEl.innerHTML = '';

  const myData = state.hands?.[state.userId];
  if(!myData || !Array.isArray(myData.action)) return;

  const turnBlocked = isInstructionTurnBlocked();

  myData.action.forEach(cardObj => {
    const allowThisCard =
      !turnBlocked || (cardObj.kind === 'instruction' && cardObj.name === '無視');

    const cardEl = buildCardEl(cardObj);
    if(turnBlocked && cardObj.kind === 'instruction' && cardObj.name === '無視'){
      cardEl.classList.add('can-ignore');
    }

    cardEl.addEventListener('pointerdown', (e) => {
      if(!allowThisCard) return;
      startDragCard(e, cardObj, cardEl);
    });

    myHandEl.appendChild(cardEl);
  });
}

function applyMyTurnClasses(){
  const wrap = document.querySelector('.my-hand-wrapper');
  if(!wrap) return;

  const mine = isMyTurn();
  const turnBlocked = isInstructionTurnBlocked();
  const roundPickActive = getRoundPick()?.phase === 'choose';

  wrap.classList.remove('my-turn-free','my-turn-blocked','my-turn-selecting');
  if(!mine || roundPickActive) return;

  if(isActionSelectionActive()){
    wrap.classList.add('my-turn-selecting');
    return;
  }

  if(turnBlocked){
    wrap.classList.add('my-turn-blocked');
  }else{
    wrap.classList.add('my-turn-free');
  }
}

function renderHands(){
  renderMyRole();
  renderMySweets();
  renderMyReceived();
  renderMyHand();
  applyMyTurnClasses();
  updateSweetsDeckUI();
  renderMyVoteChip();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  updatePassRoundBtn();
}

function isActionSelectionActive(){
  return !!actionSelection;
}

function updateActionSelectionUI(){
  if(actionExplainPop) actionExplainPop.classList.add('hidden');
  if(actionConfirmPop) actionConfirmPop.classList.add('hidden');
  if(!actionSelection) return;
  if(actionSelection.type === 'wiretap'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = '盗聴：見たいプレイヤーの正体カードを選んでください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.targetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」の正体を見ますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
  if(actionSelection.type === 'scout'){
    if(actionSelection.phase === 'select'){
      if(actionExplainPop){
        actionExplainPop.textContent = '偵察：アクションカードを見たいプレイヤーを選択してください。';
        actionExplainPop.classList.remove('hidden');
      }
    }
    if(actionSelection.phase === 'confirm'){
      const target = getPlayerByUid(actionSelection.targetUid);
      if(actionConfirmText){
        actionConfirmText.textContent = `「${target?.name ?? 'プレイヤー'}」のアクションカードを見ますか。`;
      }
      if(actionConfirmPop) actionConfirmPop.classList.remove('hidden');
    }
  }
}

function setActionSelection(next){
  actionSelection = next;
  updateActionSelectionUI();
  applyMyTurnClasses();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
  if(latestPlayers.length) renderPlayerCircle(latestPlayers);
}

function clearActionSelection(){
  setActionSelection(null);
}

function beginWiretapSelection(){
  const candidates = latestPlayers.filter(p => p.id !== state.userId);
  if(!candidates.length) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'wiretap',
      phase:'select',
      targetUid:null,
      resolve,
    });
  });
}

function beginScoutSelection(){
  const candidates = latestPlayers.filter(p => p.id !== state.userId);
  if(!candidates.length) return Promise.resolve(null);
  return new Promise(resolve => {
    setActionSelection({
      type:'scout',
      phase:'select',
      targetUid:null,
      resolve,
    });
  });
}

function handleWiretapCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'wiretap') return;
  if(actionSelection.phase !== 'select') return;
  actionSelection.phase = 'confirm';
  actionSelection.targetUid = uid;
  updateActionSelectionUI();
  if(latestPlayers.length) renderPlayerCircle(latestPlayers);
}

function handleScoutCandidate(uid){
  if(!actionSelection || actionSelection.type !== 'scout') return;
  if(actionSelection.phase !== 'select') return;
  actionSelection.phase = 'confirm';
  actionSelection.targetUid = uid;
  updateActionSelectionUI();
  if(latestPlayers.length) renderPlayerCircle(latestPlayers);
}

function triggerWiretapZoom(uid){
  const roleEl = document.querySelector(`.role-mini[data-uid="${uid}"]`);
  const img = roleEl?.querySelector('img');
  if(!img) return;
  img.animate([
    { transform:'scale(1)' },
    { transform:'scale(1.2)' },
    { transform:'scale(1)' },
  ], {
    duration: 1500,
    easing: 'ease-in-out',
  });
}

function showWiretapArrow(fromSeat, toSeat){
  const fromTag = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  const toTag = document.querySelector(`.player-tag[data-seat="${toSeat}"]`);
  if(!fromTag || !toTag) return;

  const fromRect = fromTag.getBoundingClientRect();
  const toRect = toTag.getBoundingClientRect();
  const x1 = fromRect.left + fromRect.width / 2;
  const y1 = fromRect.top + fromRect.height / 2;
  const x2 = toRect.left + toRect.width / 2;
  const y2 = toRect.top + toRect.height / 2;

  const wrap = document.createElement('div');
  wrap.className = 'wiretap-arrow';

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
 const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
  marker.setAttribute('id', 'wiretapArrowHead');
  marker.setAttribute('markerWidth', '10');
  marker.setAttribute('markerHeight', '10');
  marker.setAttribute('refX', '10');
  marker.setAttribute('refY', '5');
  marker.setAttribute('orient', 'auto');
  marker.setAttribute('markerUnits', 'strokeWidth');
  const arrowPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
  arrowPath.setAttribute('fill', '#111');
  marker.appendChild(arrowPath);
  defs.appendChild(marker);
  svg.appendChild(defs);
  svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${window.innerHeight}`);
  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  line.setAttribute('x1', String(x1));
  line.setAttribute('y1', String(y1));
  line.setAttribute('x2', String(x2));
  line.setAttribute('y2', String(y2));
  line.setAttribute('marker-end', 'url(#wiretapArrowHead)');
  svg.appendChild(line);
  wrap.appendChild(svg);

  const eye = document.createElement('div');
  eye.className = 'wiretap-eye';
  eye.textContent = '👀';
  eye.style.left = `${(x1 + x2) / 2}px`;
  eye.style.top = `${(y1 + y2) / 2}px`;
  wrap.appendChild(eye);

  document.body.appendChild(wrap);
  setTimeout(() => {
    wrap.remove();
  }, 1500);
}

if(actionConfirmYes){
  actionConfirmYes.addEventListener('click', () => {
    if(!actionSelection) return;
    if(actionSelection.phase !== 'confirm') return;
    const targetUid = actionSelection.targetUid;
    const resolve = actionSelection.resolve;
    clearActionSelection();
    if(resolve) resolve(targetUid);
  });
}
if(actionConfirmNo){
  actionConfirmNo.addEventListener('click', () => {
    if(!actionSelection) return;
    if(actionSelection.phase !== 'confirm') return;
    actionSelection.phase = 'select';
    actionSelection.targetUid = null;
    updateActionSelectionUI();
    if(latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}

/* =========================
   プレイヤー円レンダー
   ========================= */
let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;

function renderMySweetsVoteStack(){
  // スイーツ未所持なら何もしない（＆残骸があれば消す）
  const c = getMySweetsCard();
  const old = mySweetsEl.querySelector('.vote-stack');
  if(old) old.remove();
  if(!c) return;

  const voterIds = getVoteVoterIds(state.userId);
  if(!voterIds.length) return;

  const voteStack = document.createElement('div');
  voteStack.className = 'vote-stack';
  voteStack.dataset.targetUid = state.userId;

  voterIds.forEach((voterUid) => {
    const v = document.createElement('div');
    v.className = 'vote-mini';
    applyTagChipStyle(v, getTagChipStyleByUid(voterUid));
    voteStack.appendChild(v);
  });
  mySweetsEl.appendChild(voteStack);
}


function getVoteCountFor(targetUid){
  const obj = state.room?.votes?.[targetUid] || {};
  return Object.keys(obj).length;
}
function getVoteVoterIds(targetUid){
  const obj = state.room?.votes?.[targetUid] || {};
  return Object.keys(obj);
}

function roundedStarPath({R=45, r2=20, round=14, k=0.65, points=5}){
  const pts = [];
  for(let i=0;i<points*2;i++){
    const ang = -Math.PI/2 + i*Math.PI/points;
    const rad = (i%2===0) ? R : r2;
    pts.push({x: Math.cos(ang)*rad, y: Math.sin(ang)*rad, outer: i%2===0});
  }

  const prev0 = pts[pts.length-1], cur0 = pts[0];
  const A0 = insetPoint(prev0, cur0, round);
  let d = `M ${A0.x.toFixed(2)} ${A0.y.toFixed(2)} `;

  for(let i=0;i<pts.length;i++){
    const prev = pts[(i-1+pts.length)%pts.length];
    const cur  = pts[i];
    const next = pts[(i+1)%pts.length];

    if(!cur.outer){
      d += `L ${cur.x.toFixed(2)} ${cur.y.toFixed(2)} `;
      continue;
    }

    const A = insetPoint(prev, cur, round);
    const B = insetPoint(next, cur, round);

    d += `L ${A.x.toFixed(2)} ${A.y.toFixed(2)} `;

    const C1 = { x: A.x + (cur.x - A.x)*k, y: A.y + (cur.y - A.y)*k };
    const C2 = { x: B.x + (cur.x - B.x)*k, y: B.y + (cur.y - B.y)*k };

    d += `C ${C1.x.toFixed(2)} ${C1.y.toFixed(2)} `
      +  `${C2.x.toFixed(2)} ${C2.y.toFixed(2)} `
      +  `${B.x.toFixed(2)} ${B.y.toFixed(2)} `;
  }

  d += "Z";
  return d;

  function insetPoint(target, cur, dist){
    const vx = target.x - cur.x, vy = target.y - cur.y;
    const n = Math.hypot(vx, vy) || 1;
    return { x: cur.x + (vx/n)*dist, y: cur.y + (vy/n)*dist };
  }
}

function createRoundedStarSvg(){
  const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
  svg.setAttribute("class","sweets-number-star");
  svg.setAttribute("viewBox","-60 -60 120 120");
  svg.setAttribute("aria-hidden","true");

  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d", roundedStarPath({R:45, r2:20, round:30, k:0.88}));
  path.setAttribute("fill", "#fde047");
  path.setAttribute("stroke", "#111");
  path.setAttribute("stroke-width", "3");
  path.setAttribute("stroke-linejoin", "round");
  path.setAttribute("stroke-linecap", "round");

  svg.appendChild(path);
  return svg;
}
const decidedSweetsAnimated = new Map();
const DECIDED_MOVE_DURATION_MS = 650;
const DECIDED_CENTER_DELAY_MS = DECIDED_MOVE_DURATION_MS + 1800;
const DECIDED_CENTER_MOVE_DURATION_MS = 650;
const decidedCenterMoveAnimated = new Map();
const decidedCenterMoveTimers = new Map();
let centerMoveBatchTimerId = null;
let centerMoveBatchKey = null;
let decidedRoundKey = null;
let decidedRoundStartAt = null;
let lastMySweetsSnapshot = null;
let mySweetsFlyAnimatedFor = null;

function hasCompletedDecidedMove(uid){
  const ts = decidedSweetsAnimated.get(uid);
  if(typeof ts !== 'number') return false;
  return (Date.now() - ts) > DECIDED_MOVE_DURATION_MS;
}

function applyDecidedSweetsMove(items){
  if(!Array.isArray(items) || !items.length) return;
  const playRect = playCircleEl?.getBoundingClientRect?.();
  if(!playRect || !playRect.width || !playRect.height) return;
  const decidedStartAt = getDecidedStartAtForUids(items.map(item => item.uid).filter(Boolean));

  const playCenter = {
    x: playRect.left + playRect.width / 2,
    y: playRect.top + playRect.height / 2,
  };
  const decidedMoveDistance = 80;

  items.forEach(({ uid, sweetsWrap, circle, rotDeg, skipMove }) => {
    if(!sweetsWrap || !circle) return;
    const alreadyAnimated = uid && decidedSweetsAnimated.has(uid);
    const circleRect = circle.getBoundingClientRect();
    const sweetsRect = sweetsWrap.getBoundingClientRect();
    if(!circleRect.width || !circleRect.height || !sweetsRect.width || !sweetsRect.height) return;

    const circleCenter = {
      x: circleRect.left + circleRect.width / 2,
      y: circleRect.top + circleRect.height / 2,
    };
    const sweetsCenter = {
      x: sweetsRect.left + sweetsRect.width / 2,
      y: sweetsRect.top + sweetsRect.height / 2,
    };

    const dx = playCenter.x - circleCenter.x;
    const dy = playCenter.y - circleCenter.y;
    const len = Math.hypot(dx, dy) || 1;
    const targetX = circleCenter.x + (dx / len) * decidedMoveDistance;
    const targetY = circleCenter.y + (dy / len) * decidedMoveDistance;
    const moveX = targetX - sweetsCenter.x;
    const moveY = targetY - sweetsCenter.y;
    const rotRad = (typeof rotDeg === 'number' ? rotDeg : 0) * Math.PI / 180;
    const localMoveX = moveX * Math.cos(-rotRad) - moveY * Math.sin(-rotRad);
    const localMoveY = moveX * Math.sin(-rotRad) + moveY * Math.cos(-rotRad);

    if(skipMove || alreadyAnimated){
      sweetsWrap.classList.add('decided-static');
    }else{
      sweetsWrap.classList.remove('decided-static');
    }
    sweetsWrap.style.setProperty('--decidedMoveX', `${localMoveX}px`);
    sweetsWrap.style.setProperty('--decidedMoveY', `${localMoveY}px`);
    sweetsWrap.classList.add('decided-move');
    if(uid && !decidedSweetsAnimated.has(uid)){
      decidedSweetsAnimated.set(uid, decidedStartAt);
    }

  });
}

function parseRotationDegrees(value){
  if(!value) return 0;
  const num = parseFloat(value);
  return Number.isFinite(num) ? num : 0;
}

function applyCenterMoveToCard(cardEl, hostEl, rotDeg, startedAt){
  if(!cardEl || !playerCircle) return;
  const circleRect = playerCircle.getBoundingClientRect();
  const cardRect = cardEl.getBoundingClientRect();
  if(!circleRect.width || !circleRect.height || !cardRect.width || !cardRect.height) return;

  const circleCenter = {
    x: circleRect.left + circleRect.width / 2,
    y: circleRect.top + circleRect.height / 2,
  };
  const cardCenter = {
    x: cardRect.left + cardRect.width / 2,
    y: cardRect.top + cardRect.height / 2,
  };
  let moveX = circleCenter.x - cardCenter.x;
  let moveY = circleCenter.y - cardCenter.y;

  if(rotDeg){
    const rotRad = rotDeg * Math.PI / 180;
    const localMoveX = moveX * Math.cos(-rotRad) - moveY * Math.sin(-rotRad);
    const localMoveY = moveX * Math.sin(-rotRad) + moveY * Math.cos(-rotRad);
    moveX = localMoveX;
    moveY = localMoveY;
  }

  cardEl.style.setProperty('--centerMoveX', `${moveX}px`);
  cardEl.style.setProperty('--centerMoveY', `${moveY}px`);
  cardEl.classList.add('center-move');
  if(hostEl){
    hostEl.classList.add('center-move-host');
  }

  if(typeof startedAt === 'number' && (Date.now() - startedAt) > DECIDED_CENTER_MOVE_DURATION_MS){
    cardEl.classList.add('center-static');
  }else{
    cardEl.classList.remove('center-static');
  }
}

function applyCenterMoveForUid(uid){
  const startedAt = decidedCenterMoveAnimated.get(uid);
  const tagEl = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"]`);
  if(tagEl){
    const cardEl = tagEl.querySelector('.selected-sweets-card');
    applyCenterMoveToCard(cardEl, tagEl, 0, startedAt);
  }

  const wrapEl = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"]`);
  if(wrapEl){
    const cardEl = wrapEl.querySelector('.sweets-mini');
    const circle = wrapEl.closest('.otherplayerscircle');
    const rotDeg = circle
      ? parseRotationDegrees(getComputedStyle(circle).getPropertyValue('--rotDeg').trim())
      : 0;
    applyCenterMoveToCard(cardEl, wrapEl, rotDeg, startedAt);
  }
}

function getLatestDecidedAt(uids){
  const list = Array.isArray(uids) ? uids : [];
  const key = [...list].sort().join(',');
  if(decidedRoundStartAt && key === decidedRoundKey){
    return decidedRoundStartAt;
  }
  const times = list
    .map(uid => decidedSweetsAnimated.get(uid))
    .filter(ts => typeof ts === 'number');
  return times.length ? Math.max(...times) : Date.now();
}
function getLatestAppliedDecidedAt(uids){
  const list = Array.isArray(uids) ? uids : [];
  const times = list
    .map(uid => decidedSweetsAnimated.get(uid))
    .filter(ts => typeof ts === 'number');
  return times.length ? Math.max(...times) : Date.now();
}

function waitForDecidedTimestamps(uids, timeoutMs = 1200){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return Promise.resolve();
  const start = Date.now();
  return new Promise(resolve => {
    const tick = () => {
      const missing = list.some(uid => !decidedSweetsAnimated.has(uid));
      if(!missing || (Date.now() - start) >= timeoutMs){
        resolve();
        return;
      }
      setTimeout(tick, 50);
    };
    tick();
  });
}


function scheduleCenterMovesForUids(uids){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return;
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'done') return;
  const allCentered = list.every(uid => decidedCenterMoveAnimated.has(uid));
  if(allCentered) return;
  const key = [...list].sort().join(',');
  if(centerMoveBatchTimerId && centerMoveBatchKey === key) return;
  if(centerMoveBatchTimerId){
    clearTimeout(centerMoveBatchTimerId);
    centerMoveBatchTimerId = null;
  }
  centerMoveBatchKey = key;

  const latestDecidedAt = getLatestDecidedAt(list);
  const delay = Math.max(0, latestDecidedAt + DECIDED_CENTER_DELAY_MS - Date.now());

  centerMoveBatchTimerId = setTimeout(() => {
    centerMoveBatchTimerId = null;
    const startedAt = Date.now();
    list.forEach(uid => {
      if(decidedCenterMoveAnimated.has(uid)) return;
      decidedCenterMoveAnimated.set(uid, startedAt);
      applyCenterMoveForUid(uid);
    });
  }, delay);
}

function ensureDecidedRoundStart(uids){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return;
  const key = [...list].sort().join(',');
  if(decidedRoundKey === key) return;
  decidedRoundKey = key;
  decidedRoundStartAt = Date.now();
}

function getDecidedStartAtForUids(uids){
  const list = Array.isArray(uids) ? uids : [];
  const key = [...list].sort().join(',');
  if(decidedRoundStartAt && key === decidedRoundKey){
    return decidedRoundStartAt;
  }
  return Date.now();
}

function cacheMySweetsSnapshot(){
  const card = getMySweetsCard();
  if(!card || mySweetsEl.classList.contains('hidden')) return;
  const rect = mySweetsEl.getBoundingClientRect();
  if(!rect.width || !rect.height) return;
  lastMySweetsSnapshot = {
    rect,
    cardId: card.id,
  };
}

function animateMySweetsToTag(targetEl, card){
  if(!targetEl || !card || !lastMySweetsSnapshot) return;
  if(mySweetsFlyAnimatedFor === card.id) return;
  const srcRect = lastMySweetsSnapshot.rect;
  const tagEl = targetEl.classList.contains('selected-sweets-tag')
    ? targetEl
    : targetEl.closest('.selected-sweets-tag');
  const dstRect = targetEl.getBoundingClientRect();
  if(!srcRect.width || !srcRect.height || !dstRect.width || !dstRect.height) return;
  let moveYAdjust = 0;
  if(tagEl){
    const moveYValue = getComputedStyle(tagEl).getPropertyValue('--sweetsTagMoveY').trim();
    const parsedMoveY = parseFloat(moveYValue);
    if(Number.isFinite(parsedMoveY)){
      moveYAdjust = parsedMoveY;
    }
  }

  const fly = document.createElement('div');
  fly.className = 'sweets-fly-card';
  fly.style.left = `${srcRect.left}px`;
  fly.style.top = `${srcRect.top}px`;
  fly.style.width = `${srcRect.width}px`;
  fly.style.height = `${srcRect.height}px`;

  const img = document.createElement('img');
  img.src = card.img;
  img.alt = `sweets ${card.value ?? ''}`;
  img.onerror = () => { if(card.fallback) img.src = card.fallback; };
  fly.appendChild(img);

  document.body.appendChild(fly);

  const dx = dstRect.left - srcRect.left;
  const dy = (dstRect.top + moveYAdjust) - srcRect.top;
  const scale = dstRect.width / srcRect.width;

  fly.animate([
    { transform:`translate(0px, 0px) scale(1)` },
    { transform:`translate(${dx}px, ${dy}px) scale(${scale})` },
  ], {
    duration: DECIDED_MOVE_DURATION_MS,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => fly.remove();

  mySweetsFlyAnimatedFor = card.id;
}


function renderPlayerCircle(players){
  playerCircle.innerHTML = '';

  // ★ 中央リーダーボード → ★ playCircle の順で復元
  if(leaderboardBoardEl) playerCircle.appendChild(leaderboardBoardEl);
  playerCircle.appendChild(playCircleEl);

  // ★ 人数でボード画像を切り替え（席に着いてる人数）
  updateLeaderboardBoardByPlayerCount(players?.length || 0);
  updateRequiredSweetsTag();

  if (!players.length) return;

  const n = players.length;
  const radius = 42;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);
  const decidedMoveTargets = [];

  const allPassed = allSeatedPlayersPassed();
  const leaderSeat = state.turn?.leaderSeat ?? null;
  const activeSeat = allPassed ? null : (state.turn?.activeSeat ?? null);
  const roundPick = getRoundPick();
  const roundPickActive = roundPick?.phase === 'choose';
  const roundPickCandidates = roundPickActive && Array.isArray(roundPick.candidates)
    ? roundPick.candidates
    : [];
  const roundPickCanSelect = roundPickActive && roundPick?.leaderId === state.userId;
  const leaderPick = getLeaderPick();
  const leaderPickActive = leaderPick?.phase === 'choose';
  const leaderPickCandidates = leaderPickActive && Array.isArray(leaderPick.candidates)
    ? leaderPick.candidates
    : [];
  const leaderPickCanSelect = leaderPickActive && leaderPick?.leaderId === state.userId;
  const voteHoldActive = shouldHoldVoteChips();
  const decidedUids = getDecidedSweetsUids();
  const started = !!state.room?.gameStarted;
  if(roundPick?.phase === 'done' && decidedUids.length){
    ensureDecidedRoundStart(decidedUids);
  }

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    // ===== 自分 =====
    if(p.id === state.userId){
      const tag = document.createElement('div');
      tag.className = 'player-tag me';
      tag.textContent = p.name;
      tag.style.left = `${x}%`;
      tag.style.top = `${y}%`;
      tag.dataset.seat = String(p.seatIndex);
      tag.dataset.uid = p.id;
      applyTagChipStyle(tag, p.tagChipStyle);

      if(leaderPickCanSelect && leaderPickCandidates.includes(state.userId)){
        tag.classList.add('leader-pick-selectable');
        tag.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          requestLeaderPick(state.userId);
        });
        tag.onclick = (e) => {
          e.stopPropagation();
          requestLeaderPick(state.userId);
        };
      }

      playerCircle.appendChild(tag);

      if(leaderSeat !== null && leaderSeat === p.seatIndex){
        const chip = document.createElement('div');
        chip.className = 'leader-chip';
        tag.appendChild(chip);
      }
      if(voteHoldActive && !decidedUids.includes(state.userId)){
        const voteStack = buildVoteStackEl(state.userId);
        if(voteStack){
          tag.appendChild(voteStack);
        }
      }
     if(started && decidedUids.includes(state.userId)){
        const sweetsCard = getSweetsCardByUid(state.userId);
        if(sweetsCard){
          const isCollectHidden = collectedSweetsHidden.has(state.userId);
          const selected = document.createElement('div');
          selected.className = 'selected-sweets-tag';
          let decidedStartedAt = decidedSweetsAnimated.get(state.userId);
          if(typeof decidedStartedAt !== 'number'){
            decidedStartedAt = getDecidedStartAtForUids(decidedUids);
            decidedSweetsAnimated.set(state.userId, decidedStartedAt);
          }
          const canAnimateMySweets = !!(lastMySweetsSnapshot && lastMySweetsSnapshot.cardId === sweetsCard.id);
          const animationCompleted = hasCompletedDecidedMove(state.userId);
          const shouldAnimateMySweets = !animationCompleted
            && canAnimateMySweets
            && mySweetsFlyAnimatedFor !== sweetsCard.id;
          if(animationCompleted || !shouldAnimateMySweets){
            selected.classList.add('decided-static');
          }else{
            selected.classList.add('delayed-show');
          }
          if(isCollectHidden){
            selected.classList.add('collect-hidden');
          }
          selected.dataset.sweetsUid = state.userId;
          const cardWrap = document.createElement('div');
          cardWrap.className = 'selected-sweets-card';
          const img = document.createElement('img');
          img.src = SWEETS_BACK_IMG;
          img.alt = `sweets ${sweetsCard.value ?? ''}`;
          img.onerror = () => { if(sweetsCard.fallback) img.src = sweetsCard.fallback; };
          cardWrap.appendChild(img);

         if(typeof sweetsCard.value !== 'undefined'){
            const valueTag = document.createElement('div');
            valueTag.className = 'sweets-number-tag';
            const star = createRoundedStarSvg();
            const valueText = document.createElement('span');
            valueText.className = 'sweets-number-text';
            valueText.textContent = String(sweetsCard.value);
            valueTag.appendChild(star);
            valueTag.appendChild(valueText);
            cardWrap.appendChild(valueTag);
          }
          selected.appendChild(cardWrap);

         const voterIds = getVoteVoterIds(state.userId);
          if(voterIds.length){
            const voteStack = document.createElement('div');
            voteStack.className = 'vote-stack';
            voteStack.dataset.targetUid = state.userId;
            voterIds.forEach((voterUid) => {
              const v = document.createElement('div');
              v.className = 'vote-mini';
              applyTagChipStyle(v, getTagChipStyleByUid(voterUid));
              voteStack.appendChild(v);
            });
            selected.appendChild(voteStack);
         }
          tag.appendChild(selected);
          if(shouldAnimateMySweets){
            requestAnimationFrame(() => {
              animateMySweetsToTag(selected, sweetsCard);
            });
          }
          if(!animationCompleted && shouldAnimateMySweets){
            const remaining = Math.max(0, DECIDED_MOVE_DURATION_MS - (Date.now() - decidedStartedAt));
            setTimeout(() => {
              selected.classList.remove('delayed-show');
            }, remaining);
          }else{
            selected.classList.remove('delayed-show');
          }
         if(decidedCenterMoveAnimated.has(state.userId)){
            requestAnimationFrame(() => {
              applyCenterMoveForUid(state.userId);
            });
          }
        }
      }
      return;
    }


// ===== 他プレイヤー =====
const circle = document.createElement('div');
circle.className = 'otherplayerscircle';
circle.style.left = `${x}%`;
circle.style.top  = `${y}%`;
applyTagChipStyle(circle, p.tagChipStyle);

// ★ 中心方向（内側）ベクトル：(-cos, -sin)
const ux = -Math.cos(angle);
const uy = -Math.sin(angle);

// 内側/外側のオフセット（px）
const innerOff = 20;  // カードを内側へ
const outerOff = 44;  // タグを外側へ

circle.style.setProperty('--inX',  `${ux * innerOff}px`);
circle.style.setProperty('--inY',  `${uy * innerOff}px`);
circle.style.setProperty('--outX', `${-ux * outerOff}px`);
circle.style.setProperty('--outY', `${-uy * outerOff}px`);

// ★ カードの「上辺」が中心を向く回転（CSS rotate）
const rotDeg = (Math.atan2(uy, ux) * 180 / Math.PI) + 90;
circle.style.setProperty('--rotDeg', `${rotDeg}deg`);

const tag = document.createElement('div');
tag.className = 'player-tag in-othercircle';

tag.textContent = p.name;
tag.dataset.seat = String(p.seatIndex);
tag.dataset.uid = p.id;
applyTagChipStyle(tag, p.tagChipStyle);
const isRightSide = x > 50;
tag.classList.toggle('right-side', isRightSide);

const leaderPickSelectable = leaderPickCanSelect && leaderPickCandidates.includes(p.id);
  if(leaderPickSelectable){
    tag.classList.add('leader-pick-selectable');
    if(p.id !== state.userId){
      tag.classList.add('leader-pick-candidate');
    }
    tag.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    });
    tag.onclick = (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    };
    circle.onclick = (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    };
  }

const scoutSelectable = actionSelection?.type === 'scout'
  && actionSelection.phase === 'select'
  && p.id !== state.userId;

// 追い出しクリックは今まで通り
const onKick = () => {
  if (!state.roomCode) return;
  if (state.seatedTable !== null) return;

  pendingSeatIndexToSteal = p.seatIndex;
  pendingSeatPlayerIdToSteal = p.id;
  kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
  kickDialog.classList.remove('hidden');
};
if(scoutSelectable){
  const onScout = (e) => {
    e.stopPropagation();
    handleScoutCandidate(p.id);
  };
  circle.onclick = onScout;
  tag.onclick = onScout;
}else{
  circle.onclick = (e) => { e.stopPropagation(); onKick(); };
  tag.onclick = (e) => { e.stopPropagation(); onKick(); };
}

if(activeSeat === p.seatIndex) circle.classList.add('active-turn');

circle.appendChild(tag);

// handData は後でミニ手札にも使うので先に取る
const handData = state.hands?.[p.id];
const roleAssigned = !!state.roles?.[p.id];
const voteChips = getPlayerVoteChips(p.id);
let roleMini = null;

if(started && roleAssigned){
  roleMini = document.createElement('div');
  roleMini.className = 'role-mini other-role-mini';
  roleMini.dataset.uid = p.id;

  const roleFrame = document.createElement('div');
  roleFrame.className = 'role-mini-frame';
  const roleImg = document.createElement('img');
  const roleKey = state.roles?.[p.id];
  const revealed = revealedRoleUids.has(p.id);
  const roleInfo = revealed && roleKey ? roleToHelp(roleKey) : null;
  roleImg.src = roleInfo?.img || 'swroleura.jpg';
  roleImg.alt = roleInfo?.name || 'role';
  roleFrame.appendChild(roleImg);
  roleMini.appendChild(roleFrame);

  if(actionSelection?.type === 'wiretap' && actionSelection.phase === 'select' && p.id !== state.userId){
    roleMini.classList.add('wiretap-selectable');
    roleMini.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      handleWiretapCandidate(p.id);
    });
    roleMini.onclick = (e) => {
      e.stopPropagation();
      handleWiretapCandidate(p.id);
    };
  }
  tag.appendChild(roleMini);


  const hasTheirSweets = !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);
  const showVoteHold = voteHoldActive && getVoteCountFor(p.id) > 0;

  if(hasTheirSweets || showVoteHold){
    const cardsRow = document.createElement('div');
    cardsRow.className = 'other-cards-row';

    const sweetsWrap = document.createElement('div');
    sweetsWrap.className = 'sweets-wrap';
    sweetsWrap.dataset.sweetsUid = p.id;
    sweetsWrap.classList.toggle('empty', !hasTheirSweets);
    if(collectedSweetsHidden.has(p.id)){
      sweetsWrap.classList.add('collect-hidden');
    }
    if(roundPickCanSelect && roundPickCandidates.includes(p.id)){
      sweetsWrap.classList.add('roundpick-candidate');
      sweetsWrap.classList.add('roundpick-selectable');
      sweetsWrap.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        startRoundPickDrag(e, p.id);
      });
    }
    if(decidedUids.includes(p.id)){
      decidedMoveTargets.push({
        uid: p.id,
        sweetsWrap,
        circle,
        rotDeg,
        skipMove: hasCompletedDecidedMove(p.id),
      });
    }
    if(decidedUids.includes(p.id) && decidedCenterMoveAnimated.has(p.id)){
      requestAnimationFrame(() => {
        applyCenterMoveForUid(p.id);
      });
    }

    const sweetsMini = document.createElement('div');
    sweetsMini.className = 'sweets-mini';
    sweetsMini.classList.toggle('hidden', !hasTheirSweets);
    sweetsWrap.appendChild(sweetsMini);

    // 投票チップ（スイーツ右に重ね）
    const voteStack = buildVoteStackEl(p.id);
    if(voteStack){
      sweetsWrap.appendChild(voteStack);
    }

    cardsRow.appendChild(sweetsWrap);
    circle.appendChild(cardsRow);
  }
}





// ★ 他プレイヤー：ミニ手札（タグの下に扇状）はそのまま（欲しければ残す）
if (handData && Array.isArray(handData.action) && handData.action.length){
  const miniHand = document.createElement('div');
  miniHand.className = 'mini-hand';
  if(scoutSelectable){
    miniHand.classList.add('scout-selectable');
  }

  const count = handData.action.length;
  const spread = 70;
  const base = (count > 1) ? (-spread/2) : 0;

  handData.action.forEach((_, idx2) => {
    const c = document.createElement('div');
    c.className = 'mini-card';

    const angleDeg2 = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
    c.style.transform = `translate(-50%,0) rotate(${angleDeg2}deg)`;
    c.style.zIndex = String(10 + idx2);
    miniHand.appendChild(c);
  });

 tag.appendChild(miniHand);
}

if(voteChips > 0){
  const voteChip = document.createElement('div');
  voteChip.className = 'other-vote-chip';
  voteChip.dataset.voterUid = p.id;
  if(roleMini){
    roleMini.appendChild(voteChip);
  }else{
    tag.appendChild(voteChip);
  }
}

playerCircle.appendChild(circle);

if(leaderSeat !== null && leaderSeat === p.seatIndex){
  const chip = document.createElement('div');
  chip.className = 'leader-chip';
  tag.appendChild(chip);
}
  });
 requestAnimationFrame(() => {
    applyDecidedSweetsMove(decidedMoveTargets);
    if(roundPick?.phase === 'done' && decidedUids.length){
      scheduleCenterMovesForUids(decidedUids);
      decidedUids.forEach((uid) => {
        if(decidedCenterMoveAnimated.has(uid)){
          requestAnimationFrame(() => {
            applyCenterMoveForUid(uid);
          });
        }
      });
    }
  });
  scheduleVoteChipAnimations();
  updateActionDeckUI();
  updateSweetsDeckUI();
  if(pendingWiretapZoomUid){
    const uid = pendingWiretapZoomUid;
    pendingWiretapZoomUid = null;
    requestAnimationFrame(() => {
      triggerWiretapZoom(uid);
    });
  }
}

/* =========================
   ターンUI更新
   ========================= */
function updateTurnUI(){
  if(!state.turn || state.game?.status !== 'playing' || allSeatedPlayersPassed()){
    if(actionSelection){
      clearActionSelection();
    }
    turnBar.classList.add('hidden');
    turnBadge.textContent = 'TURN';
    const wrap = document.querySelector('.my-hand-wrapper');
    wrap?.classList.remove('my-turn-free','my-turn-blocked','my-turn-selecting');
    renderMySweets();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  if(actionSelection && !isMyTurn()){
    clearActionSelection();
  }

  const activeP = getPlayerBySeat(state.turn.activeSeat);
  const activeName = activeP?.name ?? '？';
  turnBadge.textContent = isTurnBlocked()
    ? 'シャッフル中…'
    : `手番：${activeName}（${state.turn.activeSeat}）`;

  const show = (state.seatedTable !== null);
  turnBar.classList.toggle('hidden', !show);

  const mine = isMyTurn();
  btnPass.disabled = !mine;

  btnDrawSweets.disabled = true;
  btnVote.disabled = true;

  renderHands();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   4つの手番終了要因（今はパスのみ：既存）
   ========================= */
btnPass.addEventListener('click', async ()=>{
  await endTurn('pass');
});

/* =========================
   ★★★ 右下PASS（ラウンド用）
   - 押したら game/passes[uid]=true
   - その時点で次手番へ（pass済みを飛ばす）
   ========================= */
passRoundBtn.addEventListener('click', async ()=>{
  if(!state.roomCode) return;
  if(!isMyTurn()) return;
  if(!myDoneSweetsAndVote()) return;
  if(getActiveInstructionCards().length > 0) return;

  const gamePassRef = ref(db, `rooms/${state.roomCode}/game/passes/${state.userId}`);
  await set(gamePassRef, true);

  await endTurn('roundPass');
});

/* =========================
   ★★★ ラウンド終了判定＆選抜
   ========================= */
function requiredPickCountByPlayers(n){
  if(n <= 4) return 2;
  if(n <= 6) return 3;
  return 4; // 7-8
}
function getLeaderPlayerId(){
  const leaderSeat = state.turn?.leaderSeat ?? null;
  if(leaderSeat == null) return null;
  const p = getPlayerBySeat(leaderSeat);
  return p?.id ?? null;
}
function allSeatedPlayersPassed(){
  const pm = getPassedMap();
  if(!latestPlayers.length) return false;
  return latestPlayers.every(p => !!pm?.[p.id]);
}
function getSweetsCardByUid(uid){
  const hd = state.hands?.[uid];
  const arr = hd?.sweets;
  if(Array.isArray(arr) && arr.length) return arr[0];
  return null;
}
function getSweetsVoteStats(){
  // 各プレイヤー（スイーツ持ち）の票数
  const owners = getSweetsOwners();
  return owners.map(uid => ({
    uid,
    votes: getVoteCountFor(uid),
    card: getSweetsCardByUid(uid),
  })).filter(x => !!x.card);
}
function groupByVotesDesc(items){
  const sorted = [...items].sort((a,b)=>{
    if(b.votes !== a.votes) return b.votes - a.votes;
    return 0;
  });
  // 票数ごとにグループ
  const groups = [];
  for(const it of sorted){
    const last = groups[groups.length-1];
    if(!last || last.votes !== it.votes){
      groups.push({ votes: it.votes, items:[it] });
    }else{
      last.items.push(it);
    }
  }
  return groups;
}

/**
 * ホストだけが「全員PASS」を検知して、選抜フローを開始する
 * - roundEnding が false の時だけ開始
 * - 同票超過があれば roundPick.phase='choose' をセット
 * - 超過がなければ roundPick.phase='done' をセットしてイベント発火
 */
async function maybeHostStartRoundEndFlow(){
  if(!state.roomCode) return;
  if(!state.room?.gameStarted) return;
  if(state.game?.roundEnding) return;
  if(!allSeatedPlayersPassed()) return;

  const nPlayers = latestPlayers.length;
  const need = requiredPickCountByPlayers(nPlayers);

  const stats = getSweetsVoteStats();
  if(!stats.length){
    // スイーツが誰も無い場合は何もしない（仕様外）
    await update(ref(db, `rooms/${state.roomCode}/game`), { roundEnding:true, roundPick:{ phase:'done', selected:[], need:0 } });
    return;
  }

  const groups = groupByVotesDesc(stats);

  const selected = [];
  let remaining = need;

  // 上位グループから順に確定していくが、最後に同票で超過するならリーダー選択へ
  for(const g of groups){
    if(remaining <= 0) break;

    if(g.items.length <= remaining){
      selected.push(...g.items.map(x=>x.uid));
      remaining -= g.items.length;
      continue;
    }

    // ここで同票超過（g.items が remaining を超える）
    const leaderId = getLeaderPlayerId();
    const payload = {
      roundEnding: true,
      roundPick: {
        phase: 'choose',
        need: remaining,
        baseSelected: selected,
        candidates: g.items.map(x=>x.uid),
        leaderSeat: state.turn?.leaderSeat ?? null,
        leaderId,
      }
    };
    await update(ref(db, `rooms/${state.roomCode}/game`), payload);
    return;
  }

  // 超過なしで確定
  const finalSelected = selected.slice(0, need);
  await update(ref(db, `rooms/${state.roomCode}/game`), {
    roundEnding: true,
    roundPick: {
      phase: 'done',
      need: 0,
      selected: finalSelected,
      revealFiredKey: null,
    }
  });

}

/* =========================
   ★ 同票超過：リーダー選択UI
   - game.roundPick.phase === 'choose' のとき
   - leaderId の人だけクリック可能
   ========================= */
function getRoundPick(){
  return state.game?.roundPick || null;
}
function getLeaderPick(){
  return state.game?.leaderPick || null;
}
function shouldHoldVoteChips(){
  const lp = getLeaderPick();
  return !!lp && lp.phase !== 'done';
}
function canLeaderPickCandidate(uid){
  const lp = getLeaderPick();
  if(!lp || lp.phase !== 'choose') return false;
  if(lp.leaderId !== state.userId) return false;
  const candidates = Array.isArray(lp.candidates) ? lp.candidates : [];
  return candidates.includes(uid);
}
function updateLeaderPickUI(){
  const lp = getLeaderPick();
  const show = !!lp && lp.phase === 'choose' && lp.leaderId === state.userId;
  leaderPickPop.classList.toggle('hidden', !show);
}
async function requestLeaderPick(uid){
  if(!state.roomCode) return;
  if(!canLeaderPickCandidate(uid)) return;
  const lp = getLeaderPick() || {};
  await update(ref(db, `rooms/${state.roomCode}/game/leaderPick`), {
    phase: 'decided',
    decidedId: uid,
    candidates: Array.isArray(lp.candidates) ? lp.candidates : [],
    leaderId: lp.leaderId ?? null,
    leaderSeat: lp.leaderSeat ?? null,
    startAt: (typeof lp.startAt === 'number') ? lp.startAt : Date.now(),
  });
}

function getLeaderChipSizePx(){
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--leaderChipSize'));
  return Number.isFinite(size) ? size : 21.6;
}
function getLeaderChipOffsetPx(){
  const offset = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--leaderChipOffset'));
  return Number.isFinite(offset) ? offset : 22;
}
function getLeaderChipAnchorRect(tagEl){
  if(!tagEl) return null;
  const rect = tagEl.getBoundingClientRect();
  const size = getLeaderChipSizePx();
  const offset = getLeaderChipOffsetPx();
  return {
    left: rect.right + offset - size,
    top: rect.top + (rect.height - size) / 2,
    size,
  };
}
function animateLeaderChipMove(prevSeat, nextSeat){
  const prevTag = document.querySelector(`.player-tag[data-seat="${prevSeat}"]`);
  const nextTag = document.querySelector(`.player-tag[data-seat="${nextSeat}"]`);
  if(!prevTag || !nextTag) return;
  const from = getLeaderChipAnchorRect(prevTag);
  const to = getLeaderChipAnchorRect(nextTag);
  if(!from || !to) return;

  const chip = document.createElement('div');
  chip.className = 'leader-chip leader-chip-fly';
  chip.style.left = `${from.left}px`;
  chip.style.top = `${from.top}px`;
  document.body.appendChild(chip);

  const targetChip = nextTag.querySelector('.leader-chip');
  if(targetChip) targetChip.classList.add('leader-chip-hidden');

  const dx = to.left - from.left;
  const dy = to.top - from.top;
  chip.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1.4)` },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: 1200,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    chip.remove();
    if(targetChip) targetChip.classList.remove('leader-chip-hidden');
  };
}


function getActionDeckRect(){
  if(!actionDeckUI) return null;
  const rect = actionDeckUI.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function getPlayerTagRectBySeat(seat){
  const tag = document.querySelector(`.player-tag[data-seat="${seat}"]`);
  if(!tag) return null;
  const rect = tag.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function getMyHandRect(){
  if(myHandEl){
    const rect = myHandEl.getBoundingClientRect();
    if(rect.width && rect.height) return rect;
  }
  const wrap = document.querySelector('.my-hand-wrapper');
  if(!wrap) return null;
  const rect = wrap.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function getOtherPlayerHandRectBySeat(seat){
  const tag = document.querySelector(`.player-tag[data-seat="${seat}"]`);
  if(!tag) return null;
  const miniHand = tag.querySelector('.mini-hand');
  if(miniHand){
    const rect = miniHand.getBoundingClientRect();
    if(rect.width && rect.height) return rect;
  }
  const rect = tag.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function animateActionDealCard(toSeat, delayMs = 0){
  const from = getActionDeckRect();
  const to = getPlayerTagRectBySeat(toSeat);
  if(!from || !to) return;

  const card = document.createElement('div');
  card.className = 'action-deal-card';
  card.style.left = `${from.left}px`;
  card.style.top = `${from.top}px`;
  card.style.width = `${from.width}px`;
  card.style.height = `${from.height}px`;
  document.body.appendChild(card);

  const dx = (to.left + to.width / 2) - (from.left + from.width / 2);
  const dy = (to.top + to.height / 2) - (from.top + from.height / 2);
  const scale = Math.min(to.width / from.width, to.height / from.height, 1.2);

  card.animate([
    { transform: 'translate(0px, 0px) rotate(-12deg) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(0deg) scale(${scale})` },
  ], {
    duration: 600,
    delay: delayMs,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    card.remove();
  };
}
function animateActionDrawToHand(toUid, toSeat, delayMs = 0){
  const from = getActionDeckRect();
  if(!from) return;

  let targetRect = null;
  if(toUid && toUid === state.userId){
    targetRect = getMyHandRect();
  }else{
    const seat = (typeof toSeat === 'number') ? toSeat : getSeatByUid(toUid);
    if(typeof seat === 'number'){
      targetRect = getOtherPlayerHandRectBySeat(seat);
    }
  }
  if(!targetRect) return;

  const card = document.createElement('div');
  card.className = 'action-deal-card';
  card.style.left = `${from.left}px`;
  card.style.top = `${from.top}px`;
  card.style.width = `${from.width}px`;
  card.style.height = `${from.height}px`;
  document.body.appendChild(card);

  const dx = (targetRect.left + targetRect.width / 2) - (from.left + from.width / 2);
  const dy = (targetRect.top + targetRect.height / 2) - (from.top + from.height / 2);
  const scale = Math.min(targetRect.width / from.width, targetRect.height / from.height, 1.2);

  card.animate([
    { transform: 'translate(0px, 0px) rotate(-10deg) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(0deg) scale(${scale})` },
  ], {
    duration: 620,
    delay: delayMs,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    card.remove();
  };
}
function schedulePostActionDealMiniShuffle(leaderSeat, delayMs){
  if(!state.isHost || !state.roomCode) return;
  const waitMs = Math.max(0, delayMs || 0);
  setTimeout(() => {
    emitEvent({
      type: 'miniSweetsShuffleStart',
      reason: 'afterActionDeal',
      leaderSeat,
    });
  }, waitMs);
}

async function hostDealActionCardsFromLeader(leaderSeat){
  if(!state.isHost || !state.roomCode) return;
  if(leaderSeat == null) return;

  const base = `rooms/${state.roomCode}`;
  const [handsSnap, decksSnap, gameSnap] = await Promise.all([
    get(ref(db, `${base}/hands`)),
    get(ref(db, `${base}/decks`)),
    get(ref(db, `${base}/game`)),
  ]);
  const hands = handsSnap.val() || {};
  const decks = decksSnap.val() || {};
  const gameNow = gameSnap.val() || {};

  if(gameNow?.actionDealKey){
    return;
  }

  const deck = Array.isArray(decks.action) ? [...decks.action] : [];

  const seatOrder = Array.isArray(gameNow.seatOrder) && gameNow.seatOrder.length
    ? gameNow.seatOrder
    : getSeatedSeatOrder();
  const startIdx = seatOrder.indexOf(leaderSeat);
  if(startIdx === -1) return;

  const deals = [];
  for(let i = 0; i < seatOrder.length; i++){
    const seat = seatOrder[(startIdx + i) % seatOrder.length];
    const player = getPlayerBySeat(seat);
    if(!player) continue;
    const hand = hands[player.id];
    const action = Array.isArray(hand?.action) ? hand.action : [];
    if(action.length >= 3) continue;
    if(!deck.length) break;
    const card = deck.shift();
    if(!card) continue;
    action.push(card);
    hands[player.id] = { ...(hand || {}), action };
    deals.push({ seat });
  }


  const dealKey = `${leaderSeat}-${Date.now()}`;
  const updates = {
    'game/actionDealKey': dealKey,
  };
  if(deals.length){
    updates.hands = hands;
    updates['decks/action'] = deck;
  }

  await update(ref(db, base), updates);
  for(let i = 0; i < deals.length; i++){
    await emitEvent({
      type: 'dealActionCard',
      toSeat: deals[i].seat,
      delayMs: i * 120,
    });
  }
  const lastDelay = (deals.length > 0) ? ((deals.length - 1) * 120 + 650) : 200;
  schedulePostActionDealMiniShuffle(leaderSeat, lastDelay);

}


function maybeHostApplyLeaderPick(){
  if(!state.isHost || !state.roomCode) return;
  const lp = getLeaderPick();
  if(!lp || lp.phase === 'done'){
    if(leaderPickApplyTimer){
      clearTimeout(leaderPickApplyTimer);
      leaderPickApplyTimer = null;
    }
    return;
  }

  const decidedId = lp.decidedId || lp.nextLeaderId || null;
  if(!decidedId) return;

  const key = `${lp.phase}:${decidedId}:${lp.startAt ?? ''}`;
  if(leaderPickApplyKey === key && leaderPickApplyTimer) return;

  if(leaderPickApplyTimer){
    clearTimeout(leaderPickApplyTimer);
    leaderPickApplyTimer = null;
  }
  leaderPickApplyKey = key;

  const baseDelay = (typeof lp.startAt === 'number') ? lp.startAt : Date.now();
  const delay = Math.max(0, baseDelay + 1000 - Date.now());

  leaderPickApplyTimer = setTimeout(async () => {
    leaderPickApplyTimer = null;
    const seat = getSeatByUid(decidedId);
    if(seat == null) return;

    await update(ref(db, `rooms/${state.roomCode}/game/turn`), {
      leaderSeat: seat,
    });
    await update(ref(db, `rooms/${state.roomCode}/game/leaderPick`), {
      phase: 'done',
      decidedId,
      appliedAt: Date.now(),
    });
    const handsSnap = await get(ref(db, `rooms/${state.roomCode}/hands`));
    const hands = handsSnap.val() || {};
    Object.keys(hands).forEach(uid => {
      if(!hands[uid] || typeof hands[uid] !== 'object') hands[uid] = {};
      hands[uid].voteChips = 1;
    });
    await Promise.all([
      set(ref(db, `rooms/${state.roomCode}/votes`), {}),
      set(ref(db, `rooms/${state.roomCode}/hands`), hands),
    ]);
    setTimeout(() => {
      hostDealActionCardsFromLeader(seat);
    }, 650);
  }, delay);
}
function isLeaderMe(){
  const rp = getRoundPick();
  return !!rp && (rp.leaderId === state.userId);
}
function getDecidedSweetsUids(){
  const rp = getRoundPick();
  if(!rp) return [];
  if(rp.phase === 'choose'){
    return Array.isArray(rp.baseSelected) ? rp.baseSelected : [];
  }
  if(rp.phase === 'done'){
    return Array.isArray(rp.selected) ? rp.selected : [];
  }
  return [];
}

function resetCollectedSweetsHiddenCache(){
  if(!state.game?.roundEnding){
    collectedSweetsHidden.clear();
    decidedSweetsAnimated.clear();
    decidedCenterMoveAnimated.clear();
    decidedCenterMoveTimers.forEach((timerId) => clearTimeout(timerId));
    decidedCenterMoveTimers.clear();
    if(centerMoveBatchTimerId){
      clearTimeout(centerMoveBatchTimerId);
      centerMoveBatchTimerId = null;
    }
    centerMoveBatchKey = null;
    decidedRoundKey = null;
    decidedRoundStartAt = null;
    document.querySelectorAll('.collect-hidden').forEach(el => {
      el.classList.remove('collect-hidden');
    });
  }
}





const roundPickDrag = {
  active:false,
  uid:null,
  ghost:null,
  offsetX:0,
  offsetY:0,
  sourceEl:null,
  sourceHidden:false,
  sourceVisibility:'',
  voteChipHidden:false,
  voteChipVisibility:'',
};

function canLeaderDragPick(uid){
  const rp = getRoundPick();
  const candidates = rp && Array.isArray(rp.candidates) ? rp.candidates : [];
  return !!rp && rp.phase === 'choose' && rp.leaderId === state.userId && candidates.includes(uid);
}

function startRoundPickDrag(e, uid){
  if(!canLeaderDragPick(uid)) return;
  e.preventDefault();

  const source = e.currentTarget;
  const r = source.getBoundingClientRect();
  roundPickDrag.active = true;
  roundPickDrag.uid = uid;
  roundPickDrag.offsetX = e.clientX - r.left;
  roundPickDrag.offsetY = e.clientY - r.top;
  roundPickDrag.sourceEl = source;
  roundPickDrag.sourceHidden = true;
  roundPickDrag.sourceVisibility = source.style.visibility;
  source.style.visibility = 'hidden';
  if(uid === state.userId){
    roundPickDrag.voteChipHidden = true;
    roundPickDrag.voteChipVisibility = myVoteChipEl.style.visibility;
    myVoteChipEl.style.visibility = 'hidden';
  }

  const ghost = document.createElement('div');
  ghost.className = 'roundpick-dragging';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${source.offsetWidth}px`;
  ghost.style.height = `${source.offsetHeight}px`;
  ghost.style.transformOrigin = 'center';

  const circle = source.closest('.otherplayerscircle');
  const rotDeg = circle ? getComputedStyle(circle).getPropertyValue('--rotDeg').trim() : '0deg';
  if(uid !== state.userId && rotDeg){
    ghost.style.transform = `rotate(${rotDeg})`;
  }

  const card = getSweetsCardByUid(uid);
  const faceImg = card?.img || card?.fallback || SWEETS_BACK_IMG;
  const bgImg = (uid === state.userId) ? faceImg : SWEETS_BACK_IMG;
  ghost.style.backgroundImage = `url('${bgImg}')`;

  document.body.appendChild(ghost);
  roundPickDrag.ghost = ghost;

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onRoundPickDragMove);
  ghost.addEventListener('pointerup', onRoundPickDragEnd);
  ghost.addEventListener('pointercancel', onRoundPickDragEnd);
}

function onRoundPickDragMove(e){
  if(!roundPickDrag.active || !roundPickDrag.ghost) return;
  const x = e.clientX - roundPickDrag.offsetX;
  const y = e.clientY - roundPickDrag.offsetY;
  roundPickDrag.ghost.style.left = `${x}px`;
  roundPickDrag.ghost.style.top  = `${y}px`;

  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (e.clientX >= pr.left && e.clientX <= pr.right && e.clientY >= pr.top && e.clientY <= pr.bottom);
  playCircleEl.classList.toggle('roundpick-target', inPlay);
}

async function onRoundPickDragEnd(e){
  if(!roundPickDrag.active) return;

  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (e.clientX >= pr.left && e.clientX <= pr.right && e.clientY >= pr.top && e.clientY <= pr.bottom);
  const uid = roundPickDrag.uid;

  cleanupRoundPickDrag();

  if(inPlay && uid){
    await leaderPickOne(uid);
  }
}

function cleanupRoundPickDrag(){
  playCircleEl.classList.remove('roundpick-target');
  if(roundPickDrag.ghost){
    roundPickDrag.ghost.removeEventListener('pointermove', onRoundPickDragMove);
    roundPickDrag.ghost.removeEventListener('pointerup', onRoundPickDragEnd);
    roundPickDrag.ghost.removeEventListener('pointercancel', onRoundPickDragEnd);
    roundPickDrag.ghost.remove();
  }
  if(roundPickDrag.sourceEl && roundPickDrag.sourceHidden){
    roundPickDrag.sourceEl.style.visibility = roundPickDrag.sourceVisibility || '';
  }
  if(roundPickDrag.voteChipHidden){
    myVoteChipEl.style.visibility = roundPickDrag.voteChipVisibility || '';
  }
  roundPickDrag.active = false;
  roundPickDrag.uid = null;
  roundPickDrag.ghost = null;
  roundPickDrag.offsetX = 0;
  roundPickDrag.offsetY = 0;
  roundPickDrag.sourceEl = null;
  roundPickDrag.sourceHidden = false;
  roundPickDrag.sourceVisibility = '';
  roundPickDrag.voteChipHidden = false;
  roundPickDrag.voteChipVisibility = '';
}
function updateRoundPickUI(){
  const rp = getRoundPick();
  const roundPickActive = !!rp && rp.phase === 'choose';
  const candidates = roundPickActive && Array.isArray(rp.candidates) ? rp.candidates : [];
  const leaderCanSelect = roundPickActive && rp.leaderId === state.userId;
  const meIsCandidate = leaderCanSelect && candidates.includes(state.userId);
  const meCanSelect = leaderCanSelect && meIsCandidate;

  mySweetsEl.classList.toggle('roundpick-candidate', meIsCandidate);
  mySweetsEl.classList.toggle('roundpick-selectable', meCanSelect);

  if(meCanSelect){
    mySweetsEl.onpointerdown = (e) => {
      e.stopPropagation();
      startRoundPickDrag(e, state.userId);
    };
  }else{
    mySweetsEl.onpointerdown = null;
  }

}
async function leaderPickOne(uid){
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'choose') return;
  if(rp.leaderId !== state.userId) return;

  const need = Number(rp.need || 0);
  if(need <= 0) return;

  const baseSelected = Array.isArray(rp.baseSelected) ? rp.baseSelected : [];
  const candidates = Array.isArray(rp.candidates) ? rp.candidates : [];

  if(!candidates.includes(uid)) return;

  const nextSelected = [...baseSelected, uid];
  const nextCandidates = candidates.filter(x=>x !== uid);
  const nextNeed = need - 1;

  if(nextNeed > 0){
    await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
      phase:'choose',
      need: nextNeed,
      baseSelected: nextSelected,
      candidates: nextCandidates,
      leaderSeat: rp.leaderSeat ?? null,
      leaderId: rp.leaderId ?? null,
    });
    return;
  }

  await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
    phase:'done',
    need: 0,
    selected: nextSelected,
    revealFiredKey: null,
  });

  // ホストがイベント発火するのが原則だが、念のためリーダーでも発火できるようにする（重複は回避）
  // → ホスト側は roundPick.phase='done' を見て発火しない設計にしていないので、ここは発火しない
  //    代わりに、ホストが subscribeGame で roundEnding=true を見て発火済みのケースがあるので、
  //    ここでは「ホストに任せる」。
}

/* ★ ホスト：roundPick が done になったらイベント発火（未発火なら） */
async function maybeHostFireRoundRevealAfterLeaderPick(){
 if(!state.isHost) return;
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'done') return;
  if(!state.game?.roundEnding) return;

  const selected = Array.isArray(rp.selected) ? rp.selected : [];
  const key = selected.join(',');
  if(rp.revealFiredKey === key) return;

  await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
    revealFiredKey: key,
  });

  const cards = selected.map(uid => getSweetsCardByUid(uid)).filter(Boolean);
  await emitEvent({ type:'roundRevealSweets', selectedUids: selected, cards });
}


/* =========================
   ★★★ ラウンド終了演出（全員）
   - 選ばれたスイーツ（裏）を中央へ集める
   - 中央でシャッフルっぽい動き
   - 表にして中央に横並び（折り返しなし）
   - 3秒表示後、消える
   ========================= */
let _roundAnimRunning = false;
function getRoundCollectCenter(){
  const r = playCircleEl?.getBoundingClientRect?.();
  if(r && r.width && r.height){
    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
  }
  return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
}
function getSweetsSourceRect(uid, fallback){
  const el = document.querySelector(`[data-sweets-uid="${uid}"]`);
  if(el){
    const r = el.getBoundingClientRect();
    if(r && r.width && r.height){
      return r;
    }
  }
  return fallback;
}

function toggleCollectHiddenForUids(uids, hidden){
  const list = Array.isArray(uids) ? uids : [];
  list.forEach(uid => {
    const targets = document.querySelectorAll(`[data-sweets-uid="${uid}"]`);
    targets.forEach(el => {
      el.classList.toggle('collect-hidden', hidden);
    });
    if(hidden){
      collectedSweetsHidden.add(uid);
    }
  });
}


/* =========================
   ★★★ ラウンド終了：回収→シャッフル→拡大表示（全員）
   - ゴースト防止：元位置DOMを collect-hidden で不可視化
   - 二重防止：stopRoundEndFx() + token で排他
   ========================= */

const roundEndFx = {
  token: 0,
  timers: new Set(),
  anims: new Set(),
  nodes: new Set(),
  restores: [],
};

function _fxRememberRestore(fn){
  roundEndFx.restores.push(fn);
}
function _fxSetTimeout(fn, ms, token){
  const id = setTimeout(() => {
    roundEndFx.timers.delete(id);
    if(token !== roundEndFx.token) return;
    fn();
  }, ms);
  roundEndFx.timers.add(id);
  return id;
}
function _fxSleep(ms, token){
  return new Promise(resolve => _fxSetTimeout(resolve, ms, token));
}

/** ★ 強制停止＆後始末（“前の”演出を完全に殺す） */
function stopRoundEndFx(){
  // token更新（これで進行中awaitは全部無効化）
  roundEndFx.token++;

  // timers
  for(const t of roundEndFx.timers) clearTimeout(t);
  roundEndFx.timers.clear();

  // anims
  for(const a of roundEndFx.anims){
    try{ a.cancel(); }catch(_){}
  }
  roundEndFx.anims.clear();

  // nodes
  for(const n of roundEndFx.nodes){
    try{ n.remove(); }catch(_){}
  }
  roundEndFx.nodes.clear();

  // restore（途中停止時だけ元に戻す）
  for(const r of roundEndFx.restores){
    try{ r(); }catch(_){}
  }
  roundEndFx.restores = [];

  // overlay掃除（ゴースト残し防止）
  try{
    roundRevealRow.innerHTML = '';
    roundRevealOverlay.classList.add('hidden');
  }catch(_){}
  resetRoundRevealState();
}


/** ★ “元位置”として最優先で使うDOMを探す（ゴースト防止のため） */
function _pickOriginElForUid(uid){
  // 1) decided表示（タグ上の selected-sweets-tag）
  let el = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"]`);
  if(el) return el;

  // 2) 他プレイヤーのスイーツ枠（sweets-wrap）
  el = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"]`);
  if(el) return el;

  // 3) 自分の手元スイーツ
  if(uid === state.userId && mySweetsEl && !mySweetsEl.classList.contains('hidden')){
    return mySweetsEl;
  }

  return null;
}

/** ★ 元位置を不可視化（“ゴースト”＝残像防止） */
function _hideOriginVisual(uid, originEl){
  if(!originEl) return;

  // sweets-wrap / selected-sweets-tag は既存CSSの collect-hidden を使う
  if(originEl.classList.contains('sweets-wrap') || originEl.classList.contains('selected-sweets-tag')){
    if(!originEl.classList.contains('collect-hidden')){
      originEl.classList.add('collect-hidden');
      collectedSweetsHidden.add(uid);
      _fxRememberRestore(()=> {
        originEl.classList.remove('collect-hidden');
        collectedSweetsHidden.delete(uid);
      });
    }
    return;
  }

  // mySweetsEl など：visibilityで消す（レイアウトは保持）
  const prevVis = originEl.style.visibility;
  originEl.style.visibility = 'hidden';
  collectedSweetsHidden.add(uid);
  _fxRememberRestore(()=> {
    originEl.style.visibility = prevVis;
    collectedSweetsHidden.delete(uid);
  });
}

/** ★ 回収カード（裏）を作成 */
function _createCollectCardAtRect(rect){
  const node = document.createElement('div');
  node.className = 'collect-card';
  node.style.left = `${rect.left}px`;
  node.style.top  = `${rect.top}px`;
  node.style.width  = `${rect.width}px`;
  node.style.height = `${rect.height}px`;
  // collect-card の background はCSSで swsweetsura.jpg になってる前提（既存のまま）
  document.body.appendChild(node);
  roundEndFx.nodes.add(node);
  return node;
}

/** ★ 中央座標（PLAYを中心に。無理なら画面中央） */
function _getCenterPoint(){
  const pr = playCircleEl?.getBoundingClientRect?.();
  if(pr && pr.width && pr.height){
    return { x: pr.left + pr.width/2, y: pr.top + pr.height/2 };
  }
  return { x: window.innerWidth/2, y: window.innerHeight/2 };
}

/** ★ シャッフル演出（中央） */
/** ★ シャッフル演出（sweetshuffle1） */
async function _runSweetShuffle1(token){
  const stage = document.createElement('div');
  stage.className = 'sweets-shuffle-stage';
  document.body.appendChild(stage);
  roundEndFx.nodes.add(stage);

  const OFFSET_X = 4;
  const OFFSET_Y = 4;
  const OUT_X = 78;
  const TILT_BASE = 5;
  const TILT_MORE = 5;
  const DUR_OUT = 220;
  const DUR_IN = 220;
  const PAUSE = 20;
  const LOOPS = 3;
  const base = 'translate(-50%,-50%)';
  const baseFront = `${base} translate(0px,0px) rotate(${TILT_BASE}deg)`;
  const baseBack = `${base} translate(${OFFSET_X}px,${OFFSET_Y}px) rotate(${TILT_BASE}deg)`;
  const outTransform = `${base} translate(${OUT_X}px,0px) rotate(${TILT_BASE + TILT_MORE}deg)`;

  const back = document.createElement('div');
  back.className = 'sweets-shuffle-card';
  back.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  back.style.zIndex = '1';
  back.style.transform = baseBack;

  const front = document.createElement('div');
  front.className = 'sweets-shuffle-card';
  front.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  front.style.zIndex = '2';
  front.style.transform = baseFront;

  stage.appendChild(back);
  stage.appendChild(front);

  const animateOnce = (el, keyframes, options) => {
    const anim = el.animate(keyframes, options);
    roundEndFx.anims.add(anim);
    return new Promise(resolve => {
      anim.onfinish = () => {
        roundEndFx.anims.delete(anim);
        resolve();
      };
      anim.oncancel = () => {
        roundEndFx.anims.delete(anim);
        resolve();
      };
    });
  };

  let frontEl = front;
  let backEl = back;

  for(let i=0;i<LOOPS;i++){
    if(token !== roundEndFx.token) return;
    await animateOnce(frontEl, [
      { transform: baseFront },
      { transform: outTransform },
    ], {
      duration: DUR_OUT,
      easing: 'ease-in-out',
      fill: 'forwards',
    });

    if(token !== roundEndFx.token) return;
    frontEl.style.transform = outTransform;
    frontEl.style.zIndex = '1';
    backEl.style.zIndex = '2';
    backEl.style.transform = baseFront;

    await animateOnce(frontEl, [
      { transform: outTransform },
      { transform: baseBack },
    ], {
      duration: DUR_IN,
      easing: 'ease-in-out',
      fill: 'forwards',
    });

    if(token !== roundEndFx.token) return;
    frontEl.style.transform = baseBack;

    const tmp = frontEl;
    frontEl = backEl;
    backEl = tmp;

    await new Promise(resolve => setTimeout(resolve, PAUSE));
  }

  if(token !== roundEndFx.token) return;
  stage.remove();
  roundEndFx.nodes.delete(stage);
}

async function getSweetsDeckRectForMiniShuffle(){
  if(!sweetsDeckUI) return null;
  let rect = sweetsDeckUI.getBoundingClientRect();
  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }

  const wasCenterHidden = centerDecksEl.classList.contains('hidden');
  const wasSweetsHidden = sweetsDeckUI.classList.contains('hidden');
  const prevCenterVisibility = centerDecksEl.style.visibility;
  const prevSweetsVisibility = sweetsDeckUI.style.visibility;

  centerDecksEl.classList.remove('hidden');
  sweetsDeckUI.classList.remove('hidden');
  centerDecksEl.style.visibility = 'hidden';
  sweetsDeckUI.style.visibility = 'hidden';

  for(let i=0;i<6;i++){
    rect = sweetsDeckUI.getBoundingClientRect();
    if(rect && rect.width > 0 && rect.height > 0){
      break;
    }
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
  }

  centerDecksEl.style.visibility = prevCenterVisibility;
  sweetsDeckUI.style.visibility = prevSweetsVisibility;
  if(wasSweetsHidden) sweetsDeckUI.classList.add('hidden');
  if(wasCenterHidden) centerDecksEl.classList.add('hidden');

  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }
  return null;
}

async function getSweetsExcludedDeckRectForMiniShuffle(){
  if(!sweetsExcludedDeckUI) return null;
  let rect = sweetsExcludedDeckUI.getBoundingClientRect();
  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }

  const wasHidden = sweetsExcludedDeckUI.classList.contains('hidden');
  const prevVisibility = sweetsExcludedDeckUI.style.visibility;
  const prevAnimating = sweetsExcludeAnimating;

 sweetsExcludedDeckUI.style.visibility = prevVisibility;
  sweetsExcludeAnimating = prevAnimating;
  if(wasHidden){
    sweetsExcludedDeckUI.classList.add('hidden');
  } else {
    sweetsExcludedDeckUI.classList.remove('hidden');
  }
  updateSweetsDeckUI();

  for(let i=0;i<6;i++){
    rect = sweetsExcludedDeckUI.getBoundingClientRect();
    if(rect && rect.width > 0 && rect.height > 0){
      break;
    }
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
  }

  sweetsExcludedDeckUI.style.visibility = prevVisibility;
  sweetsExcludeAnimating = prevAnimating;
  if(wasHidden) sweetsExcludedDeckUI.classList.add('hidden');

  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }
  return null;
}

function getPlayerCountForSweetsSplit(){
  const seatOrder = state.game?.seatOrder;
  if(Array.isArray(seatOrder) && seatOrder.length){
    return seatOrder.length;
  }
  if(Array.isArray(latestPlayers) && latestPlayers.length){
    return latestPlayers.length;
  }
  const tables = state.room?.tables;
  if(tables && typeof tables === 'object'){
    return Object.values(tables).filter(t => t && t.playerId).length;
  }
  return 0;
}

async function getSweetsDeckForMiniShuffle(){
  const deck = state.room?.decks?.sweets;
  if(Array.isArray(deck) && deck.length){
    return deck;
  }
  if(!state.roomCode) return deck;
  try{
    const snap = await get(ref(db, `rooms/${state.roomCode}/decks/sweets`));
    const data = snap.val();
    if(Array.isArray(data)) return data;
  }catch(_){}
  return deck;
}

async function animateSweetsExcludeMove(fromRect, toRect, totalCount, keepCount){
  const moveCount = Math.max(0, totalCount - keepCount);
  if(moveCount <= 0) return;

  sweetsExcludeAnimating = true;
  setSweetsCountOverrides(totalCount, 0);
  updateSweetsDeckUI();

  const dx = toRect.left - fromRect.left;
  const dy = toRect.top - fromRect.top;
  const duration = 260;

  const card = document.createElement('div');
  card.className = 'sweets-move-card';
  card.style.width = `${fromRect.width}px`;
  card.style.height = `${fromRect.height}px`;
  card.style.left = `${fromRect.left}px`;
  card.style.top = `${fromRect.top}px`;
  document.body.appendChild(card);

  const anim = card.animate([
    { transform: 'translate(0px,0px) rotate(0deg)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(90deg)` },
  ], {
    duration,
    easing: 'ease-in-out',
    fill: 'forwards',
  });

  await new Promise(resolve => {
    anim.onfinish = resolve;
    anim.oncancel = resolve;
  });
  card.remove();

  sweetsExcludeAnimating = false;
  setSweetsCountOverrides(keepCount, moveCount, 5000);
  updateSweetsDeckUI();
}

async function maybeHostApplySweetsSplit(deck, playerCount){
  if(!state.isHost || !state.roomCode) return;
  const currentExcluded = state.room?.decks?.sweetsExcluded;
  if(Array.isArray(currentExcluded) && currentExcluded.length) return;
  const keepCount = clamp(playerCount + 2, 0, Array.isArray(deck) ? deck.length : 0);
  if(!Array.isArray(deck) || deck.length <= keepCount) return;

  const { sweets, excluded } = splitSweetsDeck(deck, playerCount);
  const decksRef = ref(db, `rooms/${state.roomCode}/decks`);
  await update(decksRef, { sweets, sweetsExcluded: excluded });
}

async function runMiniSweetsShuffleAtStart(opts = {}){
  if(miniShuffleRunning) return;
  const reason = opts?.reason || null;
  const leaderSeatForRestart = (typeof opts?.leaderSeat === 'number')
    ? opts.leaderSeat
    : (state.turn?.leaderSeat ?? null);
  turnBlockedByShuffle = true;
  updateTurnUI();
  try{

    const rect = await getSweetsDeckRectForMiniShuffle();
    if(!rect){
      const deck = await getSweetsDeckForMiniShuffle();
      const totalCount = Array.isArray(deck) ? deck.length : 0;
      const playerCount = getPlayerCountForSweetsSplit();
      const keepCount = clamp(playerCount + 2, 0, totalCount);
      const moveCount = Math.max(0, totalCount - keepCount);
      if(moveCount > 0){
        sweetsExcludeAnimating = true;
        setSweetsCountOverrides(keepCount, moveCount, 5000);
        updateSweetsDeckUI();
        sweetsExcludeAnimating = false;
      }
     await maybeHostApplySweetsSplit(deck, playerCount);
      if(reason === 'afterActionDeal'){
        await hostRestartTurnAfterActionDeal(leaderSeatForRestart);
      }else{
        await hostGrantTurnAfterMiniShuffle();
      }
      return;
    }

    const token = ++miniShuffleToken;
    miniShuffleRunning = true;
    updateSweetsDeckUI();

    const cardSample = sweetsDeckUI.querySelector('.card');
    const cardStyle = cardSample ? getComputedStyle(cardSample) : null;
    const cardRadius = cardStyle?.borderRadius || '7px';
    const cardBorder = cardStyle?.border || '1px solid rgba(0,0,0,.18)';
    const cardShadow = cardStyle?.boxShadow || 'none';

    const stage = document.createElement('div');
    stage.className = 'sweets-shuffle-stage';
    stage.style.left = `${rect.left + rect.width / 2}px`;
    stage.style.top = `${rect.top + rect.height / 2}px`;
    stage.style.width = `${rect.width}px`;
    stage.style.height = `${rect.height}px`;
    document.body.appendChild(stage);

    try{
      const BASE_W = 120;
      const BASE_H = 170;
      const scale = Math.min(rect.width / BASE_W, rect.height / BASE_H);
      const OFFSET_X = 4 * scale;
      const OFFSET_Y = 4 * scale;
      const OUT_X = 78 * scale;
      const TILT_BASE = 5;
      const TILT_MORE = 5;
      const DUR_OUT = 220;
      const DUR_IN = 220;
      const PAUSE = 20;
      const LOOPS = 3;
      const base = 'translate(-50%,-50%)';
      const baseFront = `${base} translate(0px,0px) rotate(${TILT_BASE}deg)`;
      const baseBack = `${base} translate(${OFFSET_X}px,${OFFSET_Y}px) rotate(${TILT_BASE}deg)`;
      const outTransform = `${base} translate(${OUT_X}px,0px) rotate(${TILT_BASE + TILT_MORE}deg)`;

      const createCard = (zIndex, transform) => {
        const el = document.createElement('div');
        el.className = 'sweets-shuffle-card';
        el.style.width = `${rect.width}px`;
        el.style.height = `${rect.height}px`;
        el.style.borderRadius = cardRadius;
        el.style.border = cardBorder;
        el.style.boxShadow = cardShadow;
        el.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
        el.style.zIndex = String(zIndex);
        el.style.transform = transform;
        return el;
      };

      const back = createCard(1, baseBack);
      const front = createCard(2, baseFront);
      stage.appendChild(back);
      stage.appendChild(front);

      const animateOnce = (el, keyframes, options) => new Promise(resolve => {
        const anim = el.animate(keyframes, options);
        anim.onfinish = resolve;
        anim.oncancel = resolve;
      });

      let frontEl = front;
      let backEl = back;

      for(let i=0;i<LOOPS;i++){
        if(token !== miniShuffleToken) return;
        await animateOnce(frontEl, [
          { transform: baseFront },
          { transform: outTransform },
        ], {
          duration: DUR_OUT,
          easing: 'ease-in-out',
          fill: 'forwards',
        });

        if(token !== miniShuffleToken) return;
        frontEl.style.transform = outTransform;
        frontEl.style.zIndex = '1';
        backEl.style.zIndex = '2';
        backEl.style.transform = baseFront;

        await animateOnce(frontEl, [
          { transform: outTransform },
          { transform: baseBack },
        ], {
          duration: DUR_IN,
          easing: 'ease-in-out',
          fill: 'forwards',
        });

        if(token !== miniShuffleToken) return;
        frontEl.style.transform = baseBack;

        const tmp = frontEl;
        frontEl = backEl;
        backEl = tmp;

        await new Promise(resolve => setTimeout(resolve, PAUSE));
      }
    } finally {
      stage.remove();
      if(token === miniShuffleToken){
        miniShuffleRunning = false;
        updateSweetsDeckUI();
      }
    }
    if(token !== miniShuffleToken) return;

    const deck = await getSweetsDeckForMiniShuffle();
    const totalCount = Array.isArray(deck) ? deck.length : 0;
    const playerCount = getPlayerCountForSweetsSplit();
    const keepCount = clamp(playerCount + 2, 0, totalCount);
    const moveCount = Math.max(0, totalCount - keepCount);

    const targetRect = await getSweetsExcludedDeckRectForMiniShuffle();
    if(rect && targetRect && moveCount > 0){
      await animateSweetsExcludeMove(rect, targetRect, totalCount, keepCount);
    } else if(moveCount > 0){
      setSweetsCountOverrides(keepCount, moveCount, 5000);
      updateSweetsDeckUI();
    }

    await maybeHostApplySweetsSplit(deck, playerCount);
    if(token !== miniShuffleToken) return;
    if(reason === 'afterActionDeal'){
      await hostRestartTurnAfterActionDeal(leaderSeatForRestart);
    }else{
      await hostGrantTurnAfterMiniShuffle();
    }
  } finally {
    turnBlockedByShuffle = false;
    updateTurnUI();
  }
}

async function animateRoundEndReveal(cards, selectedUids){
  if(_roundAnimRunning){
    stopRoundEndFx();
    _roundAnimRunning = false;
  }
  _roundAnimRunning = true;

  try{
    stopRoundEndFx();
    const token = roundEndFx.token;

    document.querySelectorAll('.collect-card').forEach(el => el.remove());
    roundRevealRow.innerHTML = '';
    roundRevealOverlay.classList.add('hidden');

    const uids = Array.isArray(selectedUids) ? selectedUids : [];
    ensureDecidedRoundStart(uids);
    scheduleCenterMovesForUids(uids);

    await waitForDecidedTimestamps(uids);
    const latestDecidedAt = getLatestAppliedDecidedAt(uids);    const centerMoveStartAt = latestDecidedAt + DECIDED_CENTER_DELAY_MS;
    const shuffleStartAt = centerMoveStartAt + 1200;
    const waitMs = Math.max(0, shuffleStartAt - Date.now());
    if(waitMs > 0){
      await new Promise(resolve => setTimeout(resolve, waitMs));
    }
    if(token !== roundEndFx.token) return;

    uids.forEach(uid => {
      const origin = _pickOriginElForUid(uid);
      _hideOriginVisual(uid, origin);
    });

    await _runSweetShuffle1(token);
    if(token !== roundEndFx.token) return;

    roundRevealRow.innerHTML = '';
    (Array.isArray(cards) ? cards : []).forEach(card => {
      const el = document.createElement('div');
      el.className = 'roundreveal-card';
      const img = document.createElement('img');
      img.src = card?.img || card?.fallback || SWEETS_BACK_IMG;
      img.alt = `sweets ${card?.value ?? ''}`;
      img.onerror = () => { if(card?.fallback) img.src = card.fallback; };
     el.appendChild(img);
      roundRevealRow.appendChild(el);
    });
    markRoundRevealStarted();
    roundRevealOverlay.classList.remove('hidden');

    await new Promise(resolve => setTimeout(resolve, 2800));
    if(token !== roundEndFx.token) return;

    roundRevealOverlay.classList.add('hidden');
    roundRevealRow.innerHTML = '';
    markRoundRevealFinished();

    for(const restore of roundEndFx.restores){
      try{ restore(); }catch(_){}
    }
    roundEndFx.restores = [];
  } finally {
    _roundAnimRunning = false;
    if(roundRevealState.started && !roundRevealState.finished){
      markRoundRevealFinished();
    }
  }
}

/* =========================
   ドラッグ＆ドロップ（アクションカード）
   ========================= */
const drag = {
  active:false,
  card:null,
  el:null,
  offsetX:0, offsetY:0,
  originRect:null,
  lastClientX:null,
  lastClientY:null,
};

function canUseOnPlayCircle(card){
  if(card.kind !== 'instruction') return true;
  if(INSTRUCTION_NEED_TARGET.has(card.name)) return false;
  return true;
}
function canUseOnOtherPlayer(card){
  if(card.kind !== 'instruction') return false;
  return true;
}
function canStartUseCard(cardObj){
  if(!isMyTurn()) return false;
  if(getRoundPick()?.phase === 'choose') return false;
  if(isActionSelectionActive()) return false;
  const turnBlocked = isInstructionTurnBlocked();
  const receivedIds = new Set(getMyReceivedCards().map(card => card.id));
  if(receivedIds.has(cardObj.id)){
    const activeIds = new Set(getActiveInstructionCards().map(card => card.id));
    if(cardObj.name === '賄賂') return false;
    return activeIds.has(cardObj.id);
  }
  if(!turnBlocked) return true;

  const isIgnore = (cardObj.kind === 'instruction' && cardObj.name === '無視');
  return isIgnore;
}

let hoverOtherCircle = null;
function clearOtherCircleHint(){
  if(!hoverOtherCircle) return;
  hoverOtherCircle.classList.remove('hint-ok','hint-ng');
  hoverOtherCircle = null;
}
function updateOtherCircleHint(x,y,cardObj){
  clearOtherCircleHint();
  const el = document.elementFromPoint(x,y);
  const c = el?.closest?.('.otherplayerscircle');
  if(!c) return;

  const ok = canUseOnOtherPlayer(cardObj);
  c.classList.add(ok ? 'hint-ok' : 'hint-ng');
  hoverOtherCircle = c;
}

function getDropTarget(x,y){
  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (x>=pr.left && x<=pr.right && y>=pr.top && y<=pr.bottom);
  if(inPlay) return { type:'playCircle' };

  const el = document.elementFromPoint(x,y);
  const circle = el?.closest?.('.otherplayerscircle');
  if(circle){
    const tag = circle.querySelector('.player-tag');
    if(tag){
      const seat = Number(tag.dataset.seat);
      const uid = tag.dataset.uid;
      return { type:'otherCircle', seat, uid };
    }
  }

  const tag = el?.closest?.('.player-tag');
  if(tag){
    const seat = Number(tag.dataset.seat);
    const uid = tag.dataset.uid;
    return { type:'playerTag', seat, uid };
  }

  return { type:'none' };
}

function startDragCard(e, cardObj, cardEl){
  if(!canStartUseCard(cardObj)) return;
  e.preventDefault();

  drag.active = true;
  drag.card = cardObj;
  drag.el = cardEl;
  drag.originRect = cardEl.getBoundingClientRect();

  const r = drag.originRect;
  drag.offsetX = e.clientX - r.left;
  drag.offsetY = e.clientY - r.top;
  drag.lastClientX = e.clientX;
  drag.lastClientY = e.clientY;

  cardEl.classList.add('dragging');
  cardEl.style.left = `${r.left}px`;
  cardEl.style.top  = `${r.top}px`;

  cardEl.setPointerCapture(e.pointerId);

  playCircleEl.classList.toggle('hint-ok', canUseOnPlayCircle(cardObj));
  playCircleEl.classList.toggle('hint-ng', !canUseOnPlayCircle(cardObj));

  cardEl.addEventListener('pointermove', onDragMove);
  cardEl.addEventListener('pointerup', onDragEnd);
  cardEl.addEventListener('pointercancel', onDragEnd);
}

function onDragMove(e){
  if(!drag.active) return;
  const x = e.clientX - drag.offsetX;
  const y = e.clientY - drag.offsetY;
  drag.lastClientX = e.clientX;
  drag.lastClientY = e.clientY;
  drag.el.style.left = `${x}px`;
  drag.el.style.top  = `${y}px`;

  updateOtherCircleHint(e.clientX, e.clientY, drag.card);
}

async function onDragEnd(e){
  if(!drag.active) return;

  const cardObj = drag.card;
  const drop = getDropTarget(e.clientX, e.clientY);
  const receivedIds = new Set(getMyReceivedCards().map(card => card.id));
  const isReceived = receivedIds.has(cardObj?.id);

  playCircleEl.classList.remove('hint-ok','hint-ng');
  clearOtherCircleHint();

  if(isReceived && drop.type !== 'playCircle'){
    snapBack();
    return;
  }

  if(drop.type === 'playCircle'){
    const ok = canUseOnPlayCircle(cardObj);
    if(!ok){ snapBack(); return; }

    await playCardToCircle(cardObj);
    cleanupDrag();
    return;
  }

  if(drop.type === 'otherCircle'){
    if(cardObj.kind !== 'instruction'){ snapBack(); return; }
    await giveInstructionToPlayer(cardObj, drop.seat, drop.uid);
    cleanupDrag();
    return;
  }

  if(drop.type === 'playerTag'){
    const isSelf = (drop.uid === state.userId);
    if(cardObj.kind !== 'instruction'){ snapBack(); return; }
    if(isSelf && !INSTRUCTION_CAN_SELF.has(cardObj.name)){ snapBack(); return; }
    if(isSelf){
      await playCardToCircle(cardObj);
      cleanupDrag();
      return;
    }
    snapBack();
    return;
  }

  snapBack();
}

function snapBack(){
  const el = drag.el;
  el.animate([
    { transform:'translate(0,0) scale(1.02)' },
    { transform:'translate(0,0) scale(1.0)' }
  ], { duration: 120, easing:'ease-out' });

  el.style.left = '';
  el.style.top  = '';
  el.classList.remove('dragging');

  cleanupDrag();
}

function cleanupDrag(){
  if(!drag.el) return;
  drag.el.removeEventListener('pointermove', onDragMove);
  drag.el.removeEventListener('pointerup', onDragEnd);
  drag.el.removeEventListener('pointercancel', onDragEnd);

  drag.active = false;
  drag.card = null;
  drag.el = null;
  drag.originRect = null;
  drag.lastClientX = null;
  drag.lastClientY = null;
}

/* =========================
   ★ ブロック解除（無視使用時）
   ========================= */
async function consumeReceivedInstruction(){
  if(!state.roomCode) return;
  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const rec = Array.isArray(myData.received) ? myData.received : [];
  if(!rec.length) return;

  await update(myRef, { received: [] });
  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, ...rec]);
}

async function discardReceivedInstructionsForTurn(){
  if(!state.roomCode) return;
  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const rec = Array.isArray(myData.received) ? myData.received : [];
  if(!rec.length) return;

  await update(myRef, { received: [] });
  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, ...rec]);
}

/* =========================
   カード使用：プレイサークル
   ========================= */
async function playCardToCircle(cardObj){
  if(!state.roomCode) return;
  if(!isMyTurn()) return;

  const receivedExists = hasReceivedInstruction();
  const isIgnore = (cardObj.kind === 'instruction' && cardObj.name === '無視');

  const receivedIds = new Set(getMyReceivedCards().map(card => card.id));
  const isReceived = receivedIds.has(cardObj.id);

  if(isReceived){
    await discardReceivedInstructionsForTurn();

    await emitEvent({ type:'revealCard', card: cardObj });
    await runActionCardEffect(cardObj);

    await endTurn('playReceivedInstruction');
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, cardObj]);

  await emitEvent({ type:'revealCard', card: cardObj });

  if(receivedExists && isIgnore){
    await consumeReceivedInstruction();
    await endTurn('ignore_clear_received');
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  await runActionCardEffect(cardObj);
  await endTurn('playAction');
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

async function runActionCardEffect(cardObj){
  if(cardObj?.name === '盗聴'){
    await runWiretapEffect(cardObj);
    return;
  }
  if(cardObj?.name === '偵察'){
    await runScoutEffect();
    return;
  }
  if(cardObj?.name === '世代交代'){
    await runGenerationShiftEffect();
    return;
  }
  if(cardObj?.name === '仕込み'){
    await runPreparationEffect(cardObj);
  }
}

async function runGenerationShiftEffect(){
  if(!state.roomCode) return;
  const mySeat = getSeatByUid(state.userId) ?? state.seatedTable ?? null;
  if(mySeat == null) return;
  const currentLeaderSeat = state.turn?.leaderSeat ?? null;
  if(currentLeaderSeat === mySeat) return;
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await update(turnRef, { leaderSeat: mySeat });
}

async function runScoutEffect(){
  if(!state.room?.gameStarted) return;
  const targetUid = await beginScoutSelection();
  if(!targetUid) return;

  const fromSeat = state.turn?.activeSeat ?? state.seatedTable;
  const toSeat = getSeatByUid(targetUid);
  if(fromSeat !== null && toSeat !== null){
    await emitEvent({
      type:'wiretapArrow',
      fromSeat,
      toSeat,
      fromUid: state.userId,
    });
  }

  await showScoutReveal(targetUid);
}

async function runPreparationEffect(cardObj){
  if(!state.roomCode) return;
  if(!cardObj) return;

  const base = `rooms/${state.roomCode}`;
  const [deckSnap, mySnap] = await Promise.all([
    get(ref(db, `${base}/decks/action`)),
    get(ref(db, `${base}/hands/${state.userId}`)),
  ]);
  const deck = deckSnap.val() || [];
  if(!Array.isArray(deck) || !deck.length) return;

  const myData = mySnap.val() || {};
  const action = Array.isArray(myData.action) ? myData.action : [];

  const nextCard = deck.shift();
  if(!nextCard) return;
  action.push(nextCard);

  await Promise.all([
    set(ref(db, `${base}/decks/action`), deck),
    update(ref(db, `${base}/hands/${state.userId}`), { action }),
  ]);

  const seat = getSeatByUid(state.userId) ?? state.seatedTable ?? null;
  await emitEvent({
    type: 'actionDrawToHand',
    toUid: state.userId,
    toSeat: seat,
  });
}


async function runWiretapEffect(cardObj){
  if(!state.room?.gameStarted) return;
  const targetUid = await beginWiretapSelection();
  if(!targetUid) return;

  revealedRoleUids.add(targetUid);
  pendingWiretapZoomUid = targetUid;
  if(latestPlayers.length) renderPlayerCircle(latestPlayers);

  const fromSeat = state.turn?.activeSeat ?? state.seatedTable;
  const toSeat = getSeatByUid(targetUid);
  if(fromSeat !== null && toSeat !== null){
    await emitEvent({
      type:'wiretapArrow',
      fromSeat,
      toSeat,
      fromUid: state.userId,
    });
  }
}

async function showScoutReveal(targetUid){
  if(!scoutRevealOverlay || !scoutRevealGrid) return;
  scoutRevealGrid.innerHTML = '';
  const showScoutCloseConfirm = () => {
    if(scoutCloseConfirmPop) scoutCloseConfirmPop.classList.remove('hidden');
  };
  const cards = Array.isArray(state.hands?.[targetUid]?.action)
    ? state.hands[targetUid].action
    : [];
  if(cards.length){
    cards.forEach(cardObj => {
      const cardEl = buildCardEl(cardObj);
      cardEl.addEventListener('click', showScoutCloseConfirm);
      scoutRevealGrid.appendChild(cardEl);
    });
  }else{
    const empty = document.createElement('div');
    empty.textContent = '（アクションカードなし）';
    scoutRevealGrid.appendChild(empty);
  }

  if(scoutCloseConfirmPop) scoutCloseConfirmPop.classList.add('hidden');
  scoutRevealOverlay.classList.remove('hidden');

  return new Promise(resolve => {
    const closeOverlay = () => {
      scoutRevealOverlay.classList.add('hidden');
      if(scoutCloseConfirmPop) scoutCloseConfirmPop.classList.add('hidden');
      scoutRevealOverlay.removeEventListener('click', onOverlayClick);
      scoutCloseYes?.removeEventListener('click', onCloseYes);
      scoutCloseNo?.removeEventListener('click', onCloseNo);
      resolve();
    };
    const onOverlayClick = (e) => {
      if(e.target !== scoutRevealOverlay) return;
      showScoutCloseConfirm();
    };
    const onCloseYes = () => closeOverlay();
    const onCloseNo = () => {
      if(scoutCloseConfirmPop) scoutCloseConfirmPop.classList.add('hidden');
    };

    scoutRevealOverlay.addEventListener('click', onOverlayClick);
    scoutCloseYes?.addEventListener('click', onCloseYes);
    scoutCloseNo?.addEventListener('click', onCloseNo);
  });
}

/* =========================
   指示カード：他プレイヤーへ渡す
   ========================= */
async function giveInstructionToPlayer(cardObj, targetSeat, targetUid){
  if(!state.roomCode) return;
  if(!isMyTurn()) return;

  if(!canUseOnOtherPlayer(cardObj)){
    return;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const toRef = ref(db, `rooms/${state.roomCode}/hands/${targetUid}`);
  const toSnap = await get(toRef);
  const toData = toSnap.val() || {};
  const received = Array.isArray(toData.received) ? toData.received : [];
  const fromSeat = state.turn?.activeSeat ?? state.seatedTable;
  const receivedCard = { ...cardObj, fromUid: state.userId, fromSeat };
  const nextReceived = [...received, receivedCard];
  await update(toRef, { received: nextReceived });

  await emitEvent({ type:'flyBackCard', fromSeat, toSeat: targetSeat });

  await runInstructionCardEffect(cardObj, targetUid);

  await endTurn('giveInstruction_received');
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}
async function runInstructionCardEffect(cardObj, targetUid){
  return;
}

/* =========================
   ★ スイーツ：山札クリック → 一覧表示
   ========================= */
let sweetsPanelLocked = false;

function canOpenSweetsPicker(){
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(isActionSelectionActive()) return false;
  if(hasSweets()) return false;
  const instructionNames = getActiveInstructionNames();
  if(instructionNames.size > 0 && !instructionNames.has('応援') && !instructionNames.has('脅迫')) return false;
  const deck = state.room?.decks?.sweets;
  if(!Array.isArray(deck) || !deck.length) return false;
  return true;
}

function getSweetsInstructionRestriction(){
  const instructionNames = getActiveInstructionNames();
  const needsMax = instructionNames.has('応援');
  const needsMin = instructionNames.has('脅迫');
  if(!needsMax && !needsMin) return null;
  return { needsMax, needsMin };
}

function getRestrictedSweetsIds(deck){
  const restriction = getSweetsInstructionRestriction();
  if(!restriction) return null;
  const values = deck.map(card => (typeof card.value === 'number' ? card.value : 0));
  const maxValue = Math.max(...values);
  const minValue = Math.min(...values);
  const allowed = new Set();
  deck.forEach(card => {
    if(restriction.needsMax && card.value === maxValue) allowed.add(card.id);
    if(restriction.needsMin && card.value === minValue) allowed.add(card.id);
  });
  return allowed;
}

function openSweetsPicker(){
  const deck = state.room?.decks?.sweets;
  if(!Array.isArray(deck) || !deck.length) return;

  sweetsPanelLocked = true;
  btnSweetsClose.disabled = true;

  const sorted = [...deck].sort((a,b)=> (a.value ?? 0) - (b.value ?? 0));
  const allowedIds = getRestrictedSweetsIds(sorted);
  const cols = Math.ceil(sorted.length / 2);
  sweetsGrid.style.gridTemplateColumns = `repeat(${cols}, 90px)`;

  sweetsGrid.innerHTML = '';
  sorted.forEach(cardObj => {
    const el = document.createElement('div');
    el.className = 'sweets-pick-card';
    el.dataset.cardId = cardObj.id;
    if(allowedIds && !allowedIds.has(cardObj.id)){
      el.classList.add('restricted');
    }

    const img = document.createElement('img');
    img.src = cardObj.img;
    img.alt = `sweets ${cardObj.value ?? ''}`;
    img.onerror = () => { if(cardObj.fallback) img.src = cardObj.fallback; };

    el.appendChild(img);
    if(!el.classList.contains('restricted')){
      el.addEventListener('pointerdown', (e) => startDragSweets(e, cardObj, el));
    }
    sweetsGrid.appendChild(el);
  });

  sweetsBackdrop.classList.remove('hidden');
}

function closeSweetsPicker(){
  if(sweetsPanelLocked) return;
  sweetsBackdrop.classList.add('hidden');
}
btnSweetsClose.addEventListener('click', closeSweetsPicker);
sweetsBackdrop.addEventListener('click', (e) => {
  if(e.target === sweetsBackdrop) closeSweetsPicker();
});

sweetsDeckUI.addEventListener('click', () => {
  if(!canOpenSweetsPicker()) return;
  openSweetsPicker();
});

/* =========================
   ★ スイーツ：ドラッグ → dropZone で獲得
   ========================= */
const sweetsDrag = {
  active:false,
  card:null,
  srcEl:null,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
};

function startDragSweets(e, cardObj, srcEl){
  if(!canOpenSweetsPicker()) return;
  if(srcEl.classList.contains('restricted')) return;
  e.preventDefault();

  sweetsDrag.active = true;
  sweetsDrag.card = cardObj;
  sweetsDrag.srcEl = srcEl;
  const r = srcEl.getBoundingClientRect();
  sweetsDrag.offsetX = e.clientX - r.left;
  sweetsDrag.offsetY = e.clientY - r.top;
  sweetsDrag.lastClientX = e.clientX;
  sweetsDrag.lastClientY = e.clientY;

  const ghost = srcEl.cloneNode(true);
  ghost.classList.add('sweets-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  sweetsDrag.ghost = ghost;
  sweetsDrag.srcEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onSweetsDragMove);
  ghost.addEventListener('pointerup', onSweetsDragEnd);
  ghost.addEventListener('pointercancel', onSweetsDragEnd);
}

function onSweetsDragMove(e){
  if(!sweetsDrag.active || !sweetsDrag.ghost) return;
  const x = e.clientX - sweetsDrag.offsetX;
  const y = e.clientY - sweetsDrag.offsetY;
  sweetsDrag.lastClientX = e.clientX;
  sweetsDrag.lastClientY = e.clientY;
  sweetsDrag.ghost.style.left = `${x}px`;
  sweetsDrag.ghost.style.top  = `${y}px`;

  if(sweetsDropZone){
    const zoneR = sweetsDropZone.getBoundingClientRect();
    const inZone = (e.clientX >= zoneR.left && e.clientX <= zoneR.right && e.clientY >= zoneR.top && e.clientY <= zoneR.bottom);
    sweetsDropZone.classList.toggle('active', inZone);
  }
}

async function onSweetsDragEnd(e){
  if(!sweetsDrag.active) return;

  const gx = e.clientX;
  const gy = e.clientY;

  const zoneR = sweetsDropZone?.getBoundingClientRect();
  const inDropZone = zoneR
    ? (gx >= zoneR.left && gx <= zoneR.right && gy >= zoneR.top && gy <= zoneR.bottom)
    : false;

  if(inDropZone){
    await acquireSweetsCard(sweetsDrag.card);
    cleanupSweetsDrag();
    return;
  }

  cleanupSweetsDrag();
}

function cleanupSweetsDrag(){
  if(sweetsDrag.ghost){
    sweetsDrag.ghost.removeEventListener('pointermove', onSweetsDragMove);
    sweetsDrag.ghost.removeEventListener('pointerup', onSweetsDragEnd);
    sweetsDrag.ghost.removeEventListener('pointercancel', onSweetsDragEnd);
    sweetsDrag.ghost.remove();
  }
  if(sweetsDrag.srcEl){
    sweetsDrag.srcEl.style.visibility = '';
  }
  sweetsDropZone?.classList.remove('active');
  sweetsDrag.active = false;
  sweetsDrag.card = null;
  sweetsDrag.srcEl = null;
  sweetsDrag.ghost = null;
  sweetsDrag.offsetX = 0;
  sweetsDrag.offsetY = 0;
  sweetsDrag.lastClientX = null;
  sweetsDrag.lastClientY = null;
}

async function acquireSweetsCard(cardObj){
  if(!state.roomCode) return;
  if(!canOpenSweetsPicker()) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const already = Array.isArray(myData.sweets) && myData.sweets.length;
  if(already) return;

  const deckRef = ref(db, `rooms/${state.roomCode}/decks/sweets`);
  const deckSnap = await get(deckRef);
  const deck = deckSnap.val() || [];
  const exists = Array.isArray(deck) && deck.some(c => c.id === cardObj.id);
  if(!exists) return;

  const nextDeck = deck.filter(c => c.id !== cardObj.id);

  await set(deckRef, nextDeck);
  await update(myRef, { sweets: [cardObj] });

  sweetsPanelLocked = false;
  btnSweetsClose.disabled = false;
  sweetsBackdrop.classList.add('hidden');

  await endTurn('drawSweets');

  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   ★ 投票：チップドラッグ → swarea へドロップ
   ========================= */
const voteDrag = {
  active:false,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
  sourceEl:null,
  showAllHints:false,
};
let hoverSwarea = null;

function isVoteTargetAllowed(uid){
  const bribeTargetUid = getActiveBribeTargetUid();
  if(bribeTargetUid && uid !== bribeTargetUid) return false;
  return true;
}

function setAllSweetsWrapHints(active){
  document.querySelectorAll('.sweets-wrap').forEach((wrap) => {
    wrap.classList.remove('hint-ok', 'hint-ng');
    if(!active) return;
    const circle = wrap.closest('.otherplayerscircle');
    const tag = circle?.querySelector('.player-tag');
    const uid = tag?.dataset?.uid || null;
    if(!uid || !isVoteTargetAllowed(uid)) return;
    const ok = !wrap.classList.contains('empty');
    wrap.classList.add(ok ? 'hint-ok' : 'hint-ng');
  });
}

function clearSwareaHint(){
  if(!hoverSwarea) return;
  hoverSwarea.classList.remove('hint-ok','hint-ng');
  hoverSwarea = null;
}
function updateSwareaHint(x,y){
  if(voteDrag.showAllHints) return;
  clearSwareaHint();
  const drop = getVoteDropTarget(x,y);
  if(drop.type !== 'swwrap') return;
  if(!isVoteTargetAllowed(drop.uid)) return;
  const el = document.elementFromPoint(x,y);
  const area = el?.closest?.('.sweets-wrap');
  if(!area) return;
  const ok = drop.ok;
  area.classList.add(ok ? 'hint-ok' : 'hint-ng');
  hoverSwarea = area;
}
function getVoteDropTarget(x,y){
  const el = document.elementFromPoint(x,y);
  const wrap = el?.closest?.('.sweets-wrap');   // ★変更
  if(!wrap) return { type:'none' };

  // ★ tagは祖先じゃないので、otherplayerscircle から uid を取る
  const circle = wrap.closest('.otherplayerscircle');
  const tag = circle?.querySelector('.player-tag');
  const uid = tag?.dataset?.uid || null;
  if(!uid) return { type:'none' };
  if(!isVoteTargetAllowed(uid)) return { type:'swwrap', uid, ok:false };

  const handData = state.hands?.[uid];
  const hasTheirSweets = !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);

  return { type:'swwrap', uid, ok: hasTheirSweets };
}

function startDragVoteChip(e){
  if(!canVoteNow()) return;
  e.preventDefault();

  const r = myVoteChipEl.getBoundingClientRect();
  voteDrag.active = true;
  voteDrag.sourceEl = myVoteChipEl;
  voteDrag.offsetX = e.clientX - r.left;
  voteDrag.offsetY = e.clientY - r.top;
  voteDrag.lastClientX = e.clientX;
  voteDrag.lastClientY = e.clientY;

  voteDrag.showAllHints = true;
  setAllSweetsWrapHints(true);

  const ghost = myVoteChipEl.cloneNode(true);
  ghost.classList.remove('hidden');
  ghost.classList.add('vote-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  voteDrag.ghost = ghost;
  voteDrag.sourceEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onVoteDragMove);
  ghost.addEventListener('pointerup', onVoteDragEnd);
  ghost.addEventListener('pointercancel', onVoteDragEnd);
}

function onVoteDragMove(e){
  if(!voteDrag.active || !voteDrag.ghost) return;
  const x = e.clientX - voteDrag.offsetX;
  const y = e.clientY - voteDrag.offsetY;
  voteDrag.lastClientX = e.clientX;
  voteDrag.lastClientY = e.clientY;
  voteDrag.ghost.style.left = `${x}px`;
  voteDrag.ghost.style.top  = `${y}px`;
  updateSwareaHint(e.clientX, e.clientY);
}

async function onVoteDragEnd(e){
  if(!voteDrag.active) return;

  const drop = getVoteDropTarget(e.clientX, e.clientY);
  clearSwareaHint();

  if(drop.type === 'swwrap' && drop.ok){   // ★変更
    await castVote(drop.uid);
  }

  cleanupVoteDrag();
}

function cleanupVoteDrag(){
  if(voteDrag.ghost){
    voteDrag.ghost.removeEventListener('pointermove', onVoteDragMove);
    voteDrag.ghost.removeEventListener('pointerup', onVoteDragEnd);
    voteDrag.ghost.removeEventListener('pointercancel', onVoteDragEnd);
    voteDrag.ghost.remove();
  }
if(voteDrag.sourceEl){
    voteDrag.sourceEl.style.visibility = '';
  }
  voteDrag.active = false;
  voteDrag.showAllHints = false;
  setAllSweetsWrapHints(false);
  clearSwareaHint();
  voteDrag.ghost = null;
  voteDrag.offsetX = 0;
  voteDrag.offsetY = 0;
  voteDrag.lastClientX = null;
  voteDrag.lastClientY = null;
  voteDrag.sourceEl = null;
}

function syncFloatingDragPositions(){
  if(drag.active && drag.el && drag.lastClientX !== null && drag.lastClientY !== null){
    const x = drag.lastClientX - drag.offsetX;
    const y = drag.lastClientY - drag.offsetY;
    drag.el.style.left = `${x}px`;
    drag.el.style.top  = `${y}px`;
    updateOtherCircleHint(drag.lastClientX, drag.lastClientY, drag.card);
  }

  if(sweetsDrag.active && sweetsDrag.ghost && sweetsDrag.lastClientX !== null && sweetsDrag.lastClientY !== null){
    const x = sweetsDrag.lastClientX - sweetsDrag.offsetX;
    const y = sweetsDrag.lastClientY - sweetsDrag.offsetY;
    sweetsDrag.ghost.style.left = `${x}px`;
    sweetsDrag.ghost.style.top  = `${y}px`;
  }

  if(voteDrag.active && voteDrag.ghost && voteDrag.lastClientX !== null && voteDrag.lastClientY !== null){
    const x = voteDrag.lastClientX - voteDrag.offsetX;
    const y = voteDrag.lastClientY - voteDrag.offsetY;
    voteDrag.ghost.style.left = `${x}px`;
    voteDrag.ghost.style.top  = `${y}px`;
    updateSwareaHint(voteDrag.lastClientX, voteDrag.lastClientY);
  }
}

mainEl.addEventListener('scroll', syncFloatingDragPositions, { passive: true });
window.addEventListener('resize', syncFloatingDragPositions);

async function castVote(targetUid){
  if(!state.roomCode) return;
  if(!canVoteNow()) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const chips = (typeof myData.voteChips === 'number') ? myData.voteChips : 1;
  if(chips <= 0) return;

  // 1) 自分のチップ消費（手元から消える）
  await update(myRef, { voteChips: chips - 1 });

  // 2) 投票記録（ターゲットの右側に表示される）
  await set(ref(db, `rooms/${state.roomCode}/votes/${targetUid}/${state.userId}`), true);

  // 3) これは1投票（手番終了）
  await endTurn('vote');

  renderMyVoteChip();
  updatePassRoundBtn();
}

/* ★ 投票チップ：pointerdown */
myVoteChipEl.addEventListener('pointerdown', startDragVoteChip);

/* =========================
   Seat UI（既存）
   ========================= */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
          const tables = tablesSnap.val() || {};
          const tagChipStyle = pickRandomTagChipStyle(tables);
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName, tagChipStyle });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
        const tables = tablesSnap.val() || {};
        const tagChipStyle = pickRandomTagChipStyle(tables);
        await set(tRef, { playerId: state.userId, playerName: state.userName, tagChipStyle });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* =========================
   追い出しダイアログ（既存）
   ========================= */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const tagChipStyle = pickRandomTagChipStyle(tables);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し', tagChipStyle });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   ホストUI（既存）
   ========================= */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  resetLocalGameEffects();
  await hostGameStart();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/roles`)),
    remove(ref(db, `${base}/game`)),
    remove(ref(db, `${base}/decks`)),
    remove(ref(db, `${base}/discard`)),
    remove(ref(db, `${base}/events`)),
    remove(ref(db, `${base}/votes`)),
    remove(ref(db, `${base}/gameStarted`)),
  ]);

  resetLocalGameEffects();
  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
});

/* =========================
   Join（既存）
   ========================= */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeRoles();
  subscribeGame();
  subscribeEvents();

  syncSeatUI();

  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});


</script>

</body>
</html>
