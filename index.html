<!DOCTYPE html>    
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ã‚¹ã‚¤ãƒ¼ãƒ„ãƒ¯ãƒ³ãƒ€ãƒ¼ãƒªãƒ¼ã‚°</title>
<style>
  :root{
    --leaderChipSize: 21.6px;
    --leaderChipOffset: 22px;
  }
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:400; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .btn:disabled{opacity:.45; cursor:not-allowed;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  /* â˜… mainèƒŒæ™¯ï¼šå…¥å®¤å‰/å…¥å®¤å¾Œã§åˆ‡æ›¿ */
  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('swtop.jpg'); }
  main.joined{ background-image:url('swmain.jpg'); }

  /* â˜… ç€å¸­ãƒãƒƒãƒ— */
  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'âœ•';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  /* â˜… ãƒ›ã‚¹ãƒˆäººæ•°é¸æŠä¸­ï¼šå‚åŠ è€…ã«å‡ºã™é»’ãƒãƒƒãƒ—ï¼ˆä¸‹å›ºå®šï¼‰ */
  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:225;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

/* â˜… ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å††é…ç½®ç”¨ï¼ˆæ‹¡å¤§ï¼šç›´å¾„ã ã„ãŸã„400å‰å¾Œï¼‰ */
.player-circle{
  position:relative;
  width:min(300px, 92vw);
  height:min(400px, 92vw);
  margin:20px auto 0;
  border-radius:50%;
  box-sizing:border-box;
  border:none;
}



  /* â˜… ä¸­å¤®ï¼šãƒ—ãƒ¬ã‚¤ã‚µãƒ¼ã‚¯ãƒ«ï¼ˆâ€»ã‚¹ã‚¤ãƒ¼ãƒ„å±±æœ­ã‚¯ãƒªãƒƒã‚¯ã®ãŸã‚ pointer-events ã‚’æœ‰åŠ¹ã«ï¼‰ */
  .play-circle{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    width:120px;height:120px;border-radius:50%;
    background:transparent;
    pointer-events:auto;
border:transparent;
  }
  .required-sweets-tag{
    position:absolute;
    left:50%;
    top:calc(50% + 25px);
    transform:translate(-50%,-50%);
    font-size:12px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,247,224,.92);
    border:2px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
    pointer-events:none;
    z-index:7;
  }
  .play-circle::after{
    content:'PLAY';
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
    font-weight:900;font-size:12px;letter-spacing:.08em;opacity:.65;
    pointer-events:none;
display:none;

  }
.play-circle.hint-ok {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* è–„ã„é€æ˜ã‚°ãƒ¬ãƒ¼ */
}

.play-circle.hint-ng {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* è–„ã„é€æ˜ã‚°ãƒ¬ãƒ¼ */
}

.play-circle.roundpick-target {
  border-style: none;
  background: rgba(200, 200, 200, 0.3); /* è–„ã„é€æ˜ã‚°ãƒ¬ãƒ¼ */
}


  /* =========================
     â˜…â˜… ä¸­å¤®ï¼šã‚¢ã‚¯ã‚·ãƒ§ãƒ³å±±æœ­ï¼ˆå·¦ï¼‰ï¼‹ã‚¹ã‚¤ãƒ¼ãƒ„å±±æœ­ï¼ˆå³ï¼‰
     ========================= */
  .center-decks{
    position:absolute;
    left:50%; top:50%;
  transform:translate(-50%,-50%) translateY(60px); /* â† ã“ã“ã‚’å¢—ã‚„ã™ã»ã©ä¸‹ãŒã‚‹ */
    display:flex;
    gap:14px;
    align-items:center;
    justify-content:center;
    pointer-events:auto;
  }
  .center-decks.hidden{display:none;}

  /* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å±±æœ­ï¼ˆè¦‹ãŸç›®å°‚ç”¨ï¼‰ */
  .action-deck{
    position:relative;
    width:28px; height:40px;
    pointer-events:none;
  }
  .action-deck.hidden{display:none;}
  .action-deck .stack{position:absolute; inset:0;}
  .action-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swactionura.jpg') center/cover no-repeat;
    box-shadow:none;
  }
  .action-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
  .action-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
  .action-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
  .action-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
  .action-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
  display:none;
  }

  /* ã‚¹ã‚¤ãƒ¼ãƒ„å±±æœ­ï¼ˆã‚¯ãƒªãƒƒã‚¯å¯èƒ½ï¼‰ */
 .sweets-deck{
    position:relative;
    width:28px; height:40px;
    pointer-events:auto;
    cursor:pointer;
    user-select:none;
    touch-action:none;
  }
  .sweets-deck-wrap{
    position:relative;
    width:28px;
    height:40px;
  }
  .sweets-deck-wrap .sweets-deck{
    position:absolute;
    inset:0;
  }
  .sweets-deck.hidden{display:none;}
  .sweets-deck .stack{position:absolute; inset:0;}
  .sweets-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:none;
  }
  .sweets-deck .card.c2{ transform:translate(1px,-1px); opacity:.95; }
  .sweets-deck .card.c3{ transform:translate(2px,-2px); opacity:.90; }
  .sweets-deck .card.c4{ transform:translate(3px,-3px); opacity:.86; }
  .sweets-deck .card.c5{ transform:translate(4px,-4px); opacity:.82; }
  .sweets-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
   line-height:1.1;
    pointer-events:none;
  }
  .sweets-exclude-deck{
    position:absolute;
    right:-43px;
    top:0px;
    width:28px;
    height:40px;
    pointer-events:none;
    user-select:none;
  }
  .sweets-exclude-deck.hidden{display:none;}
  .sweets-exclude-deck .stack{position:absolute; inset:0;}
  .sweets-exclude-deck .card{
    position:absolute;
    width:28px; height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:none;
    transform:rotate(90deg);
    transform-origin:center;
  }
  .sweets-exclude-deck .card.c2{ transform:translate(1px,-1px) rotate(90deg); opacity:.95; }
  .sweets-exclude-deck .card.c3{ transform:translate(2px,-2px) rotate(90deg); opacity:.90; }
  .sweets-exclude-deck .card.c4{ transform:translate(3px,-3px) rotate(90deg); opacity:.86; }
  .sweets-exclude-deck .card.c5{ transform:translate(4px,-4px) rotate(90deg); opacity:.82; }
  .sweets-exclude-deck .count{
    position:absolute;
    right:-8px; top:-8px;
    font-size:11px;
    font-weight:900;
    padding:2px 6px;
    border-radius:999px;
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.18);
    color:#111;
    line-height:1.1;
    pointer-events:none;
  }
/* é™¤å¤–æœ­å…¨ä½“ã‚’å°‘ã—è–„ã */
#sweetsExcludedDeckUI{
  opacity: .50;   /* å¥½ã¿ã§èª¿æ•´ */
}

/* âœ… é™¤å¤–ãƒ‡ãƒƒã‚­ï¼šå‡ºç¾ã‚’ã€Œå‚¾ãï¼‹ãƒ•ã‚§ãƒ¼ãƒ‰ã€ã§ */
.sweets-exclude-deck{
  /* ãµã‚ã£ã¨å‡ºã™ãŸã‚ã®åŸºæº–çŠ¶æ…‹ */
  opacity: 1;
  visibility: visible;
  transform: translateX(0px) rotate(0deg) scale(1);
  will-change: opacity, transform;
  transition:
    opacity .22s ease,
    transform .22s cubic-bezier(.22,.84,.44,1),
    visibility 0s linear 0s;
}

/* âœ… é‡è¦ï¼š.hidden ã‚’ display:none ã«ã•ã›ãšã€ã‚¢ãƒ‹ãƒ¡å¯èƒ½ãªéš ã—æ–¹ã«ä¸Šæ›¸ã */
.sweets-exclude-deck.hidden{
  display: block;                 /* â† ã“ã‚ŒãŒè‚ã€‚display:none ã‚’æ®ºã™ */
  opacity: 0;
  visibility: hidden;
  transform: translateX(10px) rotate(-25deg) scale(.85); /* â† â€œå‚¾ãâ€ã®æ­£ä½“ */
  transition:
    opacity .18s ease,
    transform .18s ease,
    visibility 0s linear .18s;    /* â† ãƒ•ã‚§ãƒ¼ãƒ‰å¾Œã«ä¸å¯è¦–ã¸ */
}


  /* â˜… è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã ã‘ã€Œå¤§å°ã‚¢ãƒ‹ãƒ¡ï¼ˆé¼“å‹•ï¼‰ã€ */
  @keyframes pulseCard {
    0%{transform:scale(1);}
    50%{transform:scale(1.06);}
    100%{transform:scale(1);}
  }
 @keyframes pulseCardStrong {
    0%{transform:scale(1);}
    50%{transform:scale(1.12);}
    100%{transform:scale(1);}
  }
  .sweets-move-card{
    position:fixed;
    left:0;
    top:0;
    width:28px;
    height:40px;
    border-radius:7px;
    border:1px solid rgba(0,0,0,.18);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.2);
    z-index:620;
    pointer-events:none;
    will-change:transform;
  }

  @keyframes sweetsDecidedMove {
    from{transform:translateY(0);}
    to{transform:translateY(-60px);}
  }
  @keyframes sweetsTagMove {
    from{transform:translate(-50%,0);}
    to{transform:translate(-50%, var(--sweetsTagMoveY));}
  }
  @keyframes sweetsDecidedMoveMy {
    from{transform:translateY(0);}
    to{transform:translateY(-30px);}
  }
/* âœ… ã‚¹ã‚¤ãƒ¼ãƒ„å±±æœ­å°‚ç”¨ï¼šé¼“å‹•ï¼ˆä¾‹ï¼šå¼·ã‚ï¼‰ */
@keyframes pulseSweetsDeck {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.4); } /* â† å¼·ã•ï¼ˆä¾‹ï¼š1.06ã€œ1.14ï¼‰ */
  100% { transform: scale(1); }
}
  .sweets-deck.pulsing{ animation:pulseSweetsDeck 1.05s ease-in-out infinite; }
  .sweets-deck.pulsing:hover{ animation:none; transform:scale(1.14); }

  /* â˜…â˜… ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šãƒãƒ¼ãƒ ã‚¿ã‚°ï¼‹ã‚«ãƒ¼ãƒ‰å‘¨ã‚Šã‚’å††ã§å›²ã‚€ï¼ˆotherplayerscircleï¼‰ */
 .otherplayerscircle{
    position:absolute;
    left:0; top:0;
    width:126px; height:126px;
    transform:translate(-50%,-50%);
    border-radius:50%;
    border:2px solid transparent;
    background:transparent;
    display:flex;align-items:center;justify-content:center;
    box-sizing:border-box;
  }
  .otherplayerscircle.hint-ok{ border-color:rgba(34,197,94,.75); }
  .otherplayerscircle.hint-ng{ border-color:rgba(239,68,68,.75); }

  /* â˜…â˜… æ‰‹ç•ªï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚µãƒ¼ã‚¯ãƒ«ã‚’é’ãè¡¨ç¤º */
  .otherplayerscircle.active-turn{
    border-color:rgba(59,130,246,.65);
    background:transparent;
  }
  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    display:flex;align-items:center;gap:6px;
  }
  .player-tag.me{
    background:#111;
    color:#fff;
    border-color:#111;
    transform:translate(-50%,-50%) translateY(45px);
  }
  /* â˜… æ‰‹ç•ªã®é’æ ï¼šãƒãƒ¼ãƒ ã‚¿ã‚°è¼ªéƒ­ã®å¤–å´ */
  .player-tag.active-turn{
    outline:none;
  }

  /* otherplayerscircle å†…ã®ã‚¿ã‚°ã¯ã€Œä¸­å¤®é…ç½®ã€æ‰±ã„ */
  .player-tag.in-othercircle{
    position:relative;
    transform:none;
    left:auto; top:auto;
  }

/* â˜… ãƒªãƒ¼ãƒ€ãƒ¼ãƒãƒƒãƒ—ï¼ˆ1.2å€ï¼‰ */
.leader-chip{
  position:absolute;
  right:calc(-1 * var(--leaderChipOffset));
  top:50%;
  width:var(--leaderChipSize);
  height:var(--leaderChipSize);
  transform:translateY(-50%);
  background:url('swleader.png') center/contain no-repeat;
  filter:drop-shadow(0 2px 6px rgba(0,0,0,.35));
  pointer-events:none;
}
.leader-chip-fly{
  position:fixed;
  z-index:720;
  pointer-events:none;
}
.leader-chip-hidden{
  opacity:0;
}

@keyframes leaderPickPulse{
  0%{ scale:1; }
  50%{ scale:1.12; }
  100%{ scale:1; }
}
.leader-pick-candidate{
  animation:leaderPickPulse 1.1s ease-in-out infinite;
  transform-origin:center;
}
.leader-pick-selectable{
  cursor:pointer;
}

.leader-pick-pop{
  position:fixed;
  left:50%;
  bottom:10px;
  transform:translateX(-50%);
  background:#fde047;
  color:#92400e;
  font-weight:900;
  padding:10px 16px;
  border-radius:14px;
  border:2px solid #f59e0b;
  box-shadow:0 14px 30px rgba(0,0,0,.25);
  z-index:230;
  white-space:nowrap;
}
.leader-pick-pop.hidden{display:none;}


  /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šæ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼ˆè£ï¼‰ */
/* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šæ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼ˆè£ï¼‰ */
.role-mini{
  position:absolute;
  left:-34px; top:50%;
  transform:translateY(-50%);
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swroleura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  pointer-events:none;
}

.action-deal-card{
  position:fixed;
  left:0;
  top:0;
  background:url('swactionura.jpg') center/cover no-repeat;
  border:1px solid rgba(0,0,0,.18);
  border-radius:7px;
  box-shadow:0 10px 24px rgba(0,0,0,.18);
  pointer-events:none;
  z-index:720;
  will-change:transform;
}
  /* â˜…â˜… ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šãƒŸãƒ‹ã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆè£ï¼‰ï¼‹å‘¨ã‚Šã‚’å††ã§å›²ã‚€ï¼swarea */
/* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šã‚¹ã‚¤ãƒ¼ãƒ„æ ï¼ˆå±±æœ­ã¨åŒã‚µã‚¤ã‚ºï¼‰ */
.sweets-area{
  position:absolute;
  left:-66px; top:50%;
  transform:translateY(-50%);
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:2px solid rgba(0,0,0,.22);
  background:rgba(255,255,255,.10);
  display:flex;
  align-items:center;
  justify-content:center;
  box-sizing:border-box;
  pointer-events:auto;

}
.sweets-area.empty{
  border-style:dashed;
  opacity:.35;
}
.sweets-area.hint-ok{ border-color:rgba(34,197,94,.75); }
.sweets-area.hint-ng{ border-color:rgba(239,68,68,.75); }

.sweets-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swsweetsura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}
.sweets-mini.hidden{display:none;}

/* æŠ•ç¥¨ãƒãƒƒãƒ—ï¼ˆä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚¤ãƒ¼ãƒ„å³å´ã«é‡ã­ã‚‹ï¼‰ */
.vote-stack{
  position:absolute;
  right:-22px;
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-wrap:wrap;

  width:calc(var(--voteMiniSize) * 2 + 6px); /* 2åˆ— */
  gap:3px;
  justify-content:flex-start;
  align-items:center;
  pointer-events:none;
}

.vote-mini{
  width:var(--voteMiniSize);
  height:var(--voteMiniSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 6px 14px rgba(0,0,0,.18);
}


  /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒŸãƒ‹ã‚«ãƒ¼ãƒ‰ï¼ˆãƒãƒ¼ãƒ ã‚¿ã‚°ã®ä¸‹ã«æ‰‡çŠ¶ï¼‰ */
.player-tag .mini-hand{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    width:60px;height:30px;pointer-events:none;
  }
  .player-tag .other-role-mini{
    position:absolute;
    left:50%;
    top:100%;
    transform:translate(calc(-50% - 40px), -3px);
    box-sizing:border-box;
    pointer-events:none;
  }
  .player-tag.right-side .other-role-mini{
    transform:translate(calc(-50% + 40px), -3px);
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:url('swactionura.jpg') center/cover no-repeat;
  transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }
  .role-mini .other-vote-chip{
    position:absolute;
    right:-6px;
    bottom:-6px;
    width:var(--voteMiniSize);
    height:var(--voteMiniSize);
    border-radius:50%;
    border:2px solid var(--voteChipStroke);
    background:var(--voteChipFill);
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    pointer-events:none;
  }
  .vote-chip-fly{
    position:fixed;
    left:0;
    top:0;
    width:var(--voteMiniSize);
    height:var(--voteMiniSize);
    border-radius:50%;
    border:2px solid var(--voteChipStroke);
    background:var(--voteChipFill);
    box-shadow:0 12px 28px rgba(0,0,0,.25);
    pointer-events:none;
    z-index:999;
    will-change:transform;
  }
  .vote-stack.animating{
    opacity:0;
  }
  /* è‡ªåˆ†ã®æ‰‹æœ­è¡¨ç¤ºï¼ˆå¤§ãã‚æ¨ªä¸¦ã³ï¼‰ */
  .my-hand-wrapper{margin-top:40px;text-align:center; position:relative;}
  .my-hand-title{display:none;}
  .my-area{
    display:flex;gap:10px;justify-content:center;align-items:flex-start;
    margin-top:-6px;
  }

  /* â˜… è‡ªåˆ†ã®æ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼ˆè‡ªåˆ†ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã®å·¦å´ï¼‰ */
  .my-role{
    width:78px;height:118px;border-radius:12px;border:1px solid #ddd;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    background:#fff;
    overflow:hidden;
    flex:0 0 auto;
  }
  .my-role img{width:100%;height:100%;object-fit:cover;display:block;}

  /* â˜…â˜… è‡ªåˆ†ã®ã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆæ­£ä½“ã‚«ãƒ¼ãƒ‰ã®å·¦ï¼åŒã‚µã‚¤ã‚ºï¼‰ */
  .my-sweets{
    width:78px;height:118px;border-radius:12px;border:1px solid #ddd;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    background:#fff;
    overflow:visible;
    flex:0 0 auto;
  }
  .my-sweets.collect-hidden{
    opacity:0;
    visibility:hidden;
  }
  .my-sweets.hidden{display:none;}  .my-sweets img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
    border-radius:inherit;
  }
  /* =========================
     â˜… å—ã‘å–ã£ãŸæŒ‡ç¤ºã‚«ãƒ¼ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆï¼ˆæ­£ä½“ã‚«ãƒ¼ãƒ‰ã®å·¦ï¼‰
     ========================= */
  .my-received-slot{
    flex:0 0 auto;
    display:flex;align-items:flex-start;justify-content:center;
  }

  .my-hand{
    display:flex;justify-content:center;gap:10px;flex-wrap:wrap;
    min-height:130px;
  }

  /* â˜… ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ï¼ˆè‡ªåˆ†ã®æ‰‹æœ­ï¼‰ */
  .action-card{
    position:relative;
    width:90px;height:135px;border-radius:12px;border:1px solid #ddd;background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    overflow:hidden;
    user-select:none;
    touch-action:none;
    cursor:grab;
    transform-origin:center;
  }
  .action-card:active{cursor:grabbing;}
  .action-card img.card-img{
    position:absolute;inset:0;width:100%;height:100%;object-fit:cover;
    display:block;
  }
  .action-card .card-name{
    position:absolute;left:8px;top:6px;
    font-weight:900;font-size:14px;
    color:#1d4ed8;
    text-shadow:0 2px 6px rgba(255,255,255,.7);
    pointer-events:none;
    display:none;
  }

  .action-card .effect-frame{
    position:absolute;
    left:0;
    right:0;
    top:70%;
    bottom:0px;
    background:rgb(195,179,237);
    border-top:1px solid rgba(0,0,0,.15);
border-radius:0px;
    padding:2px 2px 2px;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    box-sizing:border-box;
    pointer-events:none;
  }
  .action-card .effect-text{
    width:100%;
    font-weight:800;
    line-height:1.2;
    color:#111;
    font-size:13px;
    word-break:break-word;
    hyphens:auto;
    overflow:hidden;
  }
  .my-turn-free .action-card{ animation:pulseCard 1.05s ease-in-out infinite; }
  .my-turn-free .action-card:hover{ animation:none; transform:scale(1.08); }

  /* â˜… å—ã‘å–ã‚ŠæŒ‡ç¤ºã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹é–“ï¼šé€šå¸¸æ‰‹æœ­ã¯ç„¡åŠ¹ï¼†ã‚¢ãƒ‹ãƒ¡åœæ­¢ */
  .my-turn-blocked .my-hand .action-card{
    animation:none !important;
    cursor:not-allowed;
    filter:grayscale(.25);
    opacity:.72;
  }

  /* â˜… æŒ‡ç¤ºã‚«ãƒ¼ãƒ‰ã‚¹ãƒ­ãƒƒãƒˆå†…ã®ã‚«ãƒ¼ãƒ‰ã ã‘é¼“å‹•ã•ã›ã‚‹ */
  .my-turn-blocked .my-received-slot .action-card.pulse-only{
    animation:pulseCard 1.05s ease-in-out infinite;
    cursor:grab;
    filter:none;
    opacity:1;
  }
  .my-turn-blocked .my-received-slot .action-card.pulse-only:hover{
    animation:none;
    transform:scale(1.08);
  }

  /* â˜… ç„¡è¦–ã‚«ãƒ¼ãƒ‰ï¼šãƒ–ãƒ­ãƒƒã‚¯ä¸­ã§ã‚‚é¼“å‹•ï¼†ä½¿ç”¨å¯ï¼ˆæ‰‹æœ­å†…ï¼‰ */
  .my-turn-blocked .my-hand .action-card.can-ignore{
    animation:pulseCard 1.05s ease-in-out infinite !important;
    cursor:grab !important;
    filter:none !important;
    opacity:1 !important;
  }
  .my-turn-blocked .my-hand .action-card.can-ignore:hover{
    animation:none !important;
    transform:scale(1.08);
  }

  /* â˜… ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®è¦‹ãŸç›® */
  .dragging{
    position:fixed !important;
    z-index:9999 !important;
    margin:0 !important;
    animation:none !important;
    pointer-events:none;
  }

  /* â˜… è¿½ã„å‡ºã—ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚° */
  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:300;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  /* â˜… ãƒ›ã‚¹ãƒˆç”¨ è¨­å®šãƒœã‚¿ãƒ³ï¼ˆå³ä¸‹å›ºå®šï¼‰ */
  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:230;
  }
  .host-settings-btn.visible{display:flex;}

  /* â˜… è¨­å®šãƒãƒƒãƒ—ï¼ˆãƒ›ã‚¹ãƒˆå°‚ç”¨ãƒ‘ãƒãƒ«ï¼‰ */
  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:240;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  /* è©³ç´°æƒ…å ±æ¶ˆã™ç”¨ */
  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  /* =========================
     â˜… å·¦ä¸‹ã€Œï¼Ÿã€ãƒœã‚¿ãƒ³
     ========================= */
  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:230;
  }
  .help-btn.visible{display:flex;}

  /* â˜… ãƒ˜ãƒ«ãƒ—ä¸€è¦§ãƒãƒƒãƒ— */
  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:310;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
  }
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
    overflow:hidden;
  }
  .role-card img{width:100%;height:100%;object-fit:cover;display:block;}
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  /* =========================
     â˜… ã‚¿ãƒ¼ãƒ³æ“ä½œãƒãƒ¼
     ========================= */
  .turn-bar{
    position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
    z-index:228;
    display:flex; gap:8px; align-items:center; justify-content:center;
    background:rgba(255,255,255,.85);
    border:1px solid #ddd;
    border-radius:999px;
    padding:6px 10px;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    backdrop-filter: blur(6px);
  }
  .turn-bar.hidden{display:none;}
  .turn-badge{
    font-size:12px;font-weight:900;opacity:.85;
    padding:4px 8px;border-radius:999px;border:1px solid #ddd;background:#fff;
  }

  /* =========================
     â˜… å…¨å“¡ã«è¦‹ã›ã‚‹ã€Œä¸­å¤®æ‹¡å¤§ã€(1ç§’)
     ========================= */
  .reveal-overlay{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center;
    z-index:500;
  }
  .reveal-overlay.hidden{display:none;}
 .reveal-card{
    width:min(calc(var(--myCardW) * 4), 78vw);
    aspect-ratio: 2 / 3;
    border-radius:18px;
    border:none;
    box-shadow:none;
    background:transparent;
    overflow:hidden;
    position:relative;
  }
  .reveal-card img{width:100%;height:100%;object-fit:cover;display:block;border:none;background:transparent;}
  .reveal-card .label{
    position:absolute; left:10px; top:10px;
    font-weight:900; color:#1d4ed8;
    text-shadow:0 2px 10px rgba(255,255,255,.75);
  }
  .reveal-card .label.hidden{display:none;}
  .reveal-card .effect-frame{
    position:absolute;
    left:0;
    right:0;
    top:70%;
    bottom:0;
    background:rgb(195,179,237);
    border-top:1px solid rgba(0,0,0,.15);
    padding:6px 8px;
    display:flex;
    align-items:flex-start;
    justify-content:flex-start;
    box-sizing:border-box;
    pointer-events:none;
  }
  .reveal-card .effect-frame.hidden{display:none;}
  .reveal-card .effect-text{
    width:100%;
    font-weight:800;
    line-height:1.3;
    color:#111;
    font-size:16px;
    word-break:break-word;
    hyphens:auto;
    overflow:hidden;
  }

  /* â˜… æŒ‡ç¤ºã‚«ãƒ¼ãƒ‰ç§»å‹•ã‚¢ãƒ‹ãƒ¡ç”¨ï¼ˆå°ã•ã„è£ã‚«ãƒ¼ãƒ‰ï¼‰ */
 .fly-card{
    position:fixed;
    width:22px;height:32px;border-radius:6px;
    border:1px solid rgba(0,0,0,.2);
    background:url('swactionura.jpg') center/cover no-repeat;
    box-shadow:0 8px 18px rgba(0,0,0,.25);
    z-index:520;
    pointer-events:none;
  }
  .sweets-fly-card{
    position:fixed;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.18);
    box-shadow:0 10px 24px rgba(0,0,0,.22);
    background:#fff;
    overflow:hidden;
    z-index:540;
    pointer-events:none;
    transform-origin:top left;
  }
  .sweets-fly-card img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
  }


  /* â˜… è‡ªåˆ†ã®æ‰‹æœ­ã‚µã‚¤ã‚ºçµ±ä¸€ï¼ˆ60x90ï¼‰ */
  :root{
    --myCardW: 60px;
    --myCardH: 90px;
    --myCardR: 10px;
  }
  .my-role{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }
  .action-card{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }
  .my-sweets{ width: var(--myCardW); height: var(--myCardH); border-radius: var(--myCardR); }

  /* =========================
     â˜… ã‚¹ã‚¤ãƒ¼ãƒ„ä¸€è¦§ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«è¡¨ç¤ºï¼‰
     ========================= */
  .sweets-backdrop{
    position:fixed; inset:0;
    background:rgba(0,0,0,.35);
    display:flex; flex-direction:column;
    align-items:center; justify-content:flex-start;
    z-index:560;
    padding:16px;
    gap:12px;
    overflow:auto;
  }
  .sweets-backdrop.hidden{display:none;}
  .sweets-panel{
    width:min(760px, calc(100% - 32px));
    background:#fff;
    border:1px solid #ddd;
    border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
    position:sticky;
    top:140px;
  }
  .sweets-panel-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .sweets-panel-title{
    font-weight:900;font-size:14px;
  }
  .sweets-panel-body{
    padding:12px;
    overflow:auto;
    max-height:min(70vh, 640px);
  }
  .sweets-grid{
    display:grid;
    gap:10px;
    justify-content:center;
    align-content:center;
  }
  .sweets-pick-card{
    width:90px; height:135px;
    border-radius:12px;
    border:1px solid #ddd;
    background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    overflow:hidden;
    position:relative;
    cursor:grab;
    user-select:none;
    touch-action:none;
    animation:pulseCardStrong 1.05s ease-in-out infinite;
    transform-origin:center;
  }
  .sweets-pick-card:active{cursor:grabbing;}
  .sweets-pick-card:hover{ animation:none; transform:scale(1.12); }
  .sweets-pick-card img{
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;
    display:block;
  }

  /* â˜… ã‚¹ã‚¤ãƒ¼ãƒ„ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®è¦‹ãŸç›® */
 .sweets-dragging{
    position:fixed !important;
    z-index:99999 !important;
    pointer-events:none;
    animation:none !important;
  }
  .sweets-drop-zone{
    width:min(800px, calc(100% - 32px));
    min-height:200px;
    border:transparent;
    border-radius:14px;
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    color:transparent;
    text-align:center;
    padding:8px 12px;
    margin-top:130px;
  }
  .sweets-drop-zone.active{
    border-color:transparent;
    color:transparent;
    background:transparent;
  }

  /* =========================
     â˜… æŠ•ç¥¨ãƒãƒƒãƒ—ï¼ˆè‡ªåˆ†ã®æ‰‹å…ƒï¼šå…¨ã‚«ãƒ¼ãƒ‰ã®å³å´ï¼‰
     ========================= */
/* æŠ•ç¥¨ãƒãƒƒãƒ—ï¼ˆè‡ªåˆ†ã®æ‰‹å…ƒï¼šå…¨ã‚«ãƒ¼ãƒ‰ã®å³å´ï¼‰ */
.vote-chip{
  width:var(--voteChipSize);
  height:var(--voteChipSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 10px 24px rgba(0,0,0,.18);
  flex:0 0 auto;
  align-self:flex-start;
  cursor:grab;
  user-select:none;
  touch-action:none;
  position:relative;
  transition:transform .2s ease;
}
/* âœ… æŠ•ç¥¨ãƒãƒƒãƒ—å°‚ç”¨ï¼šé¼“å‹•ã‚’å¼±ã‚ã‚‹ */
@keyframes pulseVoteChip {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.5); } /* â† ã“ã“ãŒå¼·ã•ï¼ˆä¾‹ï¼š1.04ã€œ1.10ï¼‰ */
  100% { transform: scale(1); }
}

.vote-chip.hidden{display:none;}
.vote-chip:active{cursor:grabbing;}
.vote-chip.pulsing{ animation:pulseVoteChip 1.05s ease-in-out infinite; }
.vote-chip.pulsing:hover{ animation:none; transform:scale(1.10); } /* â† hoveræ‹¡å¤§ã‚‚æŠ•ç¥¨å°‚ç”¨ã«èª¿æ•´ */


/* æ—¢å­˜ã®ã€ŒVã€æ–‡å­—ã¯æ¶ˆã™ï¼ˆãƒ‡ã‚¶ã‚¤ãƒ³çµ±ä¸€ï¼‰ */
.vote-chip::after{ content:''; }


  .vote-dragging{
    position:fixed !important;
    z-index:999999 !important;
    pointer-events:none;
    animation:none !important;
  }

  .roundpick-dragging{
    position:fixed !important;
    z-index:999999 !important;
    pointer-events:none;
    border-radius:12px;
    border:1px solid rgba(255,255,255,.35);
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    background:#fff center/cover no-repeat;
  }



  /* =========================
     â˜…â˜…â˜… ã“ã“ã‹ã‚‰ PASS & ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†æ¼”å‡º â˜…â˜…â˜…
     ========================= */

  /* å³ä¸‹ï¼šä¸¸ã„PASSãƒœã‚¿ãƒ³ï¼ˆç´«ãƒ»ç™½å­—ï¼‰ */
  .pass-round-btn{
    position:fixed;
    right:16px;
    bottom:16px;
    width:64px;
    height:64px;
    border-radius:50%;
    border:1px solid rgba(255,255,255,.25);
    background:#7c3aed;           /* ç´« */
    color:#fff;
    font-weight:900;
    letter-spacing:.06em;
    box-shadow:0 14px 34px rgba(0,0,0,.25);
    cursor:pointer;
    z-index:235;                  /* hostSettingsBtnã‚ˆã‚Šä¸Šã§ã‚‚OK */
    display:none;
    user-select:none;
  }
  .pass-round-btn.visible{display:grid; place-items:center;}
  .pass-round-btn:active{transform:scale(.98);}
  .pass-round-btn:disabled{opacity:.5; cursor:not-allowed; transform:none;}

  /* åé›†ã‚¢ãƒ‹ãƒ¡ç”¨ï¼šä¸­å¤®ã«é›†ã¾ã‚‹è£ã‚«ãƒ¼ãƒ‰ */
  .collect-card{
    position:fixed;
    width:90px;
    height:135px;
    border-radius:7px;
    border:1px solid rgba(255,255,255,.25);
    background:url('swsweetsura.jpg') center/cover no-repeat;
    z-index:610;
    pointer-events:none;
    transform-origin:center;
  }

  /* æœ€çµ‚å…¬é–‹ï¼ˆè¤‡æ•°ï¼‰ */
  .roundreveal-overlay{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%, -50%);
    background:transparent;
    z-index:620;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:6px;
    pointer-events:none;
  }
  .roundreveal-overlay.hidden{display:none;}
  .roundreveal-row{
    display:flex;
    gap:30px;
    align-items:center;
    justify-content:center;
    flex-wrap:nowrap;          /* æŠ˜ã‚Šè¿”ã—ãªã— */
    overflow:auto;
    padding:6px;
  }
  .roundreveal-card{
    width:min(240px, 32vw);
    aspect-ratio:2/3;
    border-radius:18px;
    border:none;
    box-shadow:none;
    background:transparent;
    overflow:hidden;
    flex:0 0 auto;
    transform:scale(1.02);
  }
  .roundreveal-card img{width:100%;height:100%;object-fit:cover;display:block;}

:root{
  --deckCardW: 28px;
  --deckCardH: 40px;
  --deckCardR: 7px;

  /* æŠ•ç¥¨ãƒãƒƒãƒ—ï¼ˆè‡ªåˆ†/ä»–äºº å…±é€šï¼‰ */
  /* è‡ªåˆ†ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ç”¨ï¼‰ */
  --voteChipSize: 22px;

  /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ä¹—ã‚‹å°ã•ã„ã‚„ã¤ */
  --voteMiniSize: 14px;

  --voteChipFill: rgba(196, 181, 253, .92);
  --voteChipStroke: rgba(255,255,255,.95);
}

/* =========================
   â˜…â˜… ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šå†…å´ã«ã€Œæ­£ä½“ï¼‹ã‚¹ã‚¤ãƒ¼ãƒ„ã€æ¨ªä¸¦ã³ï¼ˆå¹³è¡Œï¼‰
   - JSã‹ã‚‰ --inX/--inY/--rotDeg ã‚’æ¸¡ã™
   ========================= */
.otherplayerscircle{ --inX:0px; --inY:0px; --outX:0px; --outY:0px; --rotDeg:0deg; }

/* ã‚¿ã‚°ï¼ˆå¤–å´ã¸ï¼‰ */
.player-tag.in-othercircle{
  position:absolute;
  left:50%; top:50%;
  transform:translate(-50%,-50%) translate(var(--outX), var(--outY));
}

/* å†…å´ã‚«ãƒ¼ãƒ‰åˆ—ï¼ˆå›è»¢ã—ã¦ã€Œä¸ŠãŒä¸­å¿ƒã‚’å‘ãã€ï¼‰ */
.other-cards-row{
  position:absolute;
  left:50%; top:50%;
  transform:
    translate(-50%,-50%)
    translate(var(--inX), var(--inY))
    rotate(var(--rotDeg));
  display:flex;
  gap:8px;
  align-items:center;
  justify-content:center;
  pointer-events:none; /* è¦‹ãŸç›®å°‚ç”¨ï¼ˆæŠ•ç¥¨ãªã©ã«ã—ãŸã„ãªã‚‰å¤–ã™ï¼‰ */
}

/* æ­£ä½“ãƒŸãƒ‹ï¼ˆè£ï¼‰ */
.role-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swroleura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
}

/* ã‚¹ã‚¤ãƒ¼ãƒ„æ ï¼ˆè£ã‚«ãƒ¼ãƒ‰ï¼‹æŠ•ç¥¨ãƒãƒƒãƒ—é‡ã­ï¼‰ */
.sweets-wrap{
  position:relative;
  width:calc(var(--deckCardW) + 20px);
  height:calc(var(--deckCardH) + 20px);
  border-radius:calc(var(--deckCardR) + 6px);
  border:transparent;
  background:rgba(255,255,255,.10);
  box-sizing:border-box;
  display:flex; align-items:center; justify-content:center;
  transition:transform .6s ease;
  --decidedMoveX: 0px;
  --decidedMoveY: 0px;
}

.sweets-wrap.empty{
  border-style:dashed;
  opacity:.35;
}
.sweets-wrap.hint-ok{
  border-color:transparent;
  background: rgba(200, 200, 200, 0.3);
}
.sweets-wrap.hint-ng{
  border-color:rgba(239,68,68,.75);
  background: rgba(200, 200, 200, 0.3);
}
.sweets-wrap.roundpick-candidate{
  animation:pulseSweetsDeck 1.05s ease-in-out infinite;
}
.sweets-wrap.roundpick-selectable{
  cursor:pointer;
}
.sweets-wrap.roundpick-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
.sweets-wrap.decided-move{
  transform:translate(var(--decidedMoveX), var(--decidedMoveY));
}
.sweets-wrap.decided-move.decided-static{
  transition:none;
}
.sweets-wrap.center-move-host{
  border-color:transparent;
  background:transparent;
}
.sweets-wrap.collect-hidden{
  border-color:transparent;
  background:transparent;
}
.sweets-wrap.collect-hidden .sweets-mini{
  opacity:0;
}

.sweets-mini{
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  border:1px solid rgba(0,0,0,.18);
  background:url('swsweetsura.jpg') center/cover no-repeat;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  --centerMoveX: 0px;
  --centerMoveY: 0px;
}
.sweets-mini.hidden{display:none;}
.sweets-mini.center-move{
  transition:transform .6s ease;
  transform:translate(var(--centerMoveX), var(--centerMoveY));
}
.sweets-mini.center-move.center-static{
  transition:none;
}

.my-sweets.roundpick-candidate{
  animation:pulseCardStrong 1.05s ease-in-out infinite;
}
.my-sweets.roundpick-selectable{
  cursor:pointer;
}
.my-sweets.roundpick-selectable:hover{
  animation:none;
  transform:scale(1.12);
}
.my-sweets.roundpick-selectable:hover ~ .vote-chip,
.my-sweets.roundpick-selectable:active ~ .vote-chip{
  transform:scale(1.12);
}
.my-sweets.decided-move{
  transform:translateY(-30px);
  animation:sweetsDecidedMoveMy .6s ease;
}

/* æŠ•ç¥¨ãƒãƒƒãƒ—ï¼ˆã‚¹ã‚¤ãƒ¼ãƒ„ã®å³å´ã«é‡ã­ã‚‹ï¼‰ */
.vote-stack{
  position:absolute;
  right:-22px;
  top:50%;
  transform:translateY(-50%);
  display:flex;
  flex-wrap:wrap;
  width:calc(var(--voteMiniSize) * 2 + 6px); /* 2åˆ— */
  gap:3px;
  justify-content:flex-start;
  align-items:center;
  pointer-events:none;
}

.selected-sweets-tag{
  position:absolute;
  left:50%;
  bottom:100%;
  width:var(--deckCardW);
  height:var(--deckCardH);
  border-radius:var(--deckCardR);
  overflow:visible;
  --sweetsTagMoveY:-30px;
  transform:translate(-50%, var(--sweetsTagMoveY));
  animation:sweetsTagMove .6s ease;
  pointer-events:none;
}
.selected-sweets-tag.delayed-show{
  opacity:0;
  visibility:hidden;
}
.selected-sweets-tag.decided-static{
  animation:none;
}



.selected-sweets-tag.collect-hidden .selected-sweets-card{
  border-color:transparent;
  background:transparent;
  box-shadow:none;
}
.selected-sweets-tag.collect-hidden img{
  opacity:0;
}
.selected-sweets-tag.collect-hidden .sweets-number-tag{
  opacity:0;
}
.selected-sweets-card{
  position:relative;
  width:100%;
  height:100%;
  border-radius:inherit;
  border:1px solid rgba(0,0,0,.18);
  background:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  --centerMoveX: 0px;
  --centerMoveY: 0px;
}
.selected-sweets-card.center-move{
  transition:transform .6s ease;
  transform:translate(var(--centerMoveX), var(--centerMoveY));
}
.selected-sweets-card.center-move.center-static{
  transition:none;
}
.selected-sweets-card img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
  border-radius:inherit;

}
.selected-sweets-card .sweets-number-tag{
  position:absolute;
  right:9px;
  top:-12px;

  /* å°‘ã—å¤§ããã—ã¦ä½™è£•ã‚’ä½œã‚‹ */
  width:34px;
  height:34px;

  display:grid;
  place-items:center;

  font-weight:900;
  font-size:13px;
  line-height:1;
  color:#111;

  text-shadow:0 1px 0 rgba(255,255,255,.6);
}
.selected-sweets-card .sweets-number-star{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:0;
  pointer-events:none;
}
.selected-sweets-card .sweets-number-text{
  position:relative;
  z-index:1;
  transform:translateZ(0) translateY(-1px);
}


/* ä¸‹ã®æ‰‹ç•ªãƒãƒ¼ã ã‘æ¶ˆã—ã¦ã€å³ä¸‹PASSã¯æ®‹ã™ */
#turnBar{
  display:none !important;
}
/* æŠ•ç¥¨ãƒ‰ãƒ­ãƒƒãƒ—ã®ãŸã‚ï¼šå†…å´ã‚«ãƒ¼ãƒ‰åˆ—ã¯ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’é€šã™ */
.other-cards-row{ pointer-events:auto; }

/* ãƒ‰ãƒ­ãƒƒãƒ—åˆ¤å®šã—ãŸã„ã®ã¯ã‚¹ã‚¤ãƒ¼ãƒ„æ ãªã®ã§ã€ã“ã“ã‚‚æ˜ç¤ºã—ã¦ãŠã */
.sweets-wrap{ pointer-events:auto; }


/* è‡ªåˆ†ã®ã‚¹ã‚¤ãƒ¼ãƒ„ã«ã‚‚æŠ•ç¥¨ãƒŸãƒ‹ã‚’é‡ã­ã‚‹ãŸã‚ */
.my-sweets{ position:relative; }

/* è‡ªåˆ†ã‚¹ã‚¤ãƒ¼ãƒ„ä¸Šã®æŠ•ç¥¨ï¼ˆå³ã«é‡ã­ï¼‰ */
.my-sweets .vote-stack{
  right:-22px;                 /* å°‘ã—ã ã‘å†…å´ã«å¯„ã›ã‚‹ï¼ˆå¥½ã¿ã§èª¿æ•´OKï¼‰ */
  top:10%;
  transform:translateY(-50%);
}
/* â˜… è‡ªåˆ†ã®ã‚¹ã‚¤ãƒ¼ãƒ„ä¸Šã®æŠ•ç¥¨ãƒãƒƒãƒ—ã ã‘ã€Œæ‰‹å…ƒãƒãƒƒãƒ—ã¨åŒã‚µã‚¤ã‚ºã€ã«ã™ã‚‹ */
.my-sweets .vote-stack{
  width:calc(var(--voteChipSize) * 2 + 6px); /* 2åˆ—ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚‚åŒã‚µã‚¤ã‚ºåŸºæº–ã« */
}

.my-sweets .vote-stack .vote-mini{
  width:var(--voteChipSize);
  height:var(--voteChipSize);
  border-radius:50%;
  border:2px solid var(--voteChipStroke);
  background:var(--voteChipFill);
  box-shadow:0 10px 24px rgba(0,0,0,.18);
}

/* =========================
   â˜…â˜… é¸æŠœã‚¹ã‚¤ãƒ¼ãƒ„ï¼šå›åâ†’ã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆä¸­å¤®ï¼‰
   ========================= */
.sweets-shuffle-stage{
  position:fixed;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:160px;
  height:220px;
  z-index:615;
  pointer-events:none;
}
.sweets-shuffle-card{
  position:absolute;
  left:50%;
  top:50%;
  width:120px;
  height:170px;
  transform:translate(-50%,-50%);
  border-radius:12px;
  border:1px solid rgba(255,255,255,.25);
  box-shadow:0 16px 44px rgba(0,0,0,.35);
  background:center/cover no-repeat;
  will-change:transform, opacity;
}

/* =========================
   â˜… ä¸­å¤®ï¼šãƒªãƒ¼ãƒ€ãƒ¼ãƒœãƒ¼ãƒ‰ï¼ˆé•·æ–¹å½¢ 5:3.3ï¼‰
   ========================= */
.leaderboard-board{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:min(120px, 78vw);
  aspect-ratio: 5 / 3.3;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.18);
  background:rgba(255,255,255,.18);
  box-shadow:0 10px 24px rgba(0,0,0,.12);
  overflow:hidden;
  pointer-events:none;
  z-index:4; /* play-circleã‚ˆã‚Šä¸‹/ä¸Šã¯å¥½ã¿ã§ */
}
.leaderboard-board.hidden{display:none;}
.leaderboard-board img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

/* play-circle ã‚’å‰é¢ã«ï¼ˆä¸­å¤®ãƒœãƒ¼ãƒ‰ã®ä¸Šã«ä¹—ã›ã‚‹ï¼‰ */
.play-circle{ z-index:6; }
/* âœ… leaderboardã‚ˆã‚Šå‰é¢ã«å‡ºã—ãŸã„UIã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¸Šã’ã‚‹ */
.otherplayerscircle{ z-index: 7; }   /* ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å††ã”ã¨å‰ã¸ */
.player-tag{ z-index: 8; }          /* ãƒãƒ¼ãƒ ã‚¿ã‚°å‰ã¸ */
.other-cards-row{ z-index: 8; }     /* å†…å´ã‚«ãƒ¼ãƒ‰åˆ—ã‚‚å‰ã¸ */

/* é¸æŠœã‚¹ã‚¤ãƒ¼ãƒ„è¡¨ç¤ºï¼ˆselected cardï¼‰ã‚’ã•ã‚‰ã«å‰ã¸ */
.selected-sweets-tag{ z-index: 9; }

/* ãƒãƒƒãƒ—ç³»ã‚‚å‰ã¸ï¼ˆæŠ•ç¥¨ãƒãƒƒãƒ—/æŠ•ç¥¨ã‚¹ã‚¿ãƒƒã‚¯ï¼‰ */
.vote-chip{ z-index: 9; }           /* è‡ªåˆ†ã®æŠ•ç¥¨ãƒãƒƒãƒ—ï¼ˆå¿µã®ãŸã‚ï¼‰ */
.vote-stack{ z-index: 9; }          /* ä»˜éšã™ã‚‹æŠ•ç¥¨ãƒãƒƒãƒ—ç¾¤ */

/* â€» leaderboardã¯ç¾çŠ¶ã®ã¾ã¾ã§ã‚‚OKï¼ˆz-index:4ï¼‰ */

/* =========================
   â˜… ä¸­å¤®ï¼šãƒ©ã‚¦ãƒ³ãƒ‰ãƒãƒƒãƒ—æ ï¼ˆ3ã¤æ¨ªä¸¦ã³ï¼‰
   - z-indexã«é ¼ã‚‰ãšã€DOMé †ã§å‰é¢åŒ–ï¼ˆleaderboardã®å¾Œã‚ã«ç½®ãï¼‰
   ========================= */
.round-chips{
  position:absolute;
  left:50%;
top:calc(50% - 6.5px);  
  transform:translate(-50%,-50%);
  display:flex;
  gap:10.5px;
  align-items:center;
  justify-content:center;
  pointer-events:none; /* ã‚¯ãƒªãƒƒã‚¯ä¸è¦ãªã‚‰ noneï¼ˆå¿…è¦ã«ãªã£ãŸã‚‰autoã«ï¼‰ */
}

.round-chip-slot{
  width:22px;
  height:22px;
  border-radius:50%;
  border:transparent;
  background:transparent;
  box-shadow:0 6px 14px rgba(0,0,0,.10) inset;
  position:relative;
  overflow:hidden;
}

.round-chip-slot::after{
  /* ä»Šã¯ç›®å°ï¼ˆå¾Œã§æ¶ˆã—ã¦OKï¼‰ */
  content: attr(data-round);
  position:absolute;
  inset:0;
  display:grid;
  place-items:center;
  font-weight:900;
  font-size:10px;
  opacity:.55;
display:none;

}

.round-chip-img{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}

.round-chip-img.hidden{ display:none; }


</style>
</head>
<body>

<header>
  <h1>ã‚¹ã‚¤ãƒ¼ãƒ„ãƒ¯ãƒ³ãƒ€ãƒ¼ãƒªãƒ¼ã‚°</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="åå‰ï¼ˆ4æ–‡å­—ä»¥å†…ï¼‰" maxlength="4" />
    <input id="roomCode" placeholder="ãƒ«ãƒ¼ãƒ ã‚³ãƒ¼ãƒ‰ï¼ˆæœªå…¥åŠ›ã§è‡ªå‹•ç”Ÿæˆï¼‰" maxlength="12" />
    <button class="btn primary" id="btnJoin">å…¥å®¤</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ãƒ­ãƒ“ãƒ¼</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ã“ã“ã«ãƒ†ãƒ¼ãƒ–ãƒ«ã‚„æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>

    <div id="playerCircle" class="player-circle">

  <!-- â˜… ä¸­å¤®ï¼šãƒªãƒ¼ãƒ€ãƒ¼ãƒœãƒ¼ãƒ‰ï¼ˆäººæ•°ã§ç”»åƒåˆ‡æ›¿ï¼‰ -->
<div id="leaderboardBoard" class="leaderboard-board hidden" aria-hidden="true">
  <img id="leaderboardImg" alt="leaderboard" />

  <!-- â˜… ä¸­å¤®ï¼šãƒ©ã‚¦ãƒ³ãƒ‰ãƒãƒƒãƒ—æ ï¼ˆR1/R2/R3ï¼‰â€»leaderboardã‚ˆã‚Šå¾Œã«ç½®ãï¼å‰é¢ã«æç”»ã•ã‚Œã‚‹ -->
  <div id="roundChips" class="round-chips" aria-label="ãƒ©ã‚¦ãƒ³ãƒ‰ãƒãƒƒãƒ—">
    <div class="round-chip-slot" data-round="1" aria-label="ãƒ©ã‚¦ãƒ³ãƒ‰1">
      <img class="round-chip-img hidden" alt="round1" />
    </div>
    <div class="round-chip-slot" data-round="2" aria-label="ãƒ©ã‚¦ãƒ³ãƒ‰2">
      <img class="round-chip-img hidden" alt="round2" />
    </div>
    <div class="round-chip-slot" data-round="3" aria-label="ãƒ©ã‚¦ãƒ³ãƒ‰3">
      <img class="round-chip-img hidden" alt="round3" />
    </div>
  </div>
</div>


      <div id="playCircle" class="play-circle">
        <div id="requiredSweetsTag" class="required-sweets-tag hidden">ğŸ°0</div>
        <!-- â˜… ä¸­å¤®ï¼šã‚¢ã‚¯ã‚·ãƒ§ãƒ³å±±æœ­ï¼ˆå·¦ï¼‰ï¼‹ã‚¹ã‚¤ãƒ¼ãƒ„å±±æœ­ï¼ˆå³ï¼‰ -->
        <div id="centerDecks" class="center-decks hidden" aria-hidden="false">
          <div id="actionDeckUI" class="action-deck hidden" aria-hidden="true">
            <div class="stack" aria-hidden="true">
              <div class="card c5"></div>
              <div class="card c4"></div>
              <div class="card c3"></div>
              <div class="card c2"></div>
              <div class="card c1"></div>
            </div>
            <div id="actionDeckCount" class="count">0</div>
          </div>

         <div class="sweets-deck-wrap">
            <div id="sweetsDeckUI" class="sweets-deck hidden" aria-label="ã‚¹ã‚¤ãƒ¼ãƒ„å±±æœ­">
              <div class="stack" aria-hidden="true">
                <div class="card c5"></div>
                <div class="card c4"></div>
                <div class="card c3"></div>
                <div class="card c2"></div>
                <div class="card c1"></div>
              </div>
              <div id="sweetsDeckCount" class="count">0</div>
            </div>
            <div id="sweetsExcludedDeckUI" class="sweets-exclude-deck hidden" aria-label="ã‚¹ã‚¤ãƒ¼ãƒ„é™¤å¤–å±±æœ­">
              <div class="stack" aria-hidden="true">
                <div class="card c5"></div>
                <div class="card c4"></div>
                <div class="card c3"></div>
                <div class="card c2"></div>
                <div class="card c1"></div>
              </div>
              <div id="sweetsExcludedDeckCount" class="count">0</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">è‡ªåˆ†ã®ã‚«ãƒ¼ãƒ‰</div>

      <!-- â˜… ownarea -->
      <div class="my-area" id="myArea">
        <!-- â˜… å—ã‘å–ã£ãŸæŒ‡ç¤ºã‚«ãƒ¼ãƒ‰ï¼ˆæ­£ä½“ã‚«ãƒ¼ãƒ‰ã®å·¦ï¼‰ -->
        <div id="myReceived" class="my-received-slot"></div>

        <!-- â˜… è‡ªåˆ†ã®ã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆæ­£ä½“ã‚«ãƒ¼ãƒ‰ã®å·¦ãƒ»åŒã‚µã‚¤ã‚ºï¼‰ -->
        <div id="mySweets" class="my-sweets hidden"></div>

        <div id="myRole" class="my-role hidden"></div>
        <div id="myHand" class="my-hand"></div>

        <!-- â˜… æŠ•ç¥¨ãƒãƒƒãƒ—ï¼ˆå…¨æ‰€æœ‰ã‚«ãƒ¼ãƒ‰ã‚ˆã‚Šå³ï¼‰ -->
        <div id="myVoteChip" class="vote-chip hidden" aria-label="æŠ•ç¥¨ãƒãƒƒãƒ—"></div>
      </div>
    </div>
  </div>
</main>

<!-- â˜… å‚åŠ è€…ï¼šãƒ›ã‚¹ãƒˆäººæ•°é¸æŠä¸­ãƒãƒƒãƒ— -->
<div id="hostSelectingPop" class="host-selecting-pop hidden">ãƒ›ã‚¹ãƒˆãŒäººæ•°ã‚’é¸æŠä¸­</div>
<div id="leaderPickPop" class="leader-pick-pop hidden">æœ€å¤šç¥¨ã®ä¸­ã‹ã‚‰ãƒªãƒ¼ãƒ€ãƒ¼ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚</div>

<!-- ç€å¸­ãƒãƒƒãƒ— -->
<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>å¸­ã‚’é¸æŠ</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">è¦³æˆ¦</button>
  </div>
</div>

<!-- æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½ã„å‡ºã—ç¢ºèªãƒãƒƒãƒ— -->
<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">æ—¢å­˜ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã„å‡ºã—ã¦ã€ç€å¸­ã—ã¾ã™ã‹ï¼Ÿ</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">ã„ã„ãˆ</button>
      <button class="btn primary" id="btnKickYes">ã¯ã„</button>
    </div>
  </div>
</div>

<!-- ãƒ›ã‚¹ãƒˆå°‚ç”¨ è¨­å®šãƒœã‚¿ãƒ³ï¼ˆâš™ï¼‰ -->
<button id="hostSettingsBtn" class="host-settings-btn" title="è¨­å®š">âš™</button>

<!-- â˜… ãƒ˜ãƒ«ãƒ—ãƒœã‚¿ãƒ³ï¼ˆï¼Ÿï¼‰ -->
<button id="helpBtn" class="help-btn" title="æ­£ä½“ã‚«ãƒ¼ãƒ‰ä¸€è¦§">ï¼Ÿ</button>

<!-- â˜… ãƒ˜ãƒ«ãƒ—ä¸€è¦§ãƒãƒƒãƒ— -->
<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="æ­£ä½“ã‚«ãƒ¼ãƒ‰ä¸€è¦§">
    <div class="help-pop-header">
      <div class="help-pop-title">æ­£ä½“ã‚«ãƒ¼ãƒ‰</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">Ã—</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<!-- è¨­å®šãƒãƒƒãƒ—ï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆï¼‹ãƒªã‚»ãƒƒãƒˆï¼‰ -->
<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ãƒ›ã‚¹ãƒˆè¨­å®š</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">Ã—</button>
  </div>
  <div class="start-pop-main">
    ã€Œã‚¹ã‚¿ãƒ¼ãƒˆã€ã§æ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰é…å¸ƒï¼‹æ‰‹ç•ªæ±ºå®šã€‚<br>
    ã€Œãƒªã‚»ãƒƒãƒˆã€ã§äººæ•°é¸æŠã¸æˆ»ã—ã¾ã™ï¼ˆå†…å®¹ã¯å¾Œã§ï¼‰ã€‚
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">ãƒªã‚»ãƒƒãƒˆ</button>
    <button id="btnGameStart" class="btn primary">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
  </div>
</div>

<!-- â˜… ã‚¿ãƒ¼ãƒ³æ“ä½œãƒãƒ¼ï¼ˆæ—¢å­˜ï¼‰ -->
<div id="turnBar" class="turn-bar hidden">
  <span id="turnBadge" class="turn-badge">TURN</span>
  <button id="btnPass" class="btn">ãƒ‘ã‚¹</button>
  <button id="btnDrawSweets" class="btn" disabled>ã‚¹ã‚¤ãƒ¼ãƒ„ãƒ‰ãƒ­ãƒ¼ï¼ˆå¾Œã§ï¼‰</button>
  <button id="btnVote" class="btn" disabled>æŠ•ç¥¨ï¼ˆå¾Œã§ï¼‰</button>
</div>

<!-- â˜… å³ä¸‹ï¼šä¸¸ã„PASSãƒœã‚¿ãƒ³ï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰ç”¨ï¼‰ -->
<button id="passRoundBtn" class="pass-round-btn" type="button" aria-label="PASS">PASS</button>

<!-- â˜… ä¸­å¤®æ‹¡å¤§è¡¨ç¤ºï¼ˆå…¨å“¡ã€1ç§’ï¼‰ -->
<div id="revealOverlay" class="reveal-overlay hidden">
  <div class="reveal-card">
    <img id="revealImg" alt="" />
    <div id="revealLabel" class="label"></div>
    <div id="revealEffectFrame" class="effect-frame hidden">
      <div id="revealEffect" class="effect-text"></div>
    </div>
  </div>
</div>


<!-- â˜… ã‚¹ã‚¤ãƒ¼ãƒ„ä¸€è¦§ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«è¡¨ç¤ºï¼‰ -->
<div id="sweetsBackdrop" class="sweets-backdrop hidden">
  <div class="sweets-panel" role="dialog" aria-modal="true" aria-label="ã‚¹ã‚¤ãƒ¼ãƒ„ä¸€è¦§">
    <div class="sweets-panel-header">
      <div class="sweets-panel-title">ã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆä¸‹ã«ãƒ‰ãƒ©ãƒƒã‚°ï¼‰</div>
      <button id="btnSweetsClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">Ã—</button>
    </div>
    <div class="sweets-panel-body">
      <div id="sweetsGrid" class="sweets-grid"></div>
    </div>
  </div>
  <div id="sweetsDropZone" class="sweets-drop-zone" aria-label="ã‚¹ã‚¤ãƒ¼ãƒ„ç²å¾—ã‚¨ãƒªã‚¢">
    ã“ã“ã«ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã™ã¨ç²å¾—
  </div>
</div>

<!-- â˜… ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ï¼šå…¬é–‹ï¼ˆè¤‡æ•°ï¼‰ -->
<div id="roundRevealOverlay" class="roundreveal-overlay hidden" aria-hidden="true">
  <div id="roundRevealRow" class="roundreveal-row"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove,
  push, onChildAdded, serverTimestamp
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

/* =========================
   Firebase
   ========================= */
const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};
const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

// â˜… userId ã‚’ã‚¿ãƒ–å˜ä½ã§å›ºå®šï¼ˆã‚¿ãƒ–ã”ã¨ã«åˆ¥IDï¼‰
const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

/* =========================
   çŠ¶æ…‹
   ========================= */
const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  turnEnding: false,
  passReadyBlockedTurnNo: null,
  lastPassEligible: false,
  prevTurnNo: null,

  room: {},
  hands: {},
  roles: {},
  game: {},
  turn: null,
};
let latestPlayers = [];
const collectedSweetsHidden = new Set();
let miniShuffleRunning = false;
let miniShuffleToken = 0;
let sweetsExcludeAnimating = false;
let sweetsDeckCountOverride = null;
let sweetsExcludedCountOverride = null;
let sweetsOverrideClearTimer = null;
let currentGameSessionId = null;
let eventsSubscribedAt = 0;
let turnBlockedByShuffle = false;
let leaderPickApplyTimer = null;
let leaderPickApplyKey = null;
let lastLeaderSeat = null;
/* =========================
   DOM
   ========================= */
const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');
const leaderPickPop = document.getElementById('leaderPickPop');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const playCircleEl = document.getElementById('playCircle');
const myHandEl = document.getElementById('myHand');
const myRoleEl = document.getElementById('myRole');
const myReceivedEl = document.getElementById('myReceived');
const mySweetsEl = document.getElementById('mySweets');
const myAreaEl = document.getElementById('myArea');
const myVoteChipEl = document.getElementById('myVoteChip');
const leaderboardBoardEl = document.getElementById('leaderboardBoard');
const leaderboardImgEl   = document.getElementById('leaderboardImg');

const centerDecksEl = document.getElementById('centerDecks');
const requiredSweetsTagEl = document.getElementById('requiredSweetsTag');

/* âœ… è¿½åŠ ï¼šãƒ©ã‚¦ãƒ³ãƒ‰ãƒãƒƒãƒ—ï¼ˆR1/R2/R3ï¼‰ */
const roundChipsEl = document.getElementById('roundChips');
const roundChipImgEls = Array.from(document.querySelectorAll('#roundChips .round-chip-img'));


/* ä¸­å¤®ã®å±±æœ­UI */
const actionDeckUI = document.getElementById('actionDeckUI');
const actionDeckCountEl = document.getElementById('actionDeckCount');
const sweetsDeckUI = document.getElementById('sweetsDeckUI');
const sweetsDeckCountEl = document.getElementById('sweetsDeckCount');
const sweetsExcludedDeckUI = document.getElementById('sweetsExcludedDeckUI');
const sweetsExcludedDeckCountEl = document.getElementById('sweetsExcludedDeckCount');


/* ã‚¹ã‚¤ãƒ¼ãƒ„ä¸€è¦§ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ï¼‰ */
const sweetsBackdrop = document.getElementById('sweetsBackdrop');
const sweetsDropZone = document.getElementById('sweetsDropZone');
const btnSweetsClose = document.getElementById('btnSweetsClose');
const sweetsGrid = document.getElementById('sweetsGrid');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

/* ãƒ˜ãƒ«ãƒ— */
const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

/* ã‚¿ãƒ¼ãƒ³æ“ä½œãƒãƒ¼ */
const turnBar = document.getElementById('turnBar');
const turnBadge = document.getElementById('turnBadge');
const btnPass = document.getElementById('btnPass');
const btnDrawSweets = document.getElementById('btnDrawSweets');
const btnVote = document.getElementById('btnVote');

/* å³ä¸‹PASSï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰ç”¨ï¼‰ */
const passRoundBtn = document.getElementById('passRoundBtn');

/* ãƒ©ã‚¦ãƒ³ãƒ‰å…¬é–‹ï¼ˆè¤‡æ•°ï¼‰ */
const roundRevealOverlay = document.getElementById('roundRevealOverlay');
const roundRevealRow = document.getElementById('roundRevealRow');

/* ä¸­å¤®æ‹¡å¤§ï¼ˆå˜ä½“ï¼‰ */
const revealOverlay = document.getElementById('revealOverlay');
const revealImg = document.getElementById('revealImg');
const revealLabel = document.getElementById('revealLabel');
const revealEffectFrame = document.getElementById('revealEffectFrame');
const revealEffect = document.getElementById('revealEffect');

/* =========================
   ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
   ========================= */
function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}
function shuffle(arr){
  const a = [...arr];
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function now(){ return Date.now(); }

/* âœ… è¿½åŠ ï¼šå‹åˆ©ç‚¹ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆäººæ•°Ã—ãƒ©ã‚¦ãƒ³ãƒ‰ï¼‰ */
function getRoundWinThreshold(playerCount, roundNo){
  const r = clamp(roundNo ?? 1, 1, 3);
  if(playerCount <= 4)  return [8,10,12][r-1];
  if(playerCount <= 6)  return [12,14,16][r-1];
  return [16,18,20][r-1]; // 7ã€œ8äººæƒ³å®š
}

/* âœ… è¿½åŠ ï¼šé¸ã°ã‚ŒãŸã‚¹ã‚¤ãƒ¼ãƒ„åˆè¨ˆç‚¹ï¼ˆcardsé…åˆ—ã®valueåˆè¨ˆï¼‰ */
function calcSweetsTotalPoints(cards){
  const arr = Array.isArray(cards) ? cards : [];
  return arr.reduce((sum, c) => {
    const v =
      (c && typeof c.value === 'number') ? c.value :
      (c && typeof c.name === 'string') ? (parseInt(c.name, 10) || 0) :
      0;
    return sum + v;
  }, 0);
}

/* âœ… è¿½åŠ ï¼šroundchipè¡¨ç¤ºï¼ˆgame.roundChipsã‚’åæ˜ ï¼‰ */
function renderRoundChipsFromGame(){
  if(!roundChipImgEls || !roundChipImgEls.length) return;
  const chips = (state.game && typeof state.game === 'object' && state.game.roundChips) ? state.game.roundChips : {};
  roundChipImgEls.forEach((img, idx) => {
    const r = String(idx + 1);
    const src = chips?.[r] || chips?.[idx + 1] || null; // æ•°å­—ã‚­ãƒ¼/æ–‡å­—ã‚­ãƒ¼ä¸¡å¯¾å¿œ
    if(src){
      img.src = src;
      img.classList.remove('hidden');
    }else{
      img.removeAttribute('src');
      img.classList.add('hidden');
    }
  });
}



const roundRevealState = {
  started: false,
  finished: false,
  startedAt: null,
  finishedAt: null,
};

function resetRoundRevealState(){
  roundRevealState.started = false;
  roundRevealState.finished = false;
  roundRevealState.startedAt = null;
  roundRevealState.finishedAt = null;
}

function markRoundRevealStarted(){
  roundRevealState.started = true;
  roundRevealState.startedAt = now();
  roundRevealState.finished = false;
  roundRevealState.finishedAt = null;
}

function markRoundRevealFinished(){
  roundRevealState.finished = true;
  roundRevealState.finishedAt = now();
}

async function waitForRoundRevealCompletion(timeoutMs = 10000){
  const start = now();
  while(true){
    if(roundRevealState.started && roundRevealState.finished) return true;
    if(timeoutMs && now() - start > timeoutMs) return false;
    await sleep(50);
  }
}

function resetLocalGameEffects(){
  stopRoundEndFx();
  resetRoundRevealState();
  resetCollectedSweetsHiddenCache();

  miniShuffleToken += 1;
  miniShuffleRunning = false;
  sweetsExcludeAnimating = false;
  turnBlockedByShuffle = false;

  if(revealTimer){
    clearTimeout(revealTimer);
    revealTimer = null;
  }
  revealOverlay.classList.add('hidden');

  if(sweetsOverrideClearTimer){
    clearTimeout(sweetsOverrideClearTimer);
    sweetsOverrideClearTimer = null;
  }
  sweetsDeckCountOverride = null;
  sweetsExcludedCountOverride = null;

  document.querySelectorAll('.sweets-shuffle-stage, .sweets-move-card, .collect-card')
    .forEach(el => el.remove());

  roundRevealRow.innerHTML = '';
  roundRevealOverlay.classList.add('hidden');

  updateActionDeckUI();
  updateSweetsDeckUI();
}


function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? 'ï¼ˆãƒ›ã‚¹ãƒˆï¼‰' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  helpBtn.classList.add('visible');
}

function setLeaderboardImageBase(base){
  if(!leaderboardImgEl) return;
  // æ—¢å®šã¯ .jpg â†’ ãƒ€ãƒ¡ãªã‚‰ .png â†’ .webp
  leaderboardImgEl.dataset.base = base;
  leaderboardImgEl.dataset.try = 'jpg';
  leaderboardImgEl.src = `${base}.jpg`;
}
if (leaderboardImgEl){
  leaderboardImgEl.addEventListener('error', () => {
    const base = leaderboardImgEl.dataset.base || '';
    const tried = leaderboardImgEl.dataset.try || 'jpg';
    if(!base) return;

    if(tried === 'jpg'){
      leaderboardImgEl.dataset.try = 'png';
      leaderboardImgEl.src = `${base}.png`;
      return;
    }
    if(tried === 'png'){
      leaderboardImgEl.dataset.try = 'webp';
      leaderboardImgEl.src = `${base}.webp`;
      return;
    }
    // ã“ã“ã¾ã§æ¥ãŸã‚‰è«¦ã‚ã¦éè¡¨ç¤ºï¼ˆç„¡é™ã‚¨ãƒ©ãƒ¼é˜²æ­¢ï¼‰
    leaderboardBoardEl?.classList.add('hidden');
  });
}

function updateLeaderboardBoardByPlayerCount(n){
  if(!leaderboardBoardEl || !leaderboardImgEl) return;

  let base = null;
  if(n >= 1 && n <= 4) base = 'swleaderboard1';
  else if(n >= 5 && n <= 6) base = 'swleaderboard2';
  else if(n >= 7 && n <= 8) base = 'swleaderboard3';

  if(!base){
    leaderboardBoardEl.classList.add('hidden');
    leaderboardBoardEl.setAttribute('aria-hidden','true');
    return;
  }

  leaderboardBoardEl.classList.remove('hidden');
  leaderboardBoardEl.setAttribute('aria-hidden','false');

  // åŒã˜baseãªã‚‰å¼µã‚Šæ›¿ãˆãªã„
  if(leaderboardImgEl.dataset.base !== base){
    setLeaderboardImageBase(base);
  }
}


/* =========================
   â˜… ä¸­å¤®ï¼šã‚¢ã‚¯ã‚·ãƒ§ãƒ³å±±æœ­UI
   ========================= */
function updateActionDeckUI(){
  const deck = state.room?.decks?.action;
  const count = Array.isArray(deck) ? deck.length : 0;

  const started = !!state.room?.gameStarted;
  centerDecksEl.classList.toggle('hidden', !started);

  actionDeckUI.classList.toggle('hidden', !started);
  actionDeckCountEl.textContent = String(count);

  const stackN =
    count >= 20 ? 5 :
    count >= 12 ? 4 :
    count >= 6  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = actionDeckUI.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

/* =========================
   â˜… ä¸­å¤®ï¼šã‚¹ã‚¤ãƒ¼ãƒ„å±±æœ­UIï¼ˆæ®‹ã‚Šæšæ•°/å±±æœ­æ„Ÿ/é¼“å‹•ï¼‰
   ========================= */
function getMySweetsCard(){
  const myData = state.hands?.[state.userId];
  const arr = myData?.sweets;
  if(Array.isArray(arr) && arr.length) return arr[0];
  return null;
}
function hasSweets(){
  return !!getMySweetsCard();
}
function clearSweetsCountOverridesIfSynced(liveCount, liveExcluded){
  if(sweetsDeckCountOverride === null && sweetsExcludedCountOverride === null) return;
  if(sweetsDeckCountOverride === liveCount && sweetsExcludedCountOverride === liveExcluded){
    sweetsDeckCountOverride = null;
    sweetsExcludedCountOverride = null;
    if(sweetsOverrideClearTimer){
      clearTimeout(sweetsOverrideClearTimer);
      sweetsOverrideClearTimer = null;
    }
  }
}
function setSweetsCountOverrides(deckCount, excludedCount, autoClearMs = 0){
  sweetsDeckCountOverride = deckCount;
  sweetsExcludedCountOverride = excludedCount;
  if(sweetsOverrideClearTimer){
    clearTimeout(sweetsOverrideClearTimer);
    sweetsOverrideClearTimer = null;
  }
  if(autoClearMs > 0){
    sweetsOverrideClearTimer = setTimeout(() => {
      sweetsDeckCountOverride = null;
      sweetsExcludedCountOverride = null;
      sweetsOverrideClearTimer = null;
      updateSweetsDeckUI();
    }, autoClearMs);
  }
}
function updateDeckStackUI(deckEl, count){
  if(!deckEl) return;
  const stackN =
    count >= 10 ? 5 :
    count >= 8  ? 4 :
    count >= 5  ? 3 :
    count >= 2  ? 2 :
    count >= 1  ? 1 : 0;

  const cards = deckEl.querySelectorAll('.card');
  cards.forEach((el) => {
    const cls = [...el.classList].find(c => /^c[1-5]$/.test(c));
    const idx = cls ? Number(cls.slice(1)) : 1;
    el.style.display = (idx <= stackN) ? '' : 'none';
  });
}

function updateSweetsDeckUI(){
  const deck = state.room?.decks?.sweets;
  const excludedDeck = state.room?.decks?.sweetsExcluded;
  const liveCount = Array.isArray(deck) ? deck.length : 0;
  const liveExcluded = Array.isArray(excludedDeck) ? excludedDeck.length : 0;

  clearSweetsCountOverridesIfSynced(liveCount, liveExcluded);

  const count = sweetsDeckCountOverride ?? liveCount;
  const excludedCount = sweetsExcludedCountOverride ?? liveExcluded;


  const started = !!state.room?.gameStarted;
  centerDecksEl.classList.toggle('hidden', !started);

  sweetsDeckUI.classList.toggle('hidden', !started || miniShuffleRunning);
  sweetsExcludedDeckUI.classList.toggle('hidden', !started || miniShuffleRunning || (!sweetsExcludeAnimating && excludedCount <= 0));
  sweetsDeckCountEl.textContent = String(count);

 sweetsExcludedDeckCountEl.textContent = String(excludedCount);

  updateDeckStackUI(sweetsDeckUI, count);
  updateDeckStackUI(sweetsExcludedDeckUI, excludedCount);


  const pulsing = isMyTurn() && !hasSweets() && !hasReceivedInstruction();
  sweetsDeckUI.classList.toggle('pulsing', pulsing);
}

function getRequiredSweetsCount(){
  const nPlayers = latestPlayers.length;
  if(nPlayers <= 0) return 0;
  const baseNeed = requiredPickCountByPlayers(nPlayers);
  const rp = getRoundPick();
  const remaining = Number(rp?.need ?? NaN);
  if(rp?.phase === 'choose' && Number.isFinite(remaining) && remaining > 0){
    return remaining;
  }
  return baseNeed;
}

function updateRequiredSweetsTag(){
  if(!requiredSweetsTagEl) return;
  const started = !!state.room?.gameStarted;
  const hasPlayers = latestPlayers.length > 0;
  requiredSweetsTagEl.classList.toggle('hidden', !(started && hasPlayers));
  if(!(started && hasPlayers)) return;
  const count = getRequiredSweetsCount();
  requiredSweetsTagEl.textContent = `ğŸ°${count}`;
}


/* =========================
   ãƒ˜ãƒ«ãƒ—ï¼ˆæ­£ä½“ã‚«ãƒ¼ãƒ‰ï¼‰
   ========================= */
function roleToHelp(role){
  if(role === 'usakoma'){
    return { name:"ã†ã•ã“ã¾", img:"swsweetsurakoma.jpg", text:"ï¼ˆèª¬æ˜ã¯å¾Œã§ï¼‰" };
  }
  if(role === 'uragiri'){
    return { name:"è£åˆ‡ã‚Šè€…", img:"swsweetsuragiri.jpg", text:"ï¼ˆèª¬æ˜ã¯å¾Œã§ï¼‰" };
  }
  return { name:"ä¸æ˜", img:"swroleura.jpg", text:"" };
}
function renderHelpList(){
  helpBody.innerHTML = '';
  const list = [
    { name:"ã†ã•ã“ã¾", img:"swsweetsurakoma.jpg", text:"ï¼ˆèª¬æ˜ã¯å¾Œã§ï¼‰" },
    { name:"è£åˆ‡ã‚Šè€…", img:"swsweetsuragiri.jpg", text:"ï¼ˆèª¬æ˜ã¯å¾Œã§ï¼‰" },
  ];
  list.forEach((r) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    const img = document.createElement('img');
    img.src = r.img;
    img.alt = r.name;
    card.appendChild(img);

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;

    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
}
helpBtn.addEventListener('click', () => {
  if (joinBox.classList.contains('hidden')) openHelp();
});
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => {
  if (e.target === helpBackdrop) closeHelp();
});

/* =========================
   Seat å¾©å…ƒ
   ========================= */
async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;

  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) {
      mySeatIndex = Number(seatIndex);
      break;
    }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

/* =========================
   subscribe
   ========================= */
function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();

    updateActionDeckUI();
    updateSweetsDeckUI();
    updateRequiredSweetsTag();
    renderHands();
    renderMyVoteChip();
renderMySweetsVoteStack();
    updatePassRoundBtn();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
  });
}
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || 'åç„¡ã—',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
updateLeaderboardBoardByPlayerCount(players.length); 
    updatePassRoundBtn();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
    updatePassRoundBtn();
  });
}
function subscribeRoles(){
  const rolesRef = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderHands();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}
function subscribeGame(){
  const gameRef = ref(db, `rooms/${state.roomCode}/game`);
  onValue(gameRef, snap => {
    const prevLeaderSeat = state.turn?.leaderSeat ?? null;
    state.game = snap.val() || {};
    state.turn = state.game.turn || null;
    state.turnEnding = false;
    const nextSessionId = state.game?.sessionId || null;
    const sessionChanged = nextSessionId !== currentGameSessionId;
    if(sessionChanged){
      resetLocalGameEffects();
      currentGameSessionId = nextSessionId;
    } else {
      resetCollectedSweetsHiddenCache();
    }
    syncPassTurnState();
    updateTurnUI();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    renderRoundChipsFromGame();

    // â˜… ãƒ›ã‚¹ãƒˆï¼šå…¨å“¡PASSã«ãªã£ãŸã‚‰ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†å‡¦ç†ã¸
    if(state.isHost){
      maybeHostStartRoundEndFlow().catch(()=>{});
      maybeHostFireRoundRevealAfterLeaderPick().catch(()=>{});
      maybeHostApplyLeaderPick();
    }
    // â˜… ãƒªãƒ¼ãƒ€ãƒ¼é¸æŠUIæ›´æ–°ï¼ˆåŒç¥¨è§£æ±ºï¼‰
    updateRoundPickUI();
    updateLeaderPickUI();
    updatePassRoundBtn();

    const nextLeaderSeat = state.turn?.leaderSeat ?? null;
    if(prevLeaderSeat !== null && nextLeaderSeat !== null && prevLeaderSeat !== nextLeaderSeat){
      requestAnimationFrame(() => animateLeaderChipMove(prevLeaderSeat, nextLeaderSeat));
    }
    lastLeaderSeat = nextLeaderSeat;
  });
}
function subscribeEvents(){
  const evRef = ref(db, `rooms/${state.roomCode}/events`);
  eventsSubscribedAt = now();
 onChildAdded(evRef, async snap => {
    const key = snap.key;
    const ev = snap.val();
    if(!ev) return;
    const expectedSessionId = state.game?.sessionId || currentGameSessionId || null;
    if(ev.sessionId){
      if(expectedSessionId && ev.sessionId !== expectedSessionId) return;
      if(!currentGameSessionId) currentGameSessionId = ev.sessionId;
    }
    if(!expectedSessionId && !currentGameSessionId) return;
   const isStaleEvent = typeof ev.at === 'number' && eventsSubscribedAt && ev.at < eventsSubscribedAt;
    if(isStaleEvent && ['miniSweetsShuffleStart','roundRevealSweets','revealCard','flyBackCard'].includes(ev.type)) return;
    if(ev.type === 'revealCard'){
      showReveal(ev.card);
    }
    if(ev.type === 'flyBackCard'){
      animateFlyBackCard(ev.fromSeat, ev.toSeat);
    }
    if(ev.type === 'dealActionCard'){
      const delayMs = (typeof ev.delayMs === 'number') ? ev.delayMs : 0;
      animateActionDealCard(ev.toSeat, delayMs);
    }

    // â˜… ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†æ¼”å‡ºï¼ˆå…¨å“¡ï¼‰
    if(ev.type === 'roundRevealSweets'){
      // ev.cards: è¡¨ã«ã™ã‚‹ã‚«ãƒ¼ãƒ‰é…åˆ—ï¼ˆã‚¹ã‚¤ãƒ¼ãƒ„ã‚«ãƒ¼ãƒ‰ï¼‰
      await animateRoundEndReveal(ev.cards || [], ev.selectedUids || []);
  await animateReturnAllFieldSweetsToDeck();
  // âœ… ãã®ç›´å¾Œï¼šé™¤å¤–æœ­ã‚’ã€Œç¸¦ã«ãªã£ã¦ã€å±±æœ­ã¸å›å
  await animateReturnExcludedDeckToSweetsDeck();
  await hostFinalizeReturnSweetsToDeck(ev.cards || []);

    }
    if(ev.type === 'miniSweetsShuffleStart'){
      await runMiniSweetsShuffleAtStart(ev);
    }

    if(state.isHost){
      maybeHostStartRoundEndFlow().catch(()=>{});
    }
  });
}

/* =========================
   ã‚¿ãƒ¼ãƒ³ç®¡ç†ï¼ˆPASSå¯¾å¿œï¼špassã—ãŸäººã¯é£›ã°ã™ï¼‰
   ========================= */
function getSeatedSeatOrder(){
  return latestPlayers.map(p => p.seatIndex).sort((a,b)=>a-b);
}
function getPlayerBySeat(seatIndex){
  return latestPlayers.find(p => p.seatIndex === seatIndex) || null;
}
function getPlayerByUid(uid){
  return latestPlayers.find(p => p.id === uid) || null;
}
function getSeatByUid(uid){
  const fromPlayers = getPlayerByUid(uid);
  if(fromPlayers) return fromPlayers.seatIndex;
  const tables = state.room?.tables;
  if(tables && typeof tables === 'object'){
    const entry = Object.entries(tables).find(([, t]) => t && t.playerId === uid);
    if(entry){
      return Number(entry[0]);
    }
  }
  return null;
}
function getPassedMap(){
  const p = state.game?.passes;
  return (p && typeof p === 'object') ? p : {};
}
function isPassedPlayerId(uid){
  const pm = getPassedMap();
  return !!pm?.[uid];
}
function isTurnBlocked(){
  return !!turnBlockedByShuffle;
}

async function hostGrantTurnAfterMiniShuffle(){
  if(!state.isHost || !state.roomCode) return;
  if(state.game?.turn) return;
  const seats = getSeatedSeatOrder();
  if(!seats.length) return;
  const leaderSeat = seats[Math.floor(Math.random() * seats.length)];
  const leaderIdx = seats.indexOf(leaderSeat);
  const nextSeat = seats[(leaderIdx + 1) % seats.length];
  const player = getPlayerBySeat(nextSeat);
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await set(turnRef, {
    activeSeat: nextSeat,
    activePlayerId: player?.id ?? null,
    startSeat: nextSeat,
    leaderSeat: leaderSeat,
   turnNo: 1,
    updatedAt: serverTimestamp(),
  });
}

async function hostRestartTurnAfterActionDeal(leaderSeat){
  if(!state.isHost || !state.roomCode) return;
  if(leaderSeat == null) return;

  const base = `rooms/${state.roomCode}/game`;
  const gameSnap = await get(ref(db, base));
  const gameNow = gameSnap.val() || {};
  const seatOrder = Array.isArray(gameNow.seatOrder) && gameNow.seatOrder.length
    ? gameNow.seatOrder
    : getSeatedSeatOrder();
  if(!seatOrder.length) return;

  const leaderIdx = seatOrder.indexOf(leaderSeat);
  const nextSeat = (leaderIdx === -1)
    ? seatOrder[0]
    : seatOrder[(leaderIdx + 1) % seatOrder.length];
  const nextPlayer = getPlayerBySeat(nextSeat);

  await update(ref(db, base), {
    passes: {},
    roundEnding: false,
    roundPick: null,
    leaderPick: null,
    turn: {
      activeSeat: nextSeat,
      activePlayerId: nextPlayer?.id ?? null,
      startSeat: nextSeat,
      leaderSeat: leaderSeat,
      turnNo: 1,
      updatedAt: serverTimestamp(),
    },
  });
}

function getNextOccupiedSeatSkippingPassed(currentSeat){
  const seats = getSeatedSeatOrder();
  if(!seats.length) return null;

  const startIdx = seats.indexOf(currentSeat);
  const begin = (startIdx === -1) ? 0 : startIdx;

  for(let step=1; step<=seats.length; step++){
    const s = seats[(begin + step) % seats.length];
    const p = getPlayerBySeat(s);
    if(!p) continue;
    if(!isPassedPlayerId(p.id)) return s;
  }
  // å…¨å“¡passæ¸ˆã¿ãªã‚‰ã€é€šå¸¸ã¯ã“ã“ã«æ¥ãªã„ï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ã«å…¥ã‚‹ï¼‰
  return seats[(begin + 1) % seats.length];
}
function isMyTurn(){
  if(!state.turn) return false;
  if(isTurnBlocked()) return false;
  if(state.game?.roundEnding) return false;
  if(allSeatedPlayersPassed()) return false;
  return (state.turn.activePlayerId === state.userId);
}

async function endTurn(reason){
  if(!state.roomCode || !state.turn) return;
  if(!isMyTurn()) return;

  state.turnEnding = true;
  updatePassRoundBtn();

  const nextSeat = getNextOccupiedSeatSkippingPassed(state.turn.activeSeat);
  if(nextSeat == null) return;

  const nextP = getPlayerBySeat(nextSeat);
  const turnRef = ref(db, `rooms/${state.roomCode}/game/turn`);
  await update(turnRef, {
    activeSeat: nextSeat,
    activePlayerId: nextP?.id || null,
    lastEndReason: reason,
    updatedAt: serverTimestamp(),
    turnNo: (state.turn.turnNo || 1) + 1,
  });
}

/* =========================
   ãƒ‡ãƒƒã‚­æ§‹ç¯‰ï¼ˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ï¼‰
   ========================= */
const ACTION_COUNTS_BASE = [
  { name:'ç›£ç¦', count:1, kind:'normal' },
  { name:'ç›—è´', count:1, kind:'normal' },
  { name:'ä¸–ä»£äº¤ä»£', count:1, kind:'normal' },
  { name:'å®£ä¼', count:1, kind:'normal' },

  { name:'å¼·å¥ª', count:2, kind:'normal' },
  { name:'åµå¯Ÿ', count:2, kind:'normal' },
  { name:'ã²ã‚‰ã‚ã', count:2, kind:'normal' },
  { name:'ä»•è¾¼ã¿', count:2, kind:'normal' },
  { name:'äº¤æ›', count:2, kind:'normal' },
  { name:'è©¦è¡ŒéŒ¯èª¤',     count:2, kind:'normal' },
  { name:'äº‹æ•…',     count:2, kind:'normal' },
  { name:'æ¿€æ¨ã—',     count:4, kind:'normal' },
  { name:'ç„¡è¦–', count:2, kind:'instruction' },


  { name:'å¿œæ´', count:4, kind:'instruction' },
  { name:'è³„è³‚', count:4, kind:'instruction' },
  { name:'è„…è¿«', count:4, kind:'instruction' },

];
const ACTION_COUNTS_7P = [
  { name:'å¼·å¥ª', count:1, kind:'normal' },
  { name:'åµå¯Ÿ', count:1, kind:'normal' },
  { name:'ã²ã‚‰ã‚ã', count:1, kind:'normal' },
  { name:'ä»•è¾¼ã¿', count:1, kind:'normal' },
  { name:'äº¤æ›', count:1, kind:'normal' },
  { name:'è©¦è¡ŒéŒ¯èª¤',     count:1, kind:'normal' },
  { name:'äº‹æ•…',     count:1, kind:'normal' },
  { name:'æ¿€æ¨ã—',     count:1, kind:'normal' },
  { name:'ç„¡è¦–', count:1, kind:'instruction' },


  { name:'å¿œæ´', count:1, kind:'instruction' },
  { name:'è³„è³‚', count:1, kind:'instruction' },
  { name:'è„…è¿«', count:1, kind:'instruction' },
];
const INSTRUCTION_NEED_TARGET = new Set(['å¿œæ´','è„…è¿«','è³„è³‚','ç„¡è¦–']);
const INSTRUCTION_CAN_SELF = new Set(['ç„¡è¦–']);

function cardNameToImg(name){
  if(name === '') return 'blank.jpg';
  return `${name}.jpg`;
}
function buildActionDeck(playerCount){
  const list = [];
  const counts = [...ACTION_COUNTS_BASE, ...(playerCount >= 7 ? ACTION_COUNTS_7P : [])];
  counts.forEach(def => {
    for(let i=0;i<def.count;i++){
      list.push({
        id: crypto.randomUUID(),
        name: def.name,
        kind: def.kind,
        img: cardNameToImg(def.name),
        backImg: `swactionura.jpg`,
        effectText: getActionEffectText(def.name),
      });
    }
  });
  return shuffle(list);
}
function getActionEffectText(cardName){
  const map = {
    'ç›£ç¦': 'é¸ã‚“ã ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‰ã«ç½®ã‹ã‚Œã¦ã„ã‚‹ã‚¹ã‚¤ãƒ¼ãƒ„ã¯å‡ºå“ã§ããªã„ã€‚',
    'ç›—è´': 'é¸ã‚“ã ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ­£ä½“ã‚«ãƒ¼ãƒ‰ã‚’è¦‹ã‚‹ã€‚',
    'ä¸–ä»£äº¤ä»£': 'ãƒªãƒ¼ãƒ€ãƒ¼ã«ãªã‚‹ã€‚',
    'å®£ä¼': 'é¸ã‚“ã ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚¤ãƒ¼ãƒ„ã‚’å…¬é–‹ã™ã‚‹ã€‚',
    'å¼·å¥ª': 'ç½®ã‹ã‚Œã¦ã„ã‚‹ä»»æ„ã®æŠ•ç¥¨ãƒãƒƒãƒ—ã‚’1ã¤ç§»å‹•ã•ã›ã‚‹ã€‚',
    'åµå¯Ÿ': 'é¸ã‚“ã ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’è¦‹ã‚‹ã€‚',
    'ã²ã‚‰ã‚ã': 'é™¤å¤–ã—ãŸå±±æœ­ã‹ã‚‰ã‚¹ã‚¤ãƒ¼ãƒ„ã‚’ä½œã‚‹ã€‚',
    'ä»•è¾¼ã¿': 'ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ã‚’1æšã²ãã€‚',
    'äº¤æ›': 'é¸ã‚“ã ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã‚¹ã‚¤ãƒ¼ãƒ„ã‚’äº¤æ›ã™ã‚‹ã€‚',
    'è©¦è¡ŒéŒ¯èª¤': 'ä¸€ç•ªä¸Šã®é™¤å¤–ã‚«ãƒ¼ãƒ‰ã‚’ãƒ¬ã‚·ãƒ”ã«åŠ ãˆã‚‹ã€‚ãã—ã¦ãƒ¬ã‚·ãƒ”ã‹ã‚‰1æšé¸ã‚“ã§é™¤å¤–ã™ã‚‹ã€‚',
    'æ¿€æ¨ã—': 'æ–°ãŸãªæŠ•ç¥¨ãƒãƒƒãƒ—ã‚’å¾—ã¦ã€æŠ•ç¥¨ã™ã‚‹ã€‚',
    'äº‹æ•…': 'é¸ã‚“ã ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚¤ãƒ¼ãƒ„ã‚’ãƒ¬ã‚·ãƒ”ã«æˆ»ã™ã€‚',
    'å¿œæ´': 'æ¸¡ã•ã‚ŒãŸã‚‰ã€æ¬¡ã®æ‰‹ç•ªã§ä¸€ç•ªæ•°å­—ãŒå¤§ãã„ã‚¹ã‚¤ãƒ¼ãƒ„ã‚’ä½œã‚‹ã€‚',
    'è„…è¿«': 'æ¸¡ã•ã‚ŒãŸã‚‰ã€æ¬¡ã®æ‰‹ç•ªã§ä¸€ç•ªæ•°å­—ãŒå°ã•ã„ã‚¹ã‚¤ãƒ¼ãƒ„ã‚’ä½œã‚‹ã€‚',
    'è³„è³‚': 'æ¸¡ã•ã‚ŒãŸã‚‰ã€æ¬¡ã®æ‰‹ç•ªã§å—ã‘å–ã£ãŸç›¸æ‰‹ã®ã‚¹ã‚¤ãƒ¼ãƒ„ã«æŠ•ç¥¨ã™ã‚‹ã€‚',
    'ç„¡è¦–': 'æ¸¡ã‚‰ã‚ŒãŸã‚‰ã€ä»–ã®æŒ‡ç¤ºã‚’ç„¡è¦–ã§ãã‚‹ã€‚è‡ªåˆ†ã§ä½¿ã£ãŸã‚‰ã€æ‰‹ç•ªãŒçµ‚ã‚ã‚‹ã€‚',
  };
  return map[cardName] ?? 'ï¼ˆåŠ¹æœã¯å¾Œã§ï¼‰';
}

/* =========================
   â˜… ã‚¹ã‚¤ãƒ¼ãƒ„ãƒ‡ãƒƒã‚­æ§‹ç¯‰
   ========================= */
const SWEETS_BACK_IMG = 'swsweetsura.jpg';

function buildSweetsPool(){
  const base = [
    { value:0, img:'sw0.jpg', fallback:'sw1.jpg' },
    { value:1, img:'sw1.jpg' },
    { value:2, img:'sw2.jpg' },
    { value:3, img:'sw3.jpg' },
    { value:3, img:'sw3(2).jpg' },
    { value:4, img:'sw4.jpg' },
    { value:4, img:'sw4(2).jpg' },
    { value:5, img:'sw5.jpg' },
    { value:5, img:'sw5(2).jpg' },
    { value:6, img:'sw6.jpg' },
    { value:7, img:'sw7.jpg' },
    { value:8, img:'sw8.jpg' },
  ];
  return base.map(b => ({
    id: crypto.randomUUID(),
    kind: 'sweets',
    value: b.value,
    name: String(b.value),
    img: b.img,
    backImg: SWEETS_BACK_IMG,
    fallback: b.fallback || null,
  }));
}
function buildSweetsDeck(playerCount){
  const pool = buildSweetsPool();
  return shuffle(pool);
}
function splitSweetsDeck(deck, playerCount){
  const total = Array.isArray(deck) ? deck.length : 0;
  const keepCount = clamp(playerCount + 2, 0, total);
  if(!Array.isArray(deck) || total <= keepCount){
    return { sweets: Array.isArray(deck) ? deck : [], excluded: [] };
  }
  const shuffled = shuffle([...deck]);
  return {
    sweets: shuffled.slice(0, keepCount),
    excluded: shuffled.slice(keepCount),
  };
}

/* =========================
   æ­£ä½“ã‚«ãƒ¼ãƒ‰é…å¸ƒ
   ========================= */
function buildRolePool(n){
  const usakoma = Math.ceil(n/2);
  const uragiri = Math.floor(n/2);
  const pool = [];
  for(let i=0;i<usakoma;i++) pool.push('usakoma');
  for(let i=0;i<uragiri;i++) pool.push('uragiri');
  return shuffle(pool);
}

/* =========================
   ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ˆãƒ›ã‚¹ãƒˆã®ã¿ï¼‰
   ========================= */
async function hostGameStart(){
  if(!state.isHost || !state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? {
      id: t.playerId,
      name: t.playerName || 'åç„¡ã—',
      seatIndex: Number(seatIndex)
    } : null))
    .filter(Boolean)
    .sort((a,b)=>a.seatIndex-b.seatIndex);

  if(players.length === 0) return;

  const seats = players.map(p=>p.seatIndex).sort((a,b)=>a-b);

  let actionDeck = buildActionDeck(players.length);
  const sweetsDeck = buildSweetsDeck(players.length);

  const hands = {};
  players.forEach(p => {
    hands[p.id] = {
      action: actionDeck.splice(0, 3),
      sweets: [],
      received: [],
      voteChips: 1,
    };
  });

  const pool = buildRolePool(players.length);
 const roles = {};
  players.forEach((p, i) => { roles[p.id] = pool[i]; });

  const base = `rooms/${state.roomCode}`;
  const gameSessionId = `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  await update(ref(db, `${base}/game`), { turn: null });
  await update(ref(db, `${base}`), { gameStarted: true });
  await remove(ref(db, `${base}/events`));
  await set(ref(db, `${base}/hands`), {});
  await set(ref(db, `${base}/roles`), {});
  await set(ref(db, `${base}/discard`), { action: [] });

  await set(ref(db, `${base}/decks`), { action: actionDeck, sweets: sweetsDeck, sweetsExcluded: [] });



  await Promise.all([
    set(ref(db, `${base}/hands`), hands),
    set(ref(db, `${base}/roles`), roles),
  ]);

  await set(ref(db, `${base}/votes`), {});
  await set(ref(db, `${base}/game`), {
    status: 'playing',
    startedAt: serverTimestamp(),
    sessionId: gameSessionId,
    seatOrder: seats,
    passes: {},               // â˜… ãƒ©ã‚¦ãƒ³ãƒ‰PASS
    roundEnding: false,       // â˜… ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ä¸­ãƒ•ãƒ©ã‚°
    roundPick: null,          // â˜… åŒç¥¨è§£æ±ºçŠ¶æ…‹
    leaderPick: null,         // â˜… ãƒªãƒ¼ãƒ€ãƒ¼ç§»è¡ŒçŠ¶æ…‹
    actionDealKey: null,      // â˜… ãƒªãƒ¼ãƒ€ãƒ¼é…å¸ƒã®é‡è¤‡é˜²æ­¢
    roundNo: 1,
    roundChips: {},
    turn: null

  });

  await emitEvent({ type: 'miniSweetsShuffleStart', reason: 'gameStart', sessionId: gameSessionId });

  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå…¨å“¡æ¼”å‡ºç”¨ï¼‰
   ========================= */
async function emitEvent(payload){
  if(!state.roomCode) return;
  const evRef = ref(db, `rooms/${state.roomCode}/events`);
  const sessionId = payload.sessionId ?? currentGameSessionId ?? state.game?.sessionId ?? null;
  const eventPayload = { ...payload, at: now() };
  if(sessionId) eventPayload.sessionId = sessionId;
  await push(evRef, eventPayload);
}


/* =========================
   ä¸­å¤®æ‹¡å¤§ï¼ˆå…¨å“¡1ç§’ï¼‰
   ========================= */
let revealTimer = null;
function showReveal(card){
  if(!card) return;
  revealImg.src = card.img || '';
  revealLabel.textContent = card.name || '';
  const isActionCard = card.kind === 'normal' || card.kind === 'instruction';
  revealLabel.classList.toggle('hidden', isActionCard || !card.name);
  const effectText = card.effectText || card.text || '';
  revealEffect.textContent = effectText;
  revealEffectFrame.classList.toggle('hidden', !effectText);
  revealOverlay.classList.remove('hidden');
  if(revealTimer) clearTimeout(revealTimer);
  revealTimer = setTimeout(()=>{
    revealOverlay.classList.add('hidden');
  }, 1800);
}







/* =========================
   æŒ‡ç¤ºã‚«ãƒ¼ãƒ‰ï¼šè£ã‚«ãƒ¼ãƒ‰ç§»å‹•ã‚¢ãƒ‹ãƒ¡ï¼ˆå…¨å“¡ï¼‰
   ========================= */
function animateFlyBackCard(fromSeat, toSeat){
  const fromEl = document.querySelector(`.player-tag[data-seat="${fromSeat}"]`);
  const toEl   = document.querySelector(`.player-tag[data-seat="${toSeat}"]`);
  if(!fromEl || !toEl) return;

  const fr = fromEl.getBoundingClientRect();
  const tr = toEl.getBoundingClientRect();

  const fly = document.createElement('div');
  fly.className = 'fly-card';
  fly.style.left = `${fr.right + 6}px`;
  fly.style.top  = `${fr.top + fr.height/2 - 16}px`;
  document.body.appendChild(fly);

  const toX = (tr.right + 6) - (fr.right + 6);
  const toY = (tr.top + tr.height/2 - 16) - (fr.top + fr.height/2 - 16);

  fly.animate([
    { transform:`translate(0px,0px) scale(1)`, opacity:1 },
    { transform:`translate(${toX}px,${toY}px) scale(1.05)`, opacity:1 }
  ], {
    duration: 520,
    easing: 'cubic-bezier(.22,.84,.44,1)'
  }).onfinish = () => fly.remove();
}

/* =========================
   æ–‡å­—ã‚’æ å†…ã«åã‚ã‚‹
   ========================= */
function fitEffectText(el){
  if(!el) return;
  const box = el.parentElement;
  if(!box) return;

  const styles = getComputedStyle(box);
  const paddingTop = parseFloat(styles.paddingTop) || 0;
  const paddingBottom = parseFloat(styles.paddingBottom) || 0;
  const availableHeight = box.clientHeight - paddingTop - paddingBottom;

  const maxSize = 13;
  const minSize = 6;
  let size = maxSize;
  el.style.fontSize = size + 'px';

  while(size > minSize && el.scrollHeight > availableHeight){
    size -= 1;
    el.style.fontSize = size + 'px';
  }
}

/* =========================
   â˜… å—ã‘å–ã‚ŠæŒ‡ç¤ºã‚«ãƒ¼ãƒ‰
   ========================= */
function getMyReceivedCard(){
  const myData = state.hands?.[state.userId];
  const rec = myData?.received;
  if(Array.isArray(rec) && rec.length) return rec[0];
  return null;
}
function hasReceivedInstruction(){
  return !!getMyReceivedCard();
}


/* =========================
   â˜… ã‚¹ã‚¤ãƒ¼ãƒ„å›åï¼ˆæ‹¡å¤§è¡¨ç¤ºçµ‚äº†å¾Œï¼‰
   - å ´ã®ã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆselected / éselectedï¼‰ã‚’å±±æœ­ã¸
   - ãã®ç›´å¾Œã€é™¤å¤–æœ­ã¯ç¸¦ã«ãªã£ã¦å±±æœ­ã¸
   ========================= */

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

async function waitUntilHidden(el, timeoutMs = 4500){
  const start = Date.now();
  while(Date.now() - start < timeoutMs){
    if(!el || el.classList.contains('hidden')) return;
    await sleep(50);
  }
}

function isVisibleRect(el){
  if(!el) return false;
  const r = el.getBoundingClientRect();
  return !!(r.width && r.height);
}

function isFieldElement(el){
  if(!el) return false;
  // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä¸­ã®ã‚«ãƒ¼ãƒ‰ã¯å¯¾è±¡å¤–
  if(el.closest('#roundRevealOverlay')) return false;
  if(el.closest('#revealOverlay')) return false;
  if(el.closest('#sweetsBackdrop')) return false;
  return isVisibleRect(el);
}

function getSweetsDeckTargetRect(){
  if(!sweetsDeckUI) return null;
  const r = sweetsDeckUI.getBoundingClientRect();
  if(!r.width || !r.height) return null;
  return {
    x: r.left + r.width/2,
    y: r.top + r.height/2,
    w: r.width,
    h: r.height,
    raw: r
  };
}

function getCollectAnimationSnapshot(el){
  if(!el) return null;
  const rect = el.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  const width = el.offsetWidth || rect.width;
  const height = el.offsetHeight || rect.height;
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  const hostCircle = el.closest('.otherplayerscircle');
  const rotValue = hostCircle ? getComputedStyle(hostCircle).getPropertyValue('--rotDeg').trim() : '0deg';
  const rotateDeg = parseRotationDegrees(rotValue);

  return {
    left: centerX - width / 2,
    top: centerY - height / 2,
    width,
    height,
    rotateDeg,
  };
}

function normalizeRotationDegrees(fromDeg, toDeg){
  const from = Number.isFinite(fromDeg) ? fromDeg : 0;
  const to = Number.isFinite(toDeg) ? toDeg : 0;
  const diff = ((from - to + 540) % 360) - 180;
  return to + diff;
}

function animateOneCardToDeck(srcRect, target, { delay = 0, rotateFrom = 0, rotateTo = 0 } = {}){
  if(!srcRect || !srcRect.width || !srcRect.height || !target) return Promise.resolve();

  const fly = document.createElement('div');
  fly.className = 'collect-card';
  fly.style.left = `${srcRect.left}px`;
  fly.style.top  = `${srcRect.top}px`;
  fly.style.width  = `${srcRect.width}px`;
  fly.style.height = `${srcRect.height}px`;
  fly.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  fly.style.zIndex = '999999';
  document.body.appendChild(fly);

  const dx = target.x - (srcRect.left + srcRect.width/2);
  const dy = target.y - (srcRect.top  + srcRect.height/2);

  const scaleX = target.w / srcRect.width;
  const scaleY = target.h / srcRect.height;
  const scale  = Math.min(scaleX, scaleY);

  const normalizedRotateFrom = normalizeRotationDegrees(rotateFrom, rotateTo);

  return new Promise(resolve => {
    fly.animate([
      { transform:`translate(0px,0px) rotate(${normalizedRotateFrom}deg) scale(1)`, opacity:1 },
      { transform:`translate(0px,0px) rotate(${rotateTo}deg) scale(1)`, opacity:1, offset:0.55 },
      { transform:`translate(${dx}px,${dy}px) rotate(${rotateTo}deg) scale(${scale})`, opacity:0.92 },
    ],{
      duration: 780,
      delay,
      easing: 'cubic-bezier(.22,.84,.44,1)',
      fill: 'forwards'
    }).onfinish = () => {
      fly.remove();
      resolve();
    };
  });
}

async function animateReturnAllFieldSweetsToDeck(){

  // ã€Œæ‹¡å¤§å…¬é–‹ãŒå®Ÿè¡Œæ¸ˆã¿ & çµ‚äº†æ¸ˆã¿ã€ã‚’å¾…ã¤
  const revealDone = await waitForRoundRevealCompletion();
  if(!revealDone) return;
  await sleep(800);

  const target = getSweetsDeckTargetRect();
  if(!target) return;

  const sources = [];

  // 1) selectedï¼ˆãƒãƒ¼ãƒ ã‚¿ã‚°ä¸Šã® selected-sweets-cardï¼‰
  document.querySelectorAll('.selected-sweets-card').forEach(cardEl => {
    if(!isFieldElement(cardEl)) return;
    sources.push({
      el: cardEl,
      host: cardEl.closest('.selected-sweets-tag') || cardEl,
      uid: (cardEl.closest('.selected-sweets-tag')?.dataset?.sweetsUid) || null
    });
  });

  // 2) éselectedï¼ˆä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã® sweets-wrap å†… sweets-miniï¼‰
  document.querySelectorAll('.sweets-wrap .sweets-mini').forEach(miniEl => {
    if(!isFieldElement(miniEl)) return;
    sources.push({
      el: miniEl,
      host: miniEl.closest('.sweets-wrap') || miniEl,
      uid: (miniEl.closest('.sweets-wrap')?.dataset?.sweetsUid) || null
    });
  });

  // 3) è‡ªåˆ†ã®ã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆæ‰‹å…ƒè¡¨ç¤ºãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã‚‚å›åï¼‰
  const myImg = mySweetsEl?.querySelector('img');
  if(myImg && isFieldElement(myImg)){
    sources.push({
      el: myImg,
      host: mySweetsEl,
      uid: state.userId || null
    });
  }

  if(!sources.length) return;

  // ãƒ•ãƒªãƒƒã‚«ãƒ¼é˜²æ­¢ï¼šrenderå´ã§ã‚‚æ¶ˆãˆã‚‹ã‚ˆã†ã«ï¼ˆæ—¢å­˜ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’åˆ©ç”¨ï¼‰
  sources.forEach(s => { if(s.uid) collectedSweetsHidden.add(s.uid); });

  // å…ƒDOMã‚’å…ˆã«ä¸å¯è¦–åŒ–ï¼ˆå›åä¸­ã«äºŒé‡ã«è¦‹ãˆãªã„ã‚ˆã†ã«ï¼‰
  sources.forEach(s => {
    if(s.host?.classList) s.host.classList.add('collect-hidden');
    else if(s.el) s.el.style.visibility = 'hidden';
  });

  // å›åã‚¢ãƒ‹ãƒ¡ï¼ˆå°‘ã—ã ã‘ã‚ºãƒ©ã—ã¦æ°—æŒã¡ã‚ˆãï¼‰
  const tasks = sources.map((s, i) => {
    const snapshot = getCollectAnimationSnapshot(s.el);
    if(!snapshot) return Promise.resolve();
    return animateOneCardToDeck(snapshot, target, { delay: i * 35, rotateFrom: snapshot.rotateDeg, rotateTo: 0 });
  });

  await Promise.all(tasks);
}

async function animateReturnExcludedDeckToSweetsDeck(){
  // ã€Œãã®ç›´å¾Œã€
  await sleep(30);

  // é™¤å¤–ãŒç„¡ã„ãªã‚‰ä½•ã‚‚ã—ãªã„
  const excludedDeck = state.room?.decks?.sweetsExcluded;
  const liveExcluded = Array.isArray(excludedDeck) ? excludedDeck.length : 0;
  const excludedCount = (sweetsExcludedCountOverride ?? liveExcluded);
  if(excludedCount <= 0) return;

  const target = getSweetsDeckTargetRect();
  if(!target) return;

  if(!sweetsExcludedDeckUI || !isVisibleRect(sweetsExcludedDeckUI)) return;
  const exRect = sweetsExcludedDeckUI.getBoundingClientRect();

  // UIã‚’ä¸€ç¬éš ã—ã¦ã€Œé£›ã¶1æšã€ã ã‘è¦‹ã›ã‚‹ï¼ˆè¦‹ãŸç›®é‡è¤‡é˜²æ­¢ï¼‰
  const prevVis = sweetsExcludedDeckUI.style.visibility;
  sweetsExcludedDeckUI.style.visibility = 'hidden';

  // æ¨ª(90deg) â†’ ç¸¦(0deg) ã«ãªã‚Šã¤ã¤å±±æœ­ã¸
  await animateOneCardToDeck(exRect, target, { delay: 0, rotateFrom: 90, rotateTo: 0 });

  sweetsExcludedDeckUI.style.visibility = prevVis;
}

// âœ… ãƒ›ã‚¹ãƒˆã ã‘ï¼šãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†å¾Œã«ã€Œå…¨ã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆselected/éselected/æ‰‹å…ƒï¼‰ï¼‹é™¤å¤–ã€ã‚’DBä¸Šã§å±±æœ­ã¸æˆ»ã™
async function hostFinalizeReturnSweetsToDeck(revealedCards = []){
  if(!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;

  // æœ€æ–°ã‚’å–ã‚Šç›´ã™ï¼ˆstateã®ã‚ºãƒ¬å¯¾ç­–ï¼‰
  const [handsSnap, decksSnap, votesSnap, tablesSnap, gameSnap] = await Promise.all([
    get(ref(db, `${base}/hands`)),
    get(ref(db, `${base}/decks`)),
    get(ref(db, `${base}/votes`)),
    get(ref(db, `${base}/tables`)),
    get(ref(db, `${base}/game`)),
  ]);

  const gameNow = gameSnap.val() || {};


  const hands = handsSnap.val() || {};
  const decks = decksSnap.val() || {};
  const votes = votesSnap.val() || {};
  const tables = tablesSnap.val() || {};
  const deckSweets = Array.isArray(decks.sweets) ? decks.sweets : [];
  const excluded   = Array.isArray(decks.sweetsExcluded) ? decks.sweetsExcluded : [];

  // è¿”ã™ã‚«ãƒ¼ãƒ‰ã‚’ã€Œidã€ã§ãƒ¦ãƒ‹ãƒ¼ã‚¯åŒ–ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
  const returned = new Map();
  const add = (c) => {
    if(!c || !c.id) return;
    if(!returned.has(c.id)) returned.set(c.id, c);
  };

  // â‘  ã‚¤ãƒ™ãƒ³ãƒˆã§å…¬é–‹ã•ã‚ŒãŸã‚«ãƒ¼ãƒ‰ï¼ˆselected/éselectedã®å®Ÿä½“ã«ãªã£ã¦ã„ã‚‹æƒ³å®šï¼‰
  (Array.isArray(revealedCards) ? revealedCards : []).forEach(add);

  // â‘¡ hands ã«æ®‹ã£ã¦ã„ã‚‹ã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆæ‰‹å…ƒå«ã‚€ï¼‰ã‚‚å…¨éƒ¨å›åï¼ˆã“ã‚ŒãŒæšæ•°ä¸è¶³ã®ä¸»å› ï¼‰
  Object.values(hands).forEach(h => {
    const arr = h?.sweets;
    if(Array.isArray(arr)) arr.forEach(add);
  });

  // â‘¢ é™¤å¤–ã‚‚å±±æœ­ã¸æˆ»ã™ï¼ˆä»Šå›ã®ä»•æ§˜ï¼‰
  excluded.forEach(add);

  const returnedIds = new Set(returned.keys());

  // æ—¢ã«å±±æœ­ã«ç´›ã‚Œè¾¼ã‚“ã§ã„ãŸå ´åˆã§ã‚‚äºŒé‡åŒ–ã—ãªã„ã‚ˆã†ã€å…ˆã«é™¤å»ã—ã¦ã‹ã‚‰è¶³ã™
  const baseDeck = deckSweets.filter(c => !(c && c.id && returnedIds.has(c.id)));
  const newDeck  = shuffle([...baseDeck, ...Array.from(returned.values())]);

  // hands ã® sweets ã‚’å…¨å“¡ã¶ã‚“ç©ºã«ã™ã‚‹
  for(const uid of Object.keys(hands)){
    if(hands[uid] && Array.isArray(hands[uid].sweets)){
      hands[uid].sweets = [];
    }
  }

  // DBåæ˜ ï¼ˆdecksã¯éƒ¨åˆ†æ›´æ–°ã§OKï¼‰
  const leaderSeatNow = gameNow.turn?.leaderSeat ?? null;
  const leaderId = leaderSeatNow != null ? (tables?.[leaderSeatNow]?.playerId ?? null) : null;
  const voteCounts = Object.entries(votes)
    .map(([uid, voters]) => ({
      uid,
      count: (voters && typeof voters === 'object') ? Object.keys(voters).length : 0,
    }))
    .filter(entry => entry.count > 0);
  const maxVotes = voteCounts.length ? Math.max(...voteCounts.map(v => v.count)) : 0;
  const topVoteUids = voteCounts.filter(v => v.count === maxVotes).map(v => v.uid);
  const leaderPickStartAt = Date.now();
  let leaderPickPayload = null;
  if(topVoteUids.length === 1){
    leaderPickPayload = {
      phase: 'auto',
      decidedId: topVoteUids[0],
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }else if(topVoteUids.length === 2 && leaderId && topVoteUids.includes(leaderId)){
    const nextLeaderId = topVoteUids.find(uid => uid !== leaderId);
    leaderPickPayload = {
      phase: 'auto',
      decidedId: nextLeaderId || null,
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }else if(topVoteUids.length >= 2){
    leaderPickPayload = {
      phase: 'choose',
      candidates: topVoteUids,
      leaderId,
      leaderSeat: leaderSeatNow,
      startAt: leaderPickStartAt,
    };
  }

  await update(ref(db, base), {
    'hands': hands,
    'decks/sweets': newDeck,
    'decks/sweetsExcluded': [],   // é™¤å¤–ã¯ç©ºã«
    'game/leaderPick': leaderPickPayload,
    'game/actionDealKey': null,
    /* âœ… è¿½åŠ ï¼šã“ã“ã‹ã‚‰å‹æ•—åˆ¤å®šâ†’roundchipâ†’round+1 */
    ...( (() => {
      const playerCount = Array.isArray(gameNow.seatOrder) ? gameNow.seatOrder.length : (latestPlayers?.length || 0);
      const currentRound = (typeof gameNow.roundNo === 'number') ? gameNow.roundNo : 1;

      const pts = calcSweetsTotalPoints(revealedCards);          // é¸ã°ã‚ŒãŸã‚¹ã‚¤ãƒ¼ãƒ„åˆè¨ˆç‚¹
      const th  = getRoundWinThreshold(playerCount || 1, currentRound);
      const win = pts >= th;

      // roundchipã¯1ã€œ3ã®ã‚¹ãƒ­ãƒƒãƒˆã«ã®ã¿æç”»ï¼ˆã‚­ãƒ¼ã¯ "1","2","3" ã§æŒã¤ï¼‰
      const prev = (gameNow.roundChips && typeof gameNow.roundChips === 'object') ? gameNow.roundChips : {};
      const nextChips = { ...prev };
      if(currentRound >= 1 && currentRound <= 3){
        nextChips[String(currentRound)] = win ? 'winchip.png' : 'losechip.png';
      }

      return {
        'game/roundChips': nextChips,
        'game/roundNo': currentRound + 1,          // å‡¦ç†ãŒçµ‚ã‚ã£ãŸå¾Œã§ +1
        'game/lastRoundPoints': pts,               // ï¼ˆä»»æ„ï¼šãƒ‡ãƒãƒƒã‚°ç”¨ã€‚ä¸è¦ãªã‚‰æ¶ˆã—ã¦OKï¼‰
        'game/lastRoundThreshold': th,             // ï¼ˆä»»æ„ï¼šãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
      };
    })() )

  });

  if(!leaderPickPayload){
    await set(ref(db, `${base}/votes`), {});
  }
}


/* =========================
   â˜… æŠ•ç¥¨ï¼ˆãƒãƒƒãƒ—è¡¨ç¤ºï¼†æ¡ä»¶ï¼‰
   ========================= */
function getMyVoteChips(){
  const myData = state.hands?.[state.userId] || {};
  const v = myData.voteChips;
  return (typeof v === 'number') ? v : 1;
}
function getPlayerVoteChips(uid){
  const data = state.hands?.[uid] || {};
  const v = data.voteChips;
  return (typeof v === 'number') ? v : 1;
}
function getSweetsOwners(){
  return latestPlayers
    .filter(p => {
      const hd = state.hands?.[p.id];
      return !!(hd && Array.isArray(hd.sweets) && hd.sweets.length);
    })
    .map(p => p.id);
}
function canVoteNow(){
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(hasReceivedInstruction()) return false;
  if(getMyVoteChips() <= 0) return false;
  return getSweetsOwners().length >= 1;
}
function renderMyVoteChip(){
  const started = !!state.room?.gameStarted;
  if(!started){
    myVoteChipEl.classList.add('hidden');
    myVoteChipEl.classList.remove('pulsing');
    return;
  }

  const chips = getMyVoteChips();
 myVoteChipEl.classList.toggle('hidden', chips <= 0);
  myVoteChipEl.classList.toggle('pulsing', canVoteNow());
}

let lastVoteSnapshot = null;
function getVoteSnapshot(votesObj){
  const snapshot = new Map();
  const votes = votesObj && typeof votesObj === 'object' ? votesObj : {};
  Object.entries(votes).forEach(([targetUid, voters]) => {
    if(!voters || typeof voters !== 'object') return;
    snapshot.set(targetUid, new Set(Object.keys(voters)));
  });
  return snapshot;
}
function getNewVotes(prev, next){
  const diffs = [];
  if(!prev) return diffs;
  next.forEach((voters, targetUid) => {
    voters.forEach(voterUid => {
      const prevSet = prev.get(targetUid);
      if(!prevSet || !prevSet.has(voterUid)){
        diffs.push({ voterUid, targetUid });
      }
    });
  });
  return diffs;
}
function getVoteChipSizePx(){
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--voteMiniSize'));
  return Number.isFinite(size) ? size : 14;
}
function buildVoteStackEl(targetUid){
  const vCount = getVoteCountFor(targetUid);
  if(vCount <= 0) return null;
  const voteStack = document.createElement('div');
  voteStack.className = 'vote-stack';
  voteStack.dataset.targetUid = targetUid;
  for(let i=0;i<vCount;i++){
    const v = document.createElement('div');
    v.className = 'vote-mini';
    voteStack.appendChild(v);
  }
  return voteStack;
}
function getVoteChipSourceRect(voterUid){
  const tag = document.querySelector(`.player-tag[data-uid="${voterUid}"]`);
  if(!tag) return null;
  const chip = tag.querySelector(`.other-vote-chip[data-voter-uid="${voterUid}"]`);
  if(chip){
    const rect = chip.getBoundingClientRect();
    return {
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
    };
  }
  const roleMini = tag.querySelector('.role-mini');
  const size = getVoteChipSizePx();
  if(roleMini){
    const rect = roleMini.getBoundingClientRect();
    return {
      left: rect.right - 6 - size,
      top: rect.bottom - 6 - size,
      width: size,
      height: size,
    };
  }
  return null;
}
function getVoteChipTargetInfo(targetUid){
  const stack = document.querySelector(`.vote-stack[data-target-uid="${targetUid}"]`);
  if(!stack) return null;
  const rect = stack.getBoundingClientRect();
  const size = getVoteChipSizePx();
  return {
    stack,
    rect: {
      left: rect.left + (rect.width - size) / 2,
      top: rect.top + (rect.height - size) / 2,
      width: size,
      height: size,
    },
  };
}
function animateVoteChipFly(voterUid, targetUid){
  if(voterUid === state.userId) return;
  const source = getVoteChipSourceRect(voterUid);
  const targetInfo = getVoteChipTargetInfo(targetUid);
  if(!source || !targetInfo) return;
  const { stack, rect: target } = targetInfo;

  const fly = document.createElement('div');
  fly.className = 'vote-chip-fly';
  fly.style.left = `${source.left}px`;
  fly.style.top = `${source.top}px`;
  fly.style.width = `${source.width}px`;
  fly.style.height = `${source.height}px`;
  document.body.appendChild(fly);

  const dx = target.left - source.left;
  const dy = target.top - source.top;
  stack.classList.add('animating');
  fly.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: 600,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    fly.remove();
    stack.classList.remove('animating');
  };
}
function scheduleVoteChipAnimations(){
  const current = getVoteSnapshot(state.room?.votes || {});
  if(!lastVoteSnapshot){
    lastVoteSnapshot = current;
    return;
  }
  const newVotes = getNewVotes(lastVoteSnapshot, current);
  lastVoteSnapshot = current;
  if(!newVotes.length) return;
  requestAnimationFrame(() => {
    newVotes.forEach(({ voterUid, targetUid }) => {
      animateVoteChipFly(voterUid, targetUid);
    });
  });
}



/* =========================
   â˜…â˜…â˜… PASSãƒœã‚¿ãƒ³è¡¨ç¤ºæ¡ä»¶ï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰ç”¨ï¼‰
   - è‡ªåˆ†ã®æ‰‹ç•ª
   - è‡ªåˆ†ãŒã‚¹ã‚¤ãƒ¼ãƒ„ç²å¾—æ¸ˆã¿
   - è‡ªåˆ†ã®æŠ•ç¥¨ãŒæ¸ˆã¿ï¼ˆvoteChips <= 0ï¼‰
   - å—ã‘å–ã‚ŠæŒ‡ç¤ºãªã—
   - ã¾ã è‡ªåˆ†ãŒPASSã—ã¦ã„ãªã„
   ========================= */
function myDoneSweetsAndVote(){
  return hasSweets() && (getMyVoteChips() <= 0);
}
function syncPassTurnState(){
  const turnNo = state.turn?.turnNo ?? null;
  if(turnNo !== state.prevTurnNo){
    state.prevTurnNo = turnNo;
    state.passReadyBlockedTurnNo = null;
    state.lastPassEligible = false;
    if(isMyTurn()){
      state.lastPassEligible = myDoneSweetsAndVote() && !hasReceivedInstruction();
    }
  }
}
function updatePassRoundBtn(){
  const started = !!state.room?.gameStarted;
  const mine = isMyTurn();
  const passed = isPassedPlayerId(state.userId);
  const ending = !!state.game?.roundEnding;
  const eligible = myDoneSweetsAndVote() && !hasReceivedInstruction();
  if(mine){
    if(!state.lastPassEligible && eligible){
      state.passReadyBlockedTurnNo = state.turn?.turnNo ?? null;
    }
    state.lastPassEligible = eligible;
  } else {
    state.lastPassEligible = false;
  }
  const show = started && mine && !ending && !passed && !state.turnEnding && eligible && state.passReadyBlockedTurnNo !== state.turn?.turnNo;
  passRoundBtn.classList.toggle('visible', show);
  passRoundBtn.disabled = !show;
}

/* =========================
   æ‰‹æœ­ãƒ¬ãƒ³ãƒ€ãƒ¼
   ========================= */
function renderMyRole(){
  const started = !!state.room?.gameStarted;
  if(!started){
    myRoleEl.classList.add('hidden');
    myRoleEl.innerHTML = '';
    return;
  }

  const myRole = state.roles?.[state.userId];
  if(!myRole){
    myRoleEl.classList.add('hidden');
    myRoleEl.innerHTML = '';
    return;
  }
  const info = roleToHelp(myRole);
  myRoleEl.classList.remove('hidden');
  myRoleEl.innerHTML = '';
  const img = document.createElement('img');
  img.src = info.img;
  img.alt = info.name;
  myRoleEl.appendChild(img);
}

function renderMySweets(){
  mySweetsEl.innerHTML = '';
  const c = getMySweetsCard();
  if(!c){
    mySweetsEl.classList.add('hidden');
    updateRoundPickUI();
    lastMySweetsSnapshot = null;
    mySweetsFlyAnimatedFor = null;
    return;
  }
  if(collectedSweetsHidden.has(state.userId)){
    mySweetsEl.classList.add('hidden');
    mySweetsEl.innerHTML = '';
    updateRoundPickUI();
    return;
  }
  const decidedUids = getDecidedSweetsUids();
  if(decidedUids.includes(state.userId)){
    mySweetsEl.classList.add('hidden');
    mySweetsEl.innerHTML = '';
    updateRoundPickUI();
    return;
  }
  mySweetsFlyAnimatedFor = null;
  mySweetsEl.classList.remove('hidden');
  const img = document.createElement('img');
  img.src = c.img;
  img.alt = `sweets ${c.value ?? ''}`;
  img.onerror = () => { if(c.fallback) img.src = c.fallback; };
  mySweetsEl.appendChild(img);

  // â˜… è¿½åŠ ï¼šè‡ªåˆ†ã‚¹ã‚¤ãƒ¼ãƒ„ã«ã‚‚æŠ•ç¥¨ãƒŸãƒ‹ã‚’é‡ã­ã‚‹
  renderMySweetsVoteStack();

  updateRoundPickUI();
  requestAnimationFrame(cacheMySweetsSnapshot);
}

/* â˜… ã‚«ãƒ¼ãƒ‰DOMã‚’ä½œã‚‹å…±é€š */
function buildCardEl(cardObj, { extraClass='' } = {}){
  const card = document.createElement('div');
  card.className = 'action-card' + (extraClass ? ` ${extraClass}` : '');
  card.dataset.cardId = cardObj.id;

  const img = document.createElement('img');
  img.className = 'card-img';
  img.src = cardObj.img;
  img.alt = cardObj.name;

  const name = document.createElement('div');
  name.className = 'card-name';
  name.textContent = cardObj.name;

  const frame = document.createElement('div');
  frame.className = 'effect-frame';

  const txt = document.createElement('div');
  txt.className = 'effect-text';
  txt.textContent = cardObj.effectText || '';
  frame.appendChild(txt);

  card.appendChild(img);
  card.appendChild(name);
  card.appendChild(frame);

  requestAnimationFrame(()=> fitEffectText(txt));
  return card;
}

function renderMyReceived(){
  myReceivedEl.innerHTML = '';
  const rec = getMyReceivedCard();
  if(!rec) return;

  const cardEl = buildCardEl(rec, { extraClass:'pulse-only' });
  cardEl.addEventListener('pointerdown', (e) => startDragCard(e, rec, cardEl));
  myReceivedEl.appendChild(cardEl);
}

function renderMyHand(){
  myHandEl.innerHTML = '';

  const myData = state.hands?.[state.userId];
  if(!myData || !Array.isArray(myData.action)) return;

  const receivedExists = hasReceivedInstruction();

  myData.action.forEach(cardObj => {
    const allowThisCard =
      !receivedExists || (cardObj.kind === 'instruction' && cardObj.name === 'ç„¡è¦–');

    const cardEl = buildCardEl(cardObj);
    if(receivedExists && cardObj.kind === 'instruction' && cardObj.name === 'ç„¡è¦–'){
      cardEl.classList.add('can-ignore');
    }

    cardEl.addEventListener('pointerdown', (e) => {
      if(!allowThisCard) return;
      startDragCard(e, cardObj, cardEl);
    });

    myHandEl.appendChild(cardEl);
  });
}

function applyMyTurnClasses(){
  const wrap = document.querySelector('.my-hand-wrapper');
  if(!wrap) return;

  const mine = isMyTurn();
  const receivedExists = hasReceivedInstruction();
  const roundPickActive = getRoundPick()?.phase === 'choose';

  wrap.classList.remove('my-turn-free','my-turn-blocked');
  if(!mine || roundPickActive) return;

  if(receivedExists){
    wrap.classList.add('my-turn-blocked');
  }else{
    wrap.classList.add('my-turn-free');
  }
}

function renderHands(){
  renderMyRole();
  renderMySweets();
  renderMyReceived();
  renderMyHand();
  applyMyTurnClasses();
  updateSweetsDeckUI();
  renderMyVoteChip();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  updatePassRoundBtn();
}

/* =========================
   ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å††ãƒ¬ãƒ³ãƒ€ãƒ¼
   ========================= */
let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;

function renderMySweetsVoteStack(){
  // ã‚¹ã‚¤ãƒ¼ãƒ„æœªæ‰€æŒãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆï¼†æ®‹éª¸ãŒã‚ã‚Œã°æ¶ˆã™ï¼‰
  const c = getMySweetsCard();
  const old = mySweetsEl.querySelector('.vote-stack');
  if(old) old.remove();
  if(!c) return;

  const vCount = getVoteCountFor(state.userId);
  if(vCount <= 0) return;

  const voteStack = document.createElement('div');
  voteStack.className = 'vote-stack';
  voteStack.dataset.targetUid = state.userId;

  for(let i=0;i<vCount;i++){
    const v = document.createElement('div');
    v.className = 'vote-mini';
    voteStack.appendChild(v);
  }
  mySweetsEl.appendChild(voteStack);
}


function getVoteCountFor(targetUid){
  const obj = state.room?.votes?.[targetUid] || {};
  return Object.keys(obj).length;
}

function roundedStarPath({R=45, r2=20, round=14, k=0.65, points=5}){
  const pts = [];
  for(let i=0;i<points*2;i++){
    const ang = -Math.PI/2 + i*Math.PI/points;
    const rad = (i%2===0) ? R : r2;
    pts.push({x: Math.cos(ang)*rad, y: Math.sin(ang)*rad, outer: i%2===0});
  }

  const prev0 = pts[pts.length-1], cur0 = pts[0];
  const A0 = insetPoint(prev0, cur0, round);
  let d = `M ${A0.x.toFixed(2)} ${A0.y.toFixed(2)} `;

  for(let i=0;i<pts.length;i++){
    const prev = pts[(i-1+pts.length)%pts.length];
    const cur  = pts[i];
    const next = pts[(i+1)%pts.length];

    if(!cur.outer){
      d += `L ${cur.x.toFixed(2)} ${cur.y.toFixed(2)} `;
      continue;
    }

    const A = insetPoint(prev, cur, round);
    const B = insetPoint(next, cur, round);

    d += `L ${A.x.toFixed(2)} ${A.y.toFixed(2)} `;

    const C1 = { x: A.x + (cur.x - A.x)*k, y: A.y + (cur.y - A.y)*k };
    const C2 = { x: B.x + (cur.x - B.x)*k, y: B.y + (cur.y - B.y)*k };

    d += `C ${C1.x.toFixed(2)} ${C1.y.toFixed(2)} `
      +  `${C2.x.toFixed(2)} ${C2.y.toFixed(2)} `
      +  `${B.x.toFixed(2)} ${B.y.toFixed(2)} `;
  }

  d += "Z";
  return d;

  function insetPoint(target, cur, dist){
    const vx = target.x - cur.x, vy = target.y - cur.y;
    const n = Math.hypot(vx, vy) || 1;
    return { x: cur.x + (vx/n)*dist, y: cur.y + (vy/n)*dist };
  }
}

function createRoundedStarSvg(){
  const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
  svg.setAttribute("class","sweets-number-star");
  svg.setAttribute("viewBox","-60 -60 120 120");
  svg.setAttribute("aria-hidden","true");

  const path = document.createElementNS("http://www.w3.org/2000/svg","path");
  path.setAttribute("d", roundedStarPath({R:45, r2:20, round:30, k:0.88}));
  path.setAttribute("fill", "#fde047");
  path.setAttribute("stroke", "#111");
  path.setAttribute("stroke-width", "3");
  path.setAttribute("stroke-linejoin", "round");
  path.setAttribute("stroke-linecap", "round");

  svg.appendChild(path);
  return svg;
}
const decidedSweetsAnimated = new Map();
const DECIDED_MOVE_DURATION_MS = 650;
const DECIDED_CENTER_DELAY_MS = DECIDED_MOVE_DURATION_MS + 1800;
const DECIDED_CENTER_MOVE_DURATION_MS = 650;
const decidedCenterMoveAnimated = new Map();
const decidedCenterMoveTimers = new Map();
let centerMoveBatchTimerId = null;
let centerMoveBatchKey = null;
let decidedRoundKey = null;
let decidedRoundStartAt = null;
let lastMySweetsSnapshot = null;
let mySweetsFlyAnimatedFor = null;

function hasCompletedDecidedMove(uid){
  const ts = decidedSweetsAnimated.get(uid);
  if(typeof ts !== 'number') return false;
  return (Date.now() - ts) > DECIDED_MOVE_DURATION_MS;
}

function applyDecidedSweetsMove(items){
  if(!Array.isArray(items) || !items.length) return;
  const playRect = playCircleEl?.getBoundingClientRect?.();
  if(!playRect || !playRect.width || !playRect.height) return;
  const decidedStartAt = getDecidedStartAtForUids(items.map(item => item.uid).filter(Boolean));

  const playCenter = {
    x: playRect.left + playRect.width / 2,
    y: playRect.top + playRect.height / 2,
  };
  const decidedMoveDistance = 80;

  items.forEach(({ uid, sweetsWrap, circle, rotDeg, skipMove }) => {
    if(!sweetsWrap || !circle) return;
    const alreadyAnimated = uid && decidedSweetsAnimated.has(uid);
    const circleRect = circle.getBoundingClientRect();
    const sweetsRect = sweetsWrap.getBoundingClientRect();
    if(!circleRect.width || !circleRect.height || !sweetsRect.width || !sweetsRect.height) return;

    const circleCenter = {
      x: circleRect.left + circleRect.width / 2,
      y: circleRect.top + circleRect.height / 2,
    };
    const sweetsCenter = {
      x: sweetsRect.left + sweetsRect.width / 2,
      y: sweetsRect.top + sweetsRect.height / 2,
    };

    const dx = playCenter.x - circleCenter.x;
    const dy = playCenter.y - circleCenter.y;
    const len = Math.hypot(dx, dy) || 1;
    const targetX = circleCenter.x + (dx / len) * decidedMoveDistance;
    const targetY = circleCenter.y + (dy / len) * decidedMoveDistance;
    const moveX = targetX - sweetsCenter.x;
    const moveY = targetY - sweetsCenter.y;
    const rotRad = (typeof rotDeg === 'number' ? rotDeg : 0) * Math.PI / 180;
    const localMoveX = moveX * Math.cos(-rotRad) - moveY * Math.sin(-rotRad);
    const localMoveY = moveX * Math.sin(-rotRad) + moveY * Math.cos(-rotRad);

    if(skipMove || alreadyAnimated){
      sweetsWrap.classList.add('decided-static');
    }else{
      sweetsWrap.classList.remove('decided-static');
    }
    sweetsWrap.style.setProperty('--decidedMoveX', `${localMoveX}px`);
    sweetsWrap.style.setProperty('--decidedMoveY', `${localMoveY}px`);
    sweetsWrap.classList.add('decided-move');
    if(uid && !decidedSweetsAnimated.has(uid)){
      decidedSweetsAnimated.set(uid, decidedStartAt);
    }

  });
}

function parseRotationDegrees(value){
  if(!value) return 0;
  const num = parseFloat(value);
  return Number.isFinite(num) ? num : 0;
}

function applyCenterMoveToCard(cardEl, hostEl, rotDeg, startedAt){
  if(!cardEl || !playerCircle) return;
  const circleRect = playerCircle.getBoundingClientRect();
  const cardRect = cardEl.getBoundingClientRect();
  if(!circleRect.width || !circleRect.height || !cardRect.width || !cardRect.height) return;

  const circleCenter = {
    x: circleRect.left + circleRect.width / 2,
    y: circleRect.top + circleRect.height / 2,
  };
  const cardCenter = {
    x: cardRect.left + cardRect.width / 2,
    y: cardRect.top + cardRect.height / 2,
  };
  let moveX = circleCenter.x - cardCenter.x;
  let moveY = circleCenter.y - cardCenter.y;

  if(rotDeg){
    const rotRad = rotDeg * Math.PI / 180;
    const localMoveX = moveX * Math.cos(-rotRad) - moveY * Math.sin(-rotRad);
    const localMoveY = moveX * Math.sin(-rotRad) + moveY * Math.cos(-rotRad);
    moveX = localMoveX;
    moveY = localMoveY;
  }

  cardEl.style.setProperty('--centerMoveX', `${moveX}px`);
  cardEl.style.setProperty('--centerMoveY', `${moveY}px`);
  cardEl.classList.add('center-move');
  if(hostEl){
    hostEl.classList.add('center-move-host');
  }

  if(typeof startedAt === 'number' && (Date.now() - startedAt) > DECIDED_CENTER_MOVE_DURATION_MS){
    cardEl.classList.add('center-static');
  }else{
    cardEl.classList.remove('center-static');
  }
}

function applyCenterMoveForUid(uid){
  const startedAt = decidedCenterMoveAnimated.get(uid);
  const tagEl = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"]`);
  if(tagEl){
    const cardEl = tagEl.querySelector('.selected-sweets-card');
    applyCenterMoveToCard(cardEl, tagEl, 0, startedAt);
  }

  const wrapEl = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"]`);
  if(wrapEl){
    const cardEl = wrapEl.querySelector('.sweets-mini');
    const circle = wrapEl.closest('.otherplayerscircle');
    const rotDeg = circle
      ? parseRotationDegrees(getComputedStyle(circle).getPropertyValue('--rotDeg').trim())
      : 0;
    applyCenterMoveToCard(cardEl, wrapEl, rotDeg, startedAt);
  }
}

function getLatestDecidedAt(uids){
  const list = Array.isArray(uids) ? uids : [];
  const key = [...list].sort().join(',');
  if(decidedRoundStartAt && key === decidedRoundKey){
    return decidedRoundStartAt;
  }
  const times = list
    .map(uid => decidedSweetsAnimated.get(uid))
    .filter(ts => typeof ts === 'number');
  return times.length ? Math.max(...times) : Date.now();
}
function getLatestAppliedDecidedAt(uids){
  const list = Array.isArray(uids) ? uids : [];
  const times = list
    .map(uid => decidedSweetsAnimated.get(uid))
    .filter(ts => typeof ts === 'number');
  return times.length ? Math.max(...times) : Date.now();
}

function waitForDecidedTimestamps(uids, timeoutMs = 1200){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return Promise.resolve();
  const start = Date.now();
  return new Promise(resolve => {
    const tick = () => {
      const missing = list.some(uid => !decidedSweetsAnimated.has(uid));
      if(!missing || (Date.now() - start) >= timeoutMs){
        resolve();
        return;
      }
      setTimeout(tick, 50);
    };
    tick();
  });
}


function scheduleCenterMovesForUids(uids){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return;
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'done') return;
  const allCentered = list.every(uid => decidedCenterMoveAnimated.has(uid));
  if(allCentered) return;
  const key = [...list].sort().join(',');
  if(centerMoveBatchTimerId && centerMoveBatchKey === key) return;
  if(centerMoveBatchTimerId){
    clearTimeout(centerMoveBatchTimerId);
    centerMoveBatchTimerId = null;
  }
  centerMoveBatchKey = key;

  const latestDecidedAt = getLatestDecidedAt(list);
  const delay = Math.max(0, latestDecidedAt + DECIDED_CENTER_DELAY_MS - Date.now());

  centerMoveBatchTimerId = setTimeout(() => {
    centerMoveBatchTimerId = null;
    const startedAt = Date.now();
    list.forEach(uid => {
      if(decidedCenterMoveAnimated.has(uid)) return;
      decidedCenterMoveAnimated.set(uid, startedAt);
      applyCenterMoveForUid(uid);
    });
  }, delay);
}

function ensureDecidedRoundStart(uids){
  const list = Array.isArray(uids) ? uids : [];
  if(!list.length) return;
  const key = [...list].sort().join(',');
  if(decidedRoundKey === key) return;
  decidedRoundKey = key;
  decidedRoundStartAt = Date.now();
}

function getDecidedStartAtForUids(uids){
  const list = Array.isArray(uids) ? uids : [];
  const key = [...list].sort().join(',');
  if(decidedRoundStartAt && key === decidedRoundKey){
    return decidedRoundStartAt;
  }
  return Date.now();
}

function cacheMySweetsSnapshot(){
  const card = getMySweetsCard();
  if(!card || mySweetsEl.classList.contains('hidden')) return;
  const rect = mySweetsEl.getBoundingClientRect();
  if(!rect.width || !rect.height) return;
  lastMySweetsSnapshot = {
    rect,
    cardId: card.id,
  };
}

function animateMySweetsToTag(targetEl, card){
  if(!targetEl || !card || !lastMySweetsSnapshot) return;
  if(mySweetsFlyAnimatedFor === card.id) return;
  const srcRect = lastMySweetsSnapshot.rect;
  const tagEl = targetEl.classList.contains('selected-sweets-tag')
    ? targetEl
    : targetEl.closest('.selected-sweets-tag');
  const dstRect = targetEl.getBoundingClientRect();
  if(!srcRect.width || !srcRect.height || !dstRect.width || !dstRect.height) return;
  let moveYAdjust = 0;
  if(tagEl){
    const moveYValue = getComputedStyle(tagEl).getPropertyValue('--sweetsTagMoveY').trim();
    const parsedMoveY = parseFloat(moveYValue);
    if(Number.isFinite(parsedMoveY)){
      moveYAdjust = parsedMoveY;
    }
  }

  const fly = document.createElement('div');
  fly.className = 'sweets-fly-card';
  fly.style.left = `${srcRect.left}px`;
  fly.style.top = `${srcRect.top}px`;
  fly.style.width = `${srcRect.width}px`;
  fly.style.height = `${srcRect.height}px`;

  const img = document.createElement('img');
  img.src = card.img;
  img.alt = `sweets ${card.value ?? ''}`;
  img.onerror = () => { if(card.fallback) img.src = card.fallback; };
  fly.appendChild(img);

  document.body.appendChild(fly);

  const dx = dstRect.left - srcRect.left;
  const dy = (dstRect.top + moveYAdjust) - srcRect.top;
  const scale = dstRect.width / srcRect.width;

  fly.animate([
    { transform:`translate(0px, 0px) scale(1)` },
    { transform:`translate(${dx}px, ${dy}px) scale(${scale})` },
  ], {
    duration: DECIDED_MOVE_DURATION_MS,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => fly.remove();

  mySweetsFlyAnimatedFor = card.id;
}


function renderPlayerCircle(players){
  playerCircle.innerHTML = '';

  // â˜… ä¸­å¤®ãƒªãƒ¼ãƒ€ãƒ¼ãƒœãƒ¼ãƒ‰ â†’ â˜… playCircle ã®é †ã§å¾©å…ƒ
  if(leaderboardBoardEl) playerCircle.appendChild(leaderboardBoardEl);
  playerCircle.appendChild(playCircleEl);

  // â˜… äººæ•°ã§ãƒœãƒ¼ãƒ‰ç”»åƒã‚’åˆ‡ã‚Šæ›¿ãˆï¼ˆå¸­ã«ç€ã„ã¦ã‚‹äººæ•°ï¼‰
  updateLeaderboardBoardByPlayerCount(players?.length || 0);
  updateRequiredSweetsTag();

  if (!players.length) return;

  const n = players.length;
  const radius = 42;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);
  const decidedMoveTargets = [];

  const allPassed = allSeatedPlayersPassed();
  const leaderSeat = state.turn?.leaderSeat ?? null;
  const activeSeat = allPassed ? null : (state.turn?.activeSeat ?? null);
  const roundPick = getRoundPick();
  const roundPickActive = roundPick?.phase === 'choose';
  const roundPickCandidates = roundPickActive && Array.isArray(roundPick.candidates)
    ? roundPick.candidates
    : [];
  const roundPickCanSelect = roundPickActive && roundPick?.leaderId === state.userId;
  const leaderPick = getLeaderPick();
  const leaderPickActive = leaderPick?.phase === 'choose';
  const leaderPickCandidates = leaderPickActive && Array.isArray(leaderPick.candidates)
    ? leaderPick.candidates
    : [];
  const leaderPickCanSelect = leaderPickActive && leaderPick?.leaderId === state.userId;
  const voteHoldActive = shouldHoldVoteChips();
  const decidedUids = getDecidedSweetsUids();
  const started = !!state.room?.gameStarted;
  if(roundPick?.phase === 'done' && decidedUids.length){
    ensureDecidedRoundStart(decidedUids);
  }

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    // ===== è‡ªåˆ† =====
    if(p.id === state.userId){
      const tag = document.createElement('div');
      tag.className = 'player-tag me';
      tag.textContent = p.name;
      tag.style.left = `${x}%`;
      tag.style.top = `${y}%`;
      tag.dataset.seat = String(p.seatIndex);
      tag.dataset.uid = p.id;

      if(leaderPickCanSelect && leaderPickCandidates.includes(state.userId)){
        tag.classList.add('leader-pick-selectable');
        tag.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          requestLeaderPick(state.userId);
        });
        tag.onclick = (e) => {
          e.stopPropagation();
          requestLeaderPick(state.userId);
        };
      }

      playerCircle.appendChild(tag);

      if(leaderSeat !== null && leaderSeat === p.seatIndex){
        const chip = document.createElement('div');
        chip.className = 'leader-chip';
        tag.appendChild(chip);
      }
      if(voteHoldActive && !decidedUids.includes(state.userId)){
        const voteStack = buildVoteStackEl(state.userId);
        if(voteStack){
          tag.appendChild(voteStack);
        }
      }
     if(started && decidedUids.includes(state.userId)){
        const sweetsCard = getSweetsCardByUid(state.userId);
        if(sweetsCard){
          const isCollectHidden = collectedSweetsHidden.has(state.userId);
          const selected = document.createElement('div');
          selected.className = 'selected-sweets-tag';
          let decidedStartedAt = decidedSweetsAnimated.get(state.userId);
          if(typeof decidedStartedAt !== 'number'){
            decidedStartedAt = getDecidedStartAtForUids(decidedUids);
            decidedSweetsAnimated.set(state.userId, decidedStartedAt);
          }
          const canAnimateMySweets = !!(lastMySweetsSnapshot && lastMySweetsSnapshot.cardId === sweetsCard.id);
          const animationCompleted = hasCompletedDecidedMove(state.userId);
          const shouldAnimateMySweets = !animationCompleted
            && canAnimateMySweets
            && mySweetsFlyAnimatedFor !== sweetsCard.id;
          if(animationCompleted || !shouldAnimateMySweets){
            selected.classList.add('decided-static');
          }else{
            selected.classList.add('delayed-show');
          }
          if(isCollectHidden){
            selected.classList.add('collect-hidden');
          }
          selected.dataset.sweetsUid = state.userId;
          const cardWrap = document.createElement('div');
          cardWrap.className = 'selected-sweets-card';
          const img = document.createElement('img');
          img.src = SWEETS_BACK_IMG;
          img.alt = `sweets ${sweetsCard.value ?? ''}`;
          img.onerror = () => { if(sweetsCard.fallback) img.src = sweetsCard.fallback; };
          cardWrap.appendChild(img);

         if(typeof sweetsCard.value !== 'undefined'){
            const valueTag = document.createElement('div');
            valueTag.className = 'sweets-number-tag';
            const star = createRoundedStarSvg();
            const valueText = document.createElement('span');
            valueText.className = 'sweets-number-text';
            valueText.textContent = String(sweetsCard.value);
            valueTag.appendChild(star);
            valueTag.appendChild(valueText);
            cardWrap.appendChild(valueTag);
          }
          selected.appendChild(cardWrap);

         const vCount = getVoteCountFor(state.userId);
          if(vCount > 0){
            const voteStack = document.createElement('div');
            voteStack.className = 'vote-stack';
            voteStack.dataset.targetUid = state.userId;
            for(let i=0;i<vCount;i++){
              const v = document.createElement('div');
              v.className = 'vote-mini';
              voteStack.appendChild(v);
            }
            selected.appendChild(voteStack);
         }
          tag.appendChild(selected);
          if(shouldAnimateMySweets){
            requestAnimationFrame(() => {
              animateMySweetsToTag(selected, sweetsCard);
            });
          }
          if(!animationCompleted && shouldAnimateMySweets){
            const remaining = Math.max(0, DECIDED_MOVE_DURATION_MS - (Date.now() - decidedStartedAt));
            setTimeout(() => {
              selected.classList.remove('delayed-show');
            }, remaining);
          }else{
            selected.classList.remove('delayed-show');
          }
         if(decidedCenterMoveAnimated.has(state.userId)){
            requestAnimationFrame(() => {
              applyCenterMoveForUid(state.userId);
            });
          }
        }
      }
      return;
    }


// ===== ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ =====
const circle = document.createElement('div');
circle.className = 'otherplayerscircle';
circle.style.left = `${x}%`;
circle.style.top  = `${y}%`;

// â˜… ä¸­å¿ƒæ–¹å‘ï¼ˆå†…å´ï¼‰ãƒ™ã‚¯ãƒˆãƒ«ï¼š(-cos, -sin)
const ux = -Math.cos(angle);
const uy = -Math.sin(angle);

// å†…å´/å¤–å´ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆpxï¼‰
const innerOff = 20;  // ã‚«ãƒ¼ãƒ‰ã‚’å†…å´ã¸
const outerOff = 44;  // ã‚¿ã‚°ã‚’å¤–å´ã¸

circle.style.setProperty('--inX',  `${ux * innerOff}px`);
circle.style.setProperty('--inY',  `${uy * innerOff}px`);
circle.style.setProperty('--outX', `${-ux * outerOff}px`);
circle.style.setProperty('--outY', `${-uy * outerOff}px`);

// â˜… ã‚«ãƒ¼ãƒ‰ã®ã€Œä¸Šè¾ºã€ãŒä¸­å¿ƒã‚’å‘ãå›è»¢ï¼ˆCSS rotateï¼‰
const rotDeg = (Math.atan2(uy, ux) * 180 / Math.PI) + 90;
circle.style.setProperty('--rotDeg', `${rotDeg}deg`);

const tag = document.createElement('div');
tag.className = 'player-tag in-othercircle';

tag.textContent = p.name;
tag.dataset.seat = String(p.seatIndex);
tag.dataset.uid = p.id;
const isRightSide = x > 50;
tag.classList.toggle('right-side', isRightSide);

const leaderPickSelectable = leaderPickCanSelect && leaderPickCandidates.includes(p.id);
  if(leaderPickSelectable){
    tag.classList.add('leader-pick-selectable');
    if(p.id !== state.userId){
      tag.classList.add('leader-pick-candidate');
    }
    tag.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    });
    tag.onclick = (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    };
    circle.onclick = (e) => {
      e.stopPropagation();
      requestLeaderPick(p.id);
    };
  }

// è¿½ã„å‡ºã—ã‚¯ãƒªãƒƒã‚¯ã¯ä»Šã¾ã§é€šã‚Š
const onKick = () => {
  if (!state.roomCode) return;
  if (state.seatedTable !== null) return;

  pendingSeatIndexToSteal = p.seatIndex;
  pendingSeatPlayerIdToSteal = p.id;
  kickMessage.textContent = `ã€Œ${p.name}ã€ã‚’è¿½ã„å‡ºã—ã¦ã€ã“ã®å¸­ã«ç€å¸­ã—ã¾ã™ã‹ï¼Ÿ`;
  kickDialog.classList.remove('hidden');
};
circle.onclick = (e) => { e.stopPropagation(); onKick(); };
tag.onclick = (e) => { e.stopPropagation(); onKick(); };

if(activeSeat === p.seatIndex) circle.classList.add('active-turn');

circle.appendChild(tag);

// handData ã¯å¾Œã§ãƒŸãƒ‹æ‰‹æœ­ã«ã‚‚ä½¿ã†ã®ã§å…ˆã«å–ã‚‹
const handData = state.hands?.[p.id];
const roleAssigned = !!state.roles?.[p.id];
const voteChips = getPlayerVoteChips(p.id);
let roleMini = null;

if(started && roleAssigned){
  roleMini = document.createElement('div');
  roleMini.className = 'role-mini other-role-mini';
  tag.appendChild(roleMini);


  const hasTheirSweets = !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);
  const showVoteHold = voteHoldActive && getVoteCountFor(p.id) > 0;

  if(hasTheirSweets || showVoteHold){
    const cardsRow = document.createElement('div');
    cardsRow.className = 'other-cards-row';

    const sweetsWrap = document.createElement('div');
    sweetsWrap.className = 'sweets-wrap';
    sweetsWrap.dataset.sweetsUid = p.id;
    sweetsWrap.classList.toggle('empty', !hasTheirSweets);
    if(collectedSweetsHidden.has(p.id)){
      sweetsWrap.classList.add('collect-hidden');
    }
    if(roundPickCanSelect && roundPickCandidates.includes(p.id)){
      sweetsWrap.classList.add('roundpick-candidate');
      sweetsWrap.classList.add('roundpick-selectable');
      sweetsWrap.addEventListener('pointerdown', (e) => {
        e.stopPropagation();
        startRoundPickDrag(e, p.id);
      });
    }
    if(decidedUids.includes(p.id)){
      decidedMoveTargets.push({
        uid: p.id,
        sweetsWrap,
        circle,
        rotDeg,
        skipMove: hasCompletedDecidedMove(p.id),
      });
    }
    if(decidedUids.includes(p.id) && decidedCenterMoveAnimated.has(p.id)){
      requestAnimationFrame(() => {
        applyCenterMoveForUid(p.id);
      });
    }

    const sweetsMini = document.createElement('div');
    sweetsMini.className = 'sweets-mini';
    sweetsMini.classList.toggle('hidden', !hasTheirSweets);
    sweetsWrap.appendChild(sweetsMini);

    // æŠ•ç¥¨ãƒãƒƒãƒ—ï¼ˆã‚¹ã‚¤ãƒ¼ãƒ„å³ã«é‡ã­ï¼‰
    const voteStack = buildVoteStackEl(p.id);
    if(voteStack){
      sweetsWrap.appendChild(voteStack);
    }

    cardsRow.appendChild(sweetsWrap);
    circle.appendChild(cardsRow);
  }
}





// â˜… ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼šãƒŸãƒ‹æ‰‹æœ­ï¼ˆã‚¿ã‚°ã®ä¸‹ã«æ‰‡çŠ¶ï¼‰ã¯ãã®ã¾ã¾ï¼ˆæ¬²ã—ã‘ã‚Œã°æ®‹ã™ï¼‰
if (handData && Array.isArray(handData.action) && handData.action.length){
  const miniHand = document.createElement('div');
  miniHand.className = 'mini-hand';

  const count = handData.action.length;
  const spread = 70;
  const base = (count > 1) ? (-spread/2) : 0;

  handData.action.forEach((_, idx2) => {
    const c = document.createElement('div');
    c.className = 'mini-card';

    const angleDeg2 = (count > 1) ? base + (spread/(count-1))*idx2 : 0;
    c.style.transform = `translate(-50%,0) rotate(${angleDeg2}deg)`;
    c.style.zIndex = String(10 + idx2);
    miniHand.appendChild(c);
  });

 tag.appendChild(miniHand);
}

if(voteChips > 0){
  const voteChip = document.createElement('div');
  voteChip.className = 'other-vote-chip';
  voteChip.dataset.voterUid = p.id;
  if(roleMini){
    roleMini.appendChild(voteChip);
  }else{
    tag.appendChild(voteChip);
  }
}

playerCircle.appendChild(circle);

if(leaderSeat !== null && leaderSeat === p.seatIndex){
  const chip = document.createElement('div');
  chip.className = 'leader-chip';
  tag.appendChild(chip);
}
  });
 requestAnimationFrame(() => {
    applyDecidedSweetsMove(decidedMoveTargets);
    if(roundPick?.phase === 'done' && decidedUids.length){
      scheduleCenterMovesForUids(decidedUids);
      decidedUids.forEach((uid) => {
        if(decidedCenterMoveAnimated.has(uid)){
          requestAnimationFrame(() => {
            applyCenterMoveForUid(uid);
          });
        }
      });
    }
  });
  scheduleVoteChipAnimations();
  updateActionDeckUI();
  updateSweetsDeckUI();
}

/* =========================
   ã‚¿ãƒ¼ãƒ³UIæ›´æ–°
   ========================= */
function updateTurnUI(){
  if(!state.turn || state.game?.status !== 'playing' || allSeatedPlayersPassed()){
    turnBar.classList.add('hidden');
    turnBadge.textContent = 'TURN';
    const wrap = document.querySelector('.my-hand-wrapper');
    wrap?.classList.remove('my-turn-free','my-turn-blocked');
    renderMySweets();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  const activeP = getPlayerBySeat(state.turn.activeSeat);
  const activeName = activeP?.name ?? 'ï¼Ÿ';
  turnBadge.textContent = isTurnBlocked()
    ? 'ã‚·ãƒ£ãƒƒãƒ•ãƒ«ä¸­â€¦'
    : `æ‰‹ç•ªï¼š${activeName}ï¼ˆ${state.turn.activeSeat}ï¼‰`;

  const show = (state.seatedTable !== null);
  turnBar.classList.toggle('hidden', !show);

  const mine = isMyTurn();
  btnPass.disabled = !mine;

  btnDrawSweets.disabled = true;
  btnVote.disabled = true;

  renderHands();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   4ã¤ã®æ‰‹ç•ªçµ‚äº†è¦å› ï¼ˆä»Šã¯ãƒ‘ã‚¹ã®ã¿ï¼šæ—¢å­˜ï¼‰
   ========================= */
btnPass.addEventListener('click', async ()=>{
  await endTurn('pass');
});

/* =========================
   â˜…â˜…â˜… å³ä¸‹PASSï¼ˆãƒ©ã‚¦ãƒ³ãƒ‰ç”¨ï¼‰
   - æŠ¼ã—ãŸã‚‰ game/passes[uid]=true
   - ãã®æ™‚ç‚¹ã§æ¬¡æ‰‹ç•ªã¸ï¼ˆpassæ¸ˆã¿ã‚’é£›ã°ã™ï¼‰
   ========================= */
passRoundBtn.addEventListener('click', async ()=>{
  if(!state.roomCode) return;
  if(!isMyTurn()) return;
  if(!myDoneSweetsAndVote()) return;
  if(hasReceivedInstruction()) return;

  const gamePassRef = ref(db, `rooms/${state.roomCode}/game/passes/${state.userId}`);
  await set(gamePassRef, true);

  await endTurn('roundPass');
});

/* =========================
   â˜…â˜…â˜… ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†åˆ¤å®šï¼†é¸æŠœ
   ========================= */
function requiredPickCountByPlayers(n){
  if(n <= 4) return 2;
  if(n <= 6) return 3;
  return 4; // 7-8
}
function getLeaderPlayerId(){
  const leaderSeat = state.turn?.leaderSeat ?? null;
  if(leaderSeat == null) return null;
  const p = getPlayerBySeat(leaderSeat);
  return p?.id ?? null;
}
function allSeatedPlayersPassed(){
  const pm = getPassedMap();
  if(!latestPlayers.length) return false;
  return latestPlayers.every(p => !!pm?.[p.id]);
}
function getSweetsCardByUid(uid){
  const hd = state.hands?.[uid];
  const arr = hd?.sweets;
  if(Array.isArray(arr) && arr.length) return arr[0];
  return null;
}
function getSweetsVoteStats(){
  // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆã‚¹ã‚¤ãƒ¼ãƒ„æŒã¡ï¼‰ã®ç¥¨æ•°
  const owners = getSweetsOwners();
  return owners.map(uid => ({
    uid,
    votes: getVoteCountFor(uid),
    card: getSweetsCardByUid(uid),
  })).filter(x => !!x.card);
}
function groupByVotesDesc(items){
  const sorted = [...items].sort((a,b)=>{
    if(b.votes !== a.votes) return b.votes - a.votes;
    return 0;
  });
  // ç¥¨æ•°ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—
  const groups = [];
  for(const it of sorted){
    const last = groups[groups.length-1];
    if(!last || last.votes !== it.votes){
      groups.push({ votes: it.votes, items:[it] });
    }else{
      last.items.push(it);
    }
  }
  return groups;
}

/**
 * ãƒ›ã‚¹ãƒˆã ã‘ãŒã€Œå…¨å“¡PASSã€ã‚’æ¤œçŸ¥ã—ã¦ã€é¸æŠœãƒ•ãƒ­ãƒ¼ã‚’é–‹å§‹ã™ã‚‹
 * - roundEnding ãŒ false ã®æ™‚ã ã‘é–‹å§‹
 * - åŒç¥¨è¶…éãŒã‚ã‚Œã° roundPick.phase='choose' ã‚’ã‚»ãƒƒãƒˆ
 * - è¶…éãŒãªã‘ã‚Œã° roundPick.phase='done' ã‚’ã‚»ãƒƒãƒˆã—ã¦ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
 */
async function maybeHostStartRoundEndFlow(){
  if(!state.roomCode) return;
  if(!state.room?.gameStarted) return;
  if(state.game?.roundEnding) return;
  if(!allSeatedPlayersPassed()) return;

  const nPlayers = latestPlayers.length;
  const need = requiredPickCountByPlayers(nPlayers);

  const stats = getSweetsVoteStats();
  if(!stats.length){
    // ã‚¹ã‚¤ãƒ¼ãƒ„ãŒèª°ã‚‚ç„¡ã„å ´åˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆä»•æ§˜å¤–ï¼‰
    await update(ref(db, `rooms/${state.roomCode}/game`), { roundEnding:true, roundPick:{ phase:'done', selected:[], need:0 } });
    return;
  }

  const groups = groupByVotesDesc(stats);

  const selected = [];
  let remaining = need;

  // ä¸Šä½ã‚°ãƒ«ãƒ¼ãƒ—ã‹ã‚‰é †ã«ç¢ºå®šã—ã¦ã„ããŒã€æœ€å¾Œã«åŒç¥¨ã§è¶…éã™ã‚‹ãªã‚‰ãƒªãƒ¼ãƒ€ãƒ¼é¸æŠã¸
  for(const g of groups){
    if(remaining <= 0) break;

    if(g.items.length <= remaining){
      selected.push(...g.items.map(x=>x.uid));
      remaining -= g.items.length;
      continue;
    }

    // ã“ã“ã§åŒç¥¨è¶…éï¼ˆg.items ãŒ remaining ã‚’è¶…ãˆã‚‹ï¼‰
    const leaderId = getLeaderPlayerId();
    const payload = {
      roundEnding: true,
      roundPick: {
        phase: 'choose',
        need: remaining,
        baseSelected: selected,
        candidates: g.items.map(x=>x.uid),
        leaderSeat: state.turn?.leaderSeat ?? null,
        leaderId,
      }
    };
    await update(ref(db, `rooms/${state.roomCode}/game`), payload);
    return;
  }

  // è¶…éãªã—ã§ç¢ºå®š
  const finalSelected = selected.slice(0, need);
  await update(ref(db, `rooms/${state.roomCode}/game`), {
    roundEnding: true,
    roundPick: {
      phase: 'done',
      need: 0,
      selected: finalSelected,
      revealFiredKey: null,
    }
  });

}

/* =========================
   â˜… åŒç¥¨è¶…éï¼šãƒªãƒ¼ãƒ€ãƒ¼é¸æŠUI
   - game.roundPick.phase === 'choose' ã®ã¨ã
   - leaderId ã®äººã ã‘ã‚¯ãƒªãƒƒã‚¯å¯èƒ½
   ========================= */
function getRoundPick(){
  return state.game?.roundPick || null;
}
function getLeaderPick(){
  return state.game?.leaderPick || null;
}
function shouldHoldVoteChips(){
  const lp = getLeaderPick();
  return !!lp && lp.phase !== 'done';
}
function canLeaderPickCandidate(uid){
  const lp = getLeaderPick();
  if(!lp || lp.phase !== 'choose') return false;
  if(lp.leaderId !== state.userId) return false;
  const candidates = Array.isArray(lp.candidates) ? lp.candidates : [];
  return candidates.includes(uid);
}
function updateLeaderPickUI(){
  const lp = getLeaderPick();
  const show = !!lp && lp.phase === 'choose' && lp.leaderId === state.userId;
  leaderPickPop.classList.toggle('hidden', !show);
}
async function requestLeaderPick(uid){
  if(!state.roomCode) return;
  if(!canLeaderPickCandidate(uid)) return;
  const lp = getLeaderPick() || {};
  await update(ref(db, `rooms/${state.roomCode}/game/leaderPick`), {
    phase: 'decided',
    decidedId: uid,
    candidates: Array.isArray(lp.candidates) ? lp.candidates : [],
    leaderId: lp.leaderId ?? null,
    leaderSeat: lp.leaderSeat ?? null,
    startAt: (typeof lp.startAt === 'number') ? lp.startAt : Date.now(),
  });
}

function getLeaderChipSizePx(){
  const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--leaderChipSize'));
  return Number.isFinite(size) ? size : 21.6;
}
function getLeaderChipOffsetPx(){
  const offset = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--leaderChipOffset'));
  return Number.isFinite(offset) ? offset : 22;
}
function getLeaderChipAnchorRect(tagEl){
  if(!tagEl) return null;
  const rect = tagEl.getBoundingClientRect();
  const size = getLeaderChipSizePx();
  const offset = getLeaderChipOffsetPx();
  return {
    left: rect.right + offset - size,
    top: rect.top + (rect.height - size) / 2,
    size,
  };
}
function animateLeaderChipMove(prevSeat, nextSeat){
  const prevTag = document.querySelector(`.player-tag[data-seat="${prevSeat}"]`);
  const nextTag = document.querySelector(`.player-tag[data-seat="${nextSeat}"]`);
  if(!prevTag || !nextTag) return;
  const from = getLeaderChipAnchorRect(prevTag);
  const to = getLeaderChipAnchorRect(nextTag);
  if(!from || !to) return;

  const chip = document.createElement('div');
  chip.className = 'leader-chip leader-chip-fly';
  chip.style.left = `${from.left}px`;
  chip.style.top = `${from.top}px`;
  document.body.appendChild(chip);

  const targetChip = nextTag.querySelector('.leader-chip');
  if(targetChip) targetChip.classList.add('leader-chip-hidden');

  const dx = to.left - from.left;
  const dy = to.top - from.top;
  chip.animate([
    { transform: 'translate(0px, 0px) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) scale(1.4)` },
    { transform: `translate(${dx}px, ${dy}px) scale(1)` },
  ], {
    duration: 1200,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    chip.remove();
    if(targetChip) targetChip.classList.remove('leader-chip-hidden');
  };
}


function getActionDeckRect(){
  if(!actionDeckUI) return null;
  const rect = actionDeckUI.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function getPlayerTagRectBySeat(seat){
  const tag = document.querySelector(`.player-tag[data-seat="${seat}"]`);
  if(!tag) return null;
  const rect = tag.getBoundingClientRect();
  if(!rect.width || !rect.height) return null;
  return rect;
}
function animateActionDealCard(toSeat, delayMs = 0){
  const from = getActionDeckRect();
  const to = getPlayerTagRectBySeat(toSeat);
  if(!from || !to) return;

  const card = document.createElement('div');
  card.className = 'action-deal-card';
  card.style.left = `${from.left}px`;
  card.style.top = `${from.top}px`;
  card.style.width = `${from.width}px`;
  card.style.height = `${from.height}px`;
  document.body.appendChild(card);

  const dx = (to.left + to.width / 2) - (from.left + from.width / 2);
  const dy = (to.top + to.height / 2) - (from.top + from.height / 2);
  const scale = Math.min(to.width / from.width, to.height / from.height, 1.2);

  card.animate([
    { transform: 'translate(0px, 0px) rotate(-12deg) scale(1)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(0deg) scale(${scale})` },
  ], {
    duration: 600,
    delay: delayMs,
    easing: 'ease-in-out',
    fill: 'forwards',
  }).onfinish = () => {
    card.remove();
  };
}
function schedulePostActionDealMiniShuffle(leaderSeat, delayMs){
  if(!state.isHost || !state.roomCode) return;
  const waitMs = Math.max(0, delayMs || 0);
  setTimeout(() => {
    emitEvent({
      type: 'miniSweetsShuffleStart',
      reason: 'afterActionDeal',
      leaderSeat,
    });
  }, waitMs);
}

async function hostDealActionCardsFromLeader(leaderSeat){
  if(!state.isHost || !state.roomCode) return;
  if(leaderSeat == null) return;

  const base = `rooms/${state.roomCode}`;
  const [handsSnap, decksSnap, gameSnap] = await Promise.all([
    get(ref(db, `${base}/hands`)),
    get(ref(db, `${base}/decks`)),
    get(ref(db, `${base}/game`)),
  ]);
  const hands = handsSnap.val() || {};
  const decks = decksSnap.val() || {};
  const gameNow = gameSnap.val() || {};

  if(gameNow?.actionDealKey){
    return;
  }

  const deck = Array.isArray(decks.action) ? [...decks.action] : [];

  const seatOrder = Array.isArray(gameNow.seatOrder) && gameNow.seatOrder.length
    ? gameNow.seatOrder
    : getSeatedSeatOrder();
  const startIdx = seatOrder.indexOf(leaderSeat);
  if(startIdx === -1) return;

  const deals = [];
  for(let i = 0; i < seatOrder.length; i++){
    const seat = seatOrder[(startIdx + i) % seatOrder.length];
    const player = getPlayerBySeat(seat);
    if(!player) continue;
    const hand = hands[player.id];
    const action = Array.isArray(hand?.action) ? hand.action : [];
    if(action.length >= 3) continue;
    if(!deck.length) break;
    const card = deck.shift();
    if(!card) continue;
    action.push(card);
    hands[player.id] = { ...(hand || {}), action };
    deals.push({ seat });
  }


  const dealKey = `${leaderSeat}-${Date.now()}`;
  const updates = {
    'game/actionDealKey': dealKey,
  };
  if(deals.length){
    updates.hands = hands;
    updates['decks/action'] = deck;
  }

  await update(ref(db, base), updates);
  for(let i = 0; i < deals.length; i++){
    await emitEvent({
      type: 'dealActionCard',
      toSeat: deals[i].seat,
      delayMs: i * 120,
    });
  }
  const lastDelay = (deals.length > 0) ? ((deals.length - 1) * 120 + 650) : 200;
  schedulePostActionDealMiniShuffle(leaderSeat, lastDelay);

}


function maybeHostApplyLeaderPick(){
  if(!state.isHost || !state.roomCode) return;
  const lp = getLeaderPick();
  if(!lp || lp.phase === 'done'){
    if(leaderPickApplyTimer){
      clearTimeout(leaderPickApplyTimer);
      leaderPickApplyTimer = null;
    }
    return;
  }

  const decidedId = lp.decidedId || lp.nextLeaderId || null;
  if(!decidedId) return;

  const key = `${lp.phase}:${decidedId}:${lp.startAt ?? ''}`;
  if(leaderPickApplyKey === key && leaderPickApplyTimer) return;

  if(leaderPickApplyTimer){
    clearTimeout(leaderPickApplyTimer);
    leaderPickApplyTimer = null;
  }
  leaderPickApplyKey = key;

  const baseDelay = (typeof lp.startAt === 'number') ? lp.startAt : Date.now();
  const delay = Math.max(0, baseDelay + 1000 - Date.now());

  leaderPickApplyTimer = setTimeout(async () => {
    leaderPickApplyTimer = null;
    const seat = getSeatByUid(decidedId);
    if(seat == null) return;

    await update(ref(db, `rooms/${state.roomCode}/game/turn`), {
      leaderSeat: seat,
    });
    await update(ref(db, `rooms/${state.roomCode}/game/leaderPick`), {
      phase: 'done',
      decidedId,
      appliedAt: Date.now(),
    });
    const handsSnap = await get(ref(db, `rooms/${state.roomCode}/hands`));
    const hands = handsSnap.val() || {};
    Object.keys(hands).forEach(uid => {
      if(!hands[uid] || typeof hands[uid] !== 'object') hands[uid] = {};
      hands[uid].voteChips = 1;
    });
    await Promise.all([
      set(ref(db, `rooms/${state.roomCode}/votes`), {}),
      set(ref(db, `rooms/${state.roomCode}/hands`), hands),
    ]);
    setTimeout(() => {
      hostDealActionCardsFromLeader(seat);
    }, 650);
  }, delay);
}
function isLeaderMe(){
  const rp = getRoundPick();
  return !!rp && (rp.leaderId === state.userId);
}
function getDecidedSweetsUids(){
  const rp = getRoundPick();
  if(!rp) return [];
  if(rp.phase === 'choose'){
    return Array.isArray(rp.baseSelected) ? rp.baseSelected : [];
  }
  if(rp.phase === 'done'){
    return Array.isArray(rp.selected) ? rp.selected : [];
  }
  return [];
}

function resetCollectedSweetsHiddenCache(){
  if(!state.game?.roundEnding){
    collectedSweetsHidden.clear();
    decidedSweetsAnimated.clear();
    decidedCenterMoveAnimated.clear();
    decidedCenterMoveTimers.forEach((timerId) => clearTimeout(timerId));
    decidedCenterMoveTimers.clear();
    if(centerMoveBatchTimerId){
      clearTimeout(centerMoveBatchTimerId);
      centerMoveBatchTimerId = null;
    }
    centerMoveBatchKey = null;
    decidedRoundKey = null;
    decidedRoundStartAt = null;
    document.querySelectorAll('.collect-hidden').forEach(el => {
      el.classList.remove('collect-hidden');
    });
  }
}





const roundPickDrag = {
  active:false,
  uid:null,
  ghost:null,
  offsetX:0,
  offsetY:0,
  sourceEl:null,
  sourceHidden:false,
  sourceVisibility:'',
  voteChipHidden:false,
  voteChipVisibility:'',
};

function canLeaderDragPick(uid){
  const rp = getRoundPick();
  const candidates = rp && Array.isArray(rp.candidates) ? rp.candidates : [];
  return !!rp && rp.phase === 'choose' && rp.leaderId === state.userId && candidates.includes(uid);
}

function startRoundPickDrag(e, uid){
  if(!canLeaderDragPick(uid)) return;
  e.preventDefault();

  const source = e.currentTarget;
  const r = source.getBoundingClientRect();
  roundPickDrag.active = true;
  roundPickDrag.uid = uid;
  roundPickDrag.offsetX = e.clientX - r.left;
  roundPickDrag.offsetY = e.clientY - r.top;
  roundPickDrag.sourceEl = source;
  roundPickDrag.sourceHidden = true;
  roundPickDrag.sourceVisibility = source.style.visibility;
  source.style.visibility = 'hidden';
  if(uid === state.userId){
    roundPickDrag.voteChipHidden = true;
    roundPickDrag.voteChipVisibility = myVoteChipEl.style.visibility;
    myVoteChipEl.style.visibility = 'hidden';
  }

  const ghost = document.createElement('div');
  ghost.className = 'roundpick-dragging';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${source.offsetWidth}px`;
  ghost.style.height = `${source.offsetHeight}px`;
  ghost.style.transformOrigin = 'center';

  const circle = source.closest('.otherplayerscircle');
  const rotDeg = circle ? getComputedStyle(circle).getPropertyValue('--rotDeg').trim() : '0deg';
  if(uid !== state.userId && rotDeg){
    ghost.style.transform = `rotate(${rotDeg})`;
  }

  const card = getSweetsCardByUid(uid);
  const faceImg = card?.img || card?.fallback || SWEETS_BACK_IMG;
  const bgImg = (uid === state.userId) ? faceImg : SWEETS_BACK_IMG;
  ghost.style.backgroundImage = `url('${bgImg}')`;

  document.body.appendChild(ghost);
  roundPickDrag.ghost = ghost;

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onRoundPickDragMove);
  ghost.addEventListener('pointerup', onRoundPickDragEnd);
  ghost.addEventListener('pointercancel', onRoundPickDragEnd);
}

function onRoundPickDragMove(e){
  if(!roundPickDrag.active || !roundPickDrag.ghost) return;
  const x = e.clientX - roundPickDrag.offsetX;
  const y = e.clientY - roundPickDrag.offsetY;
  roundPickDrag.ghost.style.left = `${x}px`;
  roundPickDrag.ghost.style.top  = `${y}px`;

  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (e.clientX >= pr.left && e.clientX <= pr.right && e.clientY >= pr.top && e.clientY <= pr.bottom);
  playCircleEl.classList.toggle('roundpick-target', inPlay);
}

async function onRoundPickDragEnd(e){
  if(!roundPickDrag.active) return;

  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (e.clientX >= pr.left && e.clientX <= pr.right && e.clientY >= pr.top && e.clientY <= pr.bottom);
  const uid = roundPickDrag.uid;

  cleanupRoundPickDrag();

  if(inPlay && uid){
    await leaderPickOne(uid);
  }
}

function cleanupRoundPickDrag(){
  playCircleEl.classList.remove('roundpick-target');
  if(roundPickDrag.ghost){
    roundPickDrag.ghost.removeEventListener('pointermove', onRoundPickDragMove);
    roundPickDrag.ghost.removeEventListener('pointerup', onRoundPickDragEnd);
    roundPickDrag.ghost.removeEventListener('pointercancel', onRoundPickDragEnd);
    roundPickDrag.ghost.remove();
  }
  if(roundPickDrag.sourceEl && roundPickDrag.sourceHidden){
    roundPickDrag.sourceEl.style.visibility = roundPickDrag.sourceVisibility || '';
  }
  if(roundPickDrag.voteChipHidden){
    myVoteChipEl.style.visibility = roundPickDrag.voteChipVisibility || '';
  }
  roundPickDrag.active = false;
  roundPickDrag.uid = null;
  roundPickDrag.ghost = null;
  roundPickDrag.offsetX = 0;
  roundPickDrag.offsetY = 0;
  roundPickDrag.sourceEl = null;
  roundPickDrag.sourceHidden = false;
  roundPickDrag.sourceVisibility = '';
  roundPickDrag.voteChipHidden = false;
  roundPickDrag.voteChipVisibility = '';
}
function updateRoundPickUI(){
  const rp = getRoundPick();
  const roundPickActive = !!rp && rp.phase === 'choose';
  const candidates = roundPickActive && Array.isArray(rp.candidates) ? rp.candidates : [];
  const leaderCanSelect = roundPickActive && rp.leaderId === state.userId;
  const meIsCandidate = leaderCanSelect && candidates.includes(state.userId);
  const meCanSelect = leaderCanSelect && meIsCandidate;

  mySweetsEl.classList.toggle('roundpick-candidate', meIsCandidate);
  mySweetsEl.classList.toggle('roundpick-selectable', meCanSelect);

  if(meCanSelect){
    mySweetsEl.onpointerdown = (e) => {
      e.stopPropagation();
      startRoundPickDrag(e, state.userId);
    };
  }else{
    mySweetsEl.onpointerdown = null;
  }

}
async function leaderPickOne(uid){
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'choose') return;
  if(rp.leaderId !== state.userId) return;

  const need = Number(rp.need || 0);
  if(need <= 0) return;

  const baseSelected = Array.isArray(rp.baseSelected) ? rp.baseSelected : [];
  const candidates = Array.isArray(rp.candidates) ? rp.candidates : [];

  if(!candidates.includes(uid)) return;

  const nextSelected = [...baseSelected, uid];
  const nextCandidates = candidates.filter(x=>x !== uid);
  const nextNeed = need - 1;

  if(nextNeed > 0){
    await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
      phase:'choose',
      need: nextNeed,
      baseSelected: nextSelected,
      candidates: nextCandidates,
      leaderSeat: rp.leaderSeat ?? null,
      leaderId: rp.leaderId ?? null,
    });
    return;
  }

  await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
    phase:'done',
    need: 0,
    selected: nextSelected,
    revealFiredKey: null,
  });

  // ãƒ›ã‚¹ãƒˆãŒã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ã™ã‚‹ã®ãŒåŸå‰‡ã ãŒã€å¿µã®ãŸã‚ãƒªãƒ¼ãƒ€ãƒ¼ã§ã‚‚ç™ºç«ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼ˆé‡è¤‡ã¯å›é¿ï¼‰
  // â†’ ãƒ›ã‚¹ãƒˆå´ã¯ roundPick.phase='done' ã‚’è¦‹ã¦ç™ºç«ã—ãªã„è¨­è¨ˆã«ã—ã¦ã„ãªã„ã®ã§ã€ã“ã“ã¯ç™ºç«ã—ãªã„
  //    ä»£ã‚ã‚Šã«ã€ãƒ›ã‚¹ãƒˆãŒ subscribeGame ã§ roundEnding=true ã‚’è¦‹ã¦ç™ºç«æ¸ˆã¿ã®ã‚±ãƒ¼ã‚¹ãŒã‚ã‚‹ã®ã§ã€
  //    ã“ã“ã§ã¯ã€Œãƒ›ã‚¹ãƒˆã«ä»»ã›ã‚‹ã€ã€‚
}

/* â˜… ãƒ›ã‚¹ãƒˆï¼šroundPick ãŒ done ã«ãªã£ãŸã‚‰ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«ï¼ˆæœªç™ºç«ãªã‚‰ï¼‰ */
async function maybeHostFireRoundRevealAfterLeaderPick(){
 if(!state.isHost) return;
  const rp = getRoundPick();
  if(!rp || rp.phase !== 'done') return;
  if(!state.game?.roundEnding) return;

  const selected = Array.isArray(rp.selected) ? rp.selected : [];
  const key = selected.join(',');
  if(rp.revealFiredKey === key) return;

  await update(ref(db, `rooms/${state.roomCode}/game/roundPick`), {
    revealFiredKey: key,
  });

  const cards = selected.map(uid => getSweetsCardByUid(uid)).filter(Boolean);
  await emitEvent({ type:'roundRevealSweets', selectedUids: selected, cards });
}


/* =========================
   â˜…â˜…â˜… ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†æ¼”å‡ºï¼ˆå…¨å“¡ï¼‰
   - é¸ã°ã‚ŒãŸã‚¹ã‚¤ãƒ¼ãƒ„ï¼ˆè£ï¼‰ã‚’ä¸­å¤®ã¸é›†ã‚ã‚‹
   - ä¸­å¤®ã§ã‚·ãƒ£ãƒƒãƒ•ãƒ«ã£ã½ã„å‹•ã
   - è¡¨ã«ã—ã¦ä¸­å¤®ã«æ¨ªä¸¦ã³ï¼ˆæŠ˜ã‚Šè¿”ã—ãªã—ï¼‰
   - 3ç§’è¡¨ç¤ºå¾Œã€æ¶ˆãˆã‚‹
   ========================= */
let _roundAnimRunning = false;
function getRoundCollectCenter(){
  const r = playCircleEl?.getBoundingClientRect?.();
  if(r && r.width && r.height){
    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
  }
  return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
}
function getSweetsSourceRect(uid, fallback){
  const el = document.querySelector(`[data-sweets-uid="${uid}"]`);
  if(el){
    const r = el.getBoundingClientRect();
    if(r && r.width && r.height){
      return r;
    }
  }
  return fallback;
}

function toggleCollectHiddenForUids(uids, hidden){
  const list = Array.isArray(uids) ? uids : [];
  list.forEach(uid => {
    const targets = document.querySelectorAll(`[data-sweets-uid="${uid}"]`);
    targets.forEach(el => {
      el.classList.toggle('collect-hidden', hidden);
    });
    if(hidden){
      collectedSweetsHidden.add(uid);
    }
  });
}


/* =========================
   â˜…â˜…â˜… ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ï¼šå›åâ†’ã‚·ãƒ£ãƒƒãƒ•ãƒ«â†’æ‹¡å¤§è¡¨ç¤ºï¼ˆå…¨å“¡ï¼‰
   - ã‚´ãƒ¼ã‚¹ãƒˆé˜²æ­¢ï¼šå…ƒä½ç½®DOMã‚’ collect-hidden ã§ä¸å¯è¦–åŒ–
   - äºŒé‡é˜²æ­¢ï¼šstopRoundEndFx() + token ã§æ’ä»–
   ========================= */

const roundEndFx = {
  token: 0,
  timers: new Set(),
  anims: new Set(),
  nodes: new Set(),
  restores: [],
};

function _fxRememberRestore(fn){
  roundEndFx.restores.push(fn);
}
function _fxSetTimeout(fn, ms, token){
  const id = setTimeout(() => {
    roundEndFx.timers.delete(id);
    if(token !== roundEndFx.token) return;
    fn();
  }, ms);
  roundEndFx.timers.add(id);
  return id;
}
function _fxSleep(ms, token){
  return new Promise(resolve => _fxSetTimeout(resolve, ms, token));
}

/** â˜… å¼·åˆ¶åœæ­¢ï¼†å¾Œå§‹æœ«ï¼ˆâ€œå‰ã®â€æ¼”å‡ºã‚’å®Œå…¨ã«æ®ºã™ï¼‰ */
function stopRoundEndFx(){
  // tokenæ›´æ–°ï¼ˆã“ã‚Œã§é€²è¡Œä¸­awaitã¯å…¨éƒ¨ç„¡åŠ¹åŒ–ï¼‰
  roundEndFx.token++;

  // timers
  for(const t of roundEndFx.timers) clearTimeout(t);
  roundEndFx.timers.clear();

  // anims
  for(const a of roundEndFx.anims){
    try{ a.cancel(); }catch(_){}
  }
  roundEndFx.anims.clear();

  // nodes
  for(const n of roundEndFx.nodes){
    try{ n.remove(); }catch(_){}
  }
  roundEndFx.nodes.clear();

  // restoreï¼ˆé€”ä¸­åœæ­¢æ™‚ã ã‘å…ƒã«æˆ»ã™ï¼‰
  for(const r of roundEndFx.restores){
    try{ r(); }catch(_){}
  }
  roundEndFx.restores = [];

  // overlayæƒé™¤ï¼ˆã‚´ãƒ¼ã‚¹ãƒˆæ®‹ã—é˜²æ­¢ï¼‰
  try{
    roundRevealRow.innerHTML = '';
    roundRevealOverlay.classList.add('hidden');
  }catch(_){}
  resetRoundRevealState();
}


/** â˜… â€œå…ƒä½ç½®â€ã¨ã—ã¦æœ€å„ªå…ˆã§ä½¿ã†DOMã‚’æ¢ã™ï¼ˆã‚´ãƒ¼ã‚¹ãƒˆé˜²æ­¢ã®ãŸã‚ï¼‰ */
function _pickOriginElForUid(uid){
  // 1) decidedè¡¨ç¤ºï¼ˆã‚¿ã‚°ä¸Šã® selected-sweets-tagï¼‰
  let el = document.querySelector(`.selected-sweets-tag[data-sweets-uid="${uid}"]`);
  if(el) return el;

  // 2) ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ã‚¤ãƒ¼ãƒ„æ ï¼ˆsweets-wrapï¼‰
  el = document.querySelector(`.sweets-wrap[data-sweets-uid="${uid}"]`);
  if(el) return el;

  // 3) è‡ªåˆ†ã®æ‰‹å…ƒã‚¹ã‚¤ãƒ¼ãƒ„
  if(uid === state.userId && mySweetsEl && !mySweetsEl.classList.contains('hidden')){
    return mySweetsEl;
  }

  return null;
}

/** â˜… å…ƒä½ç½®ã‚’ä¸å¯è¦–åŒ–ï¼ˆâ€œã‚´ãƒ¼ã‚¹ãƒˆâ€ï¼æ®‹åƒé˜²æ­¢ï¼‰ */
function _hideOriginVisual(uid, originEl){
  if(!originEl) return;

  // sweets-wrap / selected-sweets-tag ã¯æ—¢å­˜CSSã® collect-hidden ã‚’ä½¿ã†
  if(originEl.classList.contains('sweets-wrap') || originEl.classList.contains('selected-sweets-tag')){
    if(!originEl.classList.contains('collect-hidden')){
      originEl.classList.add('collect-hidden');
      collectedSweetsHidden.add(uid);
      _fxRememberRestore(()=> {
        originEl.classList.remove('collect-hidden');
        collectedSweetsHidden.delete(uid);
      });
    }
    return;
  }

  // mySweetsEl ãªã©ï¼švisibilityã§æ¶ˆã™ï¼ˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯ä¿æŒï¼‰
  const prevVis = originEl.style.visibility;
  originEl.style.visibility = 'hidden';
  collectedSweetsHidden.add(uid);
  _fxRememberRestore(()=> {
    originEl.style.visibility = prevVis;
    collectedSweetsHidden.delete(uid);
  });
}

/** â˜… å›åã‚«ãƒ¼ãƒ‰ï¼ˆè£ï¼‰ã‚’ä½œæˆ */
function _createCollectCardAtRect(rect){
  const node = document.createElement('div');
  node.className = 'collect-card';
  node.style.left = `${rect.left}px`;
  node.style.top  = `${rect.top}px`;
  node.style.width  = `${rect.width}px`;
  node.style.height = `${rect.height}px`;
  // collect-card ã® background ã¯CSSã§ swsweetsura.jpg ã«ãªã£ã¦ã‚‹å‰æï¼ˆæ—¢å­˜ã®ã¾ã¾ï¼‰
  document.body.appendChild(node);
  roundEndFx.nodes.add(node);
  return node;
}

/** â˜… ä¸­å¤®åº§æ¨™ï¼ˆPLAYã‚’ä¸­å¿ƒã«ã€‚ç„¡ç†ãªã‚‰ç”»é¢ä¸­å¤®ï¼‰ */
function _getCenterPoint(){
  const pr = playCircleEl?.getBoundingClientRect?.();
  if(pr && pr.width && pr.height){
    return { x: pr.left + pr.width/2, y: pr.top + pr.height/2 };
  }
  return { x: window.innerWidth/2, y: window.innerHeight/2 };
}

/** â˜… ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ¼”å‡ºï¼ˆä¸­å¤®ï¼‰ */
/** â˜… ã‚·ãƒ£ãƒƒãƒ•ãƒ«æ¼”å‡ºï¼ˆsweetshuffle1ï¼‰ */
async function _runSweetShuffle1(token){
  const stage = document.createElement('div');
  stage.className = 'sweets-shuffle-stage';
  document.body.appendChild(stage);
  roundEndFx.nodes.add(stage);

  const OFFSET_X = 4;
  const OFFSET_Y = 4;
  const OUT_X = 78;
  const TILT_BASE = 5;
  const TILT_MORE = 5;
  const DUR_OUT = 220;
  const DUR_IN = 220;
  const PAUSE = 20;
  const LOOPS = 3;
  const base = 'translate(-50%,-50%)';
  const baseFront = `${base} translate(0px,0px) rotate(${TILT_BASE}deg)`;
  const baseBack = `${base} translate(${OFFSET_X}px,${OFFSET_Y}px) rotate(${TILT_BASE}deg)`;
  const outTransform = `${base} translate(${OUT_X}px,0px) rotate(${TILT_BASE + TILT_MORE}deg)`;

  const back = document.createElement('div');
  back.className = 'sweets-shuffle-card';
  back.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  back.style.zIndex = '1';
  back.style.transform = baseBack;

  const front = document.createElement('div');
  front.className = 'sweets-shuffle-card';
  front.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
  front.style.zIndex = '2';
  front.style.transform = baseFront;

  stage.appendChild(back);
  stage.appendChild(front);

  const animateOnce = (el, keyframes, options) => {
    const anim = el.animate(keyframes, options);
    roundEndFx.anims.add(anim);
    return new Promise(resolve => {
      anim.onfinish = () => {
        roundEndFx.anims.delete(anim);
        resolve();
      };
      anim.oncancel = () => {
        roundEndFx.anims.delete(anim);
        resolve();
      };
    });
  };

  let frontEl = front;
  let backEl = back;

  for(let i=0;i<LOOPS;i++){
    if(token !== roundEndFx.token) return;
    await animateOnce(frontEl, [
      { transform: baseFront },
      { transform: outTransform },
    ], {
      duration: DUR_OUT,
      easing: 'ease-in-out',
      fill: 'forwards',
    });

    if(token !== roundEndFx.token) return;
    frontEl.style.transform = outTransform;
    frontEl.style.zIndex = '1';
    backEl.style.zIndex = '2';
    backEl.style.transform = baseFront;

    await animateOnce(frontEl, [
      { transform: outTransform },
      { transform: baseBack },
    ], {
      duration: DUR_IN,
      easing: 'ease-in-out',
      fill: 'forwards',
    });

    if(token !== roundEndFx.token) return;
    frontEl.style.transform = baseBack;

    const tmp = frontEl;
    frontEl = backEl;
    backEl = tmp;

    await new Promise(resolve => setTimeout(resolve, PAUSE));
  }

  if(token !== roundEndFx.token) return;
  stage.remove();
  roundEndFx.nodes.delete(stage);
}

async function getSweetsDeckRectForMiniShuffle(){
  if(!sweetsDeckUI) return null;
  let rect = sweetsDeckUI.getBoundingClientRect();
  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }

  const wasCenterHidden = centerDecksEl.classList.contains('hidden');
  const wasSweetsHidden = sweetsDeckUI.classList.contains('hidden');
  const prevCenterVisibility = centerDecksEl.style.visibility;
  const prevSweetsVisibility = sweetsDeckUI.style.visibility;

  centerDecksEl.classList.remove('hidden');
  sweetsDeckUI.classList.remove('hidden');
  centerDecksEl.style.visibility = 'hidden';
  sweetsDeckUI.style.visibility = 'hidden';

  for(let i=0;i<6;i++){
    rect = sweetsDeckUI.getBoundingClientRect();
    if(rect && rect.width > 0 && rect.height > 0){
      break;
    }
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
  }

  centerDecksEl.style.visibility = prevCenterVisibility;
  sweetsDeckUI.style.visibility = prevSweetsVisibility;
  if(wasSweetsHidden) sweetsDeckUI.classList.add('hidden');
  if(wasCenterHidden) centerDecksEl.classList.add('hidden');

  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }
  return null;
}

async function getSweetsExcludedDeckRectForMiniShuffle(){
  if(!sweetsExcludedDeckUI) return null;
  let rect = sweetsExcludedDeckUI.getBoundingClientRect();
  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }

  const wasHidden = sweetsExcludedDeckUI.classList.contains('hidden');
  const prevVisibility = sweetsExcludedDeckUI.style.visibility;
  const prevAnimating = sweetsExcludeAnimating;

 sweetsExcludedDeckUI.style.visibility = prevVisibility;
  sweetsExcludeAnimating = prevAnimating;
  if(wasHidden){
    sweetsExcludedDeckUI.classList.add('hidden');
  } else {
    sweetsExcludedDeckUI.classList.remove('hidden');
  }
  updateSweetsDeckUI();

  for(let i=0;i<6;i++){
    rect = sweetsExcludedDeckUI.getBoundingClientRect();
    if(rect && rect.width > 0 && rect.height > 0){
      break;
    }
    await new Promise(resolve => requestAnimationFrame(() => resolve()));
  }

  sweetsExcludedDeckUI.style.visibility = prevVisibility;
  sweetsExcludeAnimating = prevAnimating;
  if(wasHidden) sweetsExcludedDeckUI.classList.add('hidden');

  if(rect && rect.width > 0 && rect.height > 0){
    return rect;
  }
  return null;
}

function getPlayerCountForSweetsSplit(){
  const seatOrder = state.game?.seatOrder;
  if(Array.isArray(seatOrder) && seatOrder.length){
    return seatOrder.length;
  }
  if(Array.isArray(latestPlayers) && latestPlayers.length){
    return latestPlayers.length;
  }
  const tables = state.room?.tables;
  if(tables && typeof tables === 'object'){
    return Object.values(tables).filter(t => t && t.playerId).length;
  }
  return 0;
}

async function getSweetsDeckForMiniShuffle(){
  const deck = state.room?.decks?.sweets;
  if(Array.isArray(deck) && deck.length){
    return deck;
  }
  if(!state.roomCode) return deck;
  try{
    const snap = await get(ref(db, `rooms/${state.roomCode}/decks/sweets`));
    const data = snap.val();
    if(Array.isArray(data)) return data;
  }catch(_){}
  return deck;
}

async function animateSweetsExcludeMove(fromRect, toRect, totalCount, keepCount){
  const moveCount = Math.max(0, totalCount - keepCount);
  if(moveCount <= 0) return;

  sweetsExcludeAnimating = true;
  setSweetsCountOverrides(totalCount, 0);
  updateSweetsDeckUI();

  const dx = toRect.left - fromRect.left;
  const dy = toRect.top - fromRect.top;
  const duration = 260;

  const card = document.createElement('div');
  card.className = 'sweets-move-card';
  card.style.width = `${fromRect.width}px`;
  card.style.height = `${fromRect.height}px`;
  card.style.left = `${fromRect.left}px`;
  card.style.top = `${fromRect.top}px`;
  document.body.appendChild(card);

  const anim = card.animate([
    { transform: 'translate(0px,0px) rotate(0deg)' },
    { transform: `translate(${dx}px, ${dy}px) rotate(90deg)` },
  ], {
    duration,
    easing: 'ease-in-out',
    fill: 'forwards',
  });

  await new Promise(resolve => {
    anim.onfinish = resolve;
    anim.oncancel = resolve;
  });
  card.remove();

  sweetsExcludeAnimating = false;
  setSweetsCountOverrides(keepCount, moveCount, 5000);
  updateSweetsDeckUI();
}

async function maybeHostApplySweetsSplit(deck, playerCount){
  if(!state.isHost || !state.roomCode) return;
  const currentExcluded = state.room?.decks?.sweetsExcluded;
  if(Array.isArray(currentExcluded) && currentExcluded.length) return;
  const keepCount = clamp(playerCount + 2, 0, Array.isArray(deck) ? deck.length : 0);
  if(!Array.isArray(deck) || deck.length <= keepCount) return;

  const { sweets, excluded } = splitSweetsDeck(deck, playerCount);
  const decksRef = ref(db, `rooms/${state.roomCode}/decks`);
  await update(decksRef, { sweets, sweetsExcluded: excluded });
}

async function runMiniSweetsShuffleAtStart(opts = {}){
  if(miniShuffleRunning) return;
  const reason = opts?.reason || null;
  const leaderSeatForRestart = (typeof opts?.leaderSeat === 'number')
    ? opts.leaderSeat
    : (state.turn?.leaderSeat ?? null);
  turnBlockedByShuffle = true;
  updateTurnUI();
  try{

    const rect = await getSweetsDeckRectForMiniShuffle();
    if(!rect){
      const deck = await getSweetsDeckForMiniShuffle();
      const totalCount = Array.isArray(deck) ? deck.length : 0;
      const playerCount = getPlayerCountForSweetsSplit();
      const keepCount = clamp(playerCount + 2, 0, totalCount);
      const moveCount = Math.max(0, totalCount - keepCount);
      if(moveCount > 0){
        sweetsExcludeAnimating = true;
        setSweetsCountOverrides(keepCount, moveCount, 5000);
        updateSweetsDeckUI();
        sweetsExcludeAnimating = false;
      }
     await maybeHostApplySweetsSplit(deck, playerCount);
      if(reason === 'afterActionDeal'){
        await hostRestartTurnAfterActionDeal(leaderSeatForRestart);
      }else{
        await hostGrantTurnAfterMiniShuffle();
      }
      return;
    }

    const token = ++miniShuffleToken;
    miniShuffleRunning = true;
    updateSweetsDeckUI();

    const cardSample = sweetsDeckUI.querySelector('.card');
    const cardStyle = cardSample ? getComputedStyle(cardSample) : null;
    const cardRadius = cardStyle?.borderRadius || '7px';
    const cardBorder = cardStyle?.border || '1px solid rgba(0,0,0,.18)';
    const cardShadow = cardStyle?.boxShadow || 'none';

    const stage = document.createElement('div');
    stage.className = 'sweets-shuffle-stage';
    stage.style.left = `${rect.left + rect.width / 2}px`;
    stage.style.top = `${rect.top + rect.height / 2}px`;
    stage.style.width = `${rect.width}px`;
    stage.style.height = `${rect.height}px`;
    document.body.appendChild(stage);

    try{
      const BASE_W = 120;
      const BASE_H = 170;
      const scale = Math.min(rect.width / BASE_W, rect.height / BASE_H);
      const OFFSET_X = 4 * scale;
      const OFFSET_Y = 4 * scale;
      const OUT_X = 78 * scale;
      const TILT_BASE = 5;
      const TILT_MORE = 5;
      const DUR_OUT = 220;
      const DUR_IN = 220;
      const PAUSE = 20;
      const LOOPS = 3;
      const base = 'translate(-50%,-50%)';
      const baseFront = `${base} translate(0px,0px) rotate(${TILT_BASE}deg)`;
      const baseBack = `${base} translate(${OFFSET_X}px,${OFFSET_Y}px) rotate(${TILT_BASE}deg)`;
      const outTransform = `${base} translate(${OUT_X}px,0px) rotate(${TILT_BASE + TILT_MORE}deg)`;

      const createCard = (zIndex, transform) => {
        const el = document.createElement('div');
        el.className = 'sweets-shuffle-card';
        el.style.width = `${rect.width}px`;
        el.style.height = `${rect.height}px`;
        el.style.borderRadius = cardRadius;
        el.style.border = cardBorder;
        el.style.boxShadow = cardShadow;
        el.style.backgroundImage = `url('${SWEETS_BACK_IMG}')`;
        el.style.zIndex = String(zIndex);
        el.style.transform = transform;
        return el;
      };

      const back = createCard(1, baseBack);
      const front = createCard(2, baseFront);
      stage.appendChild(back);
      stage.appendChild(front);

      const animateOnce = (el, keyframes, options) => new Promise(resolve => {
        const anim = el.animate(keyframes, options);
        anim.onfinish = resolve;
        anim.oncancel = resolve;
      });

      let frontEl = front;
      let backEl = back;

      for(let i=0;i<LOOPS;i++){
        if(token !== miniShuffleToken) return;
        await animateOnce(frontEl, [
          { transform: baseFront },
          { transform: outTransform },
        ], {
          duration: DUR_OUT,
          easing: 'ease-in-out',
          fill: 'forwards',
        });

        if(token !== miniShuffleToken) return;
        frontEl.style.transform = outTransform;
        frontEl.style.zIndex = '1';
        backEl.style.zIndex = '2';
        backEl.style.transform = baseFront;

        await animateOnce(frontEl, [
          { transform: outTransform },
          { transform: baseBack },
        ], {
          duration: DUR_IN,
          easing: 'ease-in-out',
          fill: 'forwards',
        });

        if(token !== miniShuffleToken) return;
        frontEl.style.transform = baseBack;

        const tmp = frontEl;
        frontEl = backEl;
        backEl = tmp;

        await new Promise(resolve => setTimeout(resolve, PAUSE));
      }
    } finally {
      stage.remove();
      if(token === miniShuffleToken){
        miniShuffleRunning = false;
        updateSweetsDeckUI();
      }
    }
    if(token !== miniShuffleToken) return;

    const deck = await getSweetsDeckForMiniShuffle();
    const totalCount = Array.isArray(deck) ? deck.length : 0;
    const playerCount = getPlayerCountForSweetsSplit();
    const keepCount = clamp(playerCount + 2, 0, totalCount);
    const moveCount = Math.max(0, totalCount - keepCount);

    const targetRect = await getSweetsExcludedDeckRectForMiniShuffle();
    if(rect && targetRect && moveCount > 0){
      await animateSweetsExcludeMove(rect, targetRect, totalCount, keepCount);
    } else if(moveCount > 0){
      setSweetsCountOverrides(keepCount, moveCount, 5000);
      updateSweetsDeckUI();
    }

    await maybeHostApplySweetsSplit(deck, playerCount);
    if(token !== miniShuffleToken) return;
    if(reason === 'afterActionDeal'){
      await hostRestartTurnAfterActionDeal(leaderSeatForRestart);
    }else{
      await hostGrantTurnAfterMiniShuffle();
    }
  } finally {
    turnBlockedByShuffle = false;
    updateTurnUI();
  }
}

async function animateRoundEndReveal(cards, selectedUids){
  if(_roundAnimRunning){
    stopRoundEndFx();
    _roundAnimRunning = false;
  }
  _roundAnimRunning = true;

  try{
    stopRoundEndFx();
    const token = roundEndFx.token;

    document.querySelectorAll('.collect-card').forEach(el => el.remove());
    roundRevealRow.innerHTML = '';
    roundRevealOverlay.classList.add('hidden');

    const uids = Array.isArray(selectedUids) ? selectedUids : [];
    ensureDecidedRoundStart(uids);
    scheduleCenterMovesForUids(uids);

    await waitForDecidedTimestamps(uids);
    const latestDecidedAt = getLatestAppliedDecidedAt(uids);    const centerMoveStartAt = latestDecidedAt + DECIDED_CENTER_DELAY_MS;
    const shuffleStartAt = centerMoveStartAt + 1200;
    const waitMs = Math.max(0, shuffleStartAt - Date.now());
    if(waitMs > 0){
      await new Promise(resolve => setTimeout(resolve, waitMs));
    }
    if(token !== roundEndFx.token) return;

    uids.forEach(uid => {
      const origin = _pickOriginElForUid(uid);
      _hideOriginVisual(uid, origin);
    });

    await _runSweetShuffle1(token);
    if(token !== roundEndFx.token) return;

    roundRevealRow.innerHTML = '';
    (Array.isArray(cards) ? cards : []).forEach(card => {
      const el = document.createElement('div');
      el.className = 'roundreveal-card';
      const img = document.createElement('img');
      img.src = card?.img || card?.fallback || SWEETS_BACK_IMG;
      img.alt = `sweets ${card?.value ?? ''}`;
      img.onerror = () => { if(card?.fallback) img.src = card.fallback; };
     el.appendChild(img);
      roundRevealRow.appendChild(el);
    });
    markRoundRevealStarted();
    roundRevealOverlay.classList.remove('hidden');

    await new Promise(resolve => setTimeout(resolve, 2800));
    if(token !== roundEndFx.token) return;

    roundRevealOverlay.classList.add('hidden');
    roundRevealRow.innerHTML = '';
    markRoundRevealFinished();

    for(const restore of roundEndFx.restores){
      try{ restore(); }catch(_){}
    }
    roundEndFx.restores = [];
  } finally {
    _roundAnimRunning = false;
    if(roundRevealState.started && !roundRevealState.finished){
      markRoundRevealFinished();
    }
  }
}

/* =========================
   ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ï¼ˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚«ãƒ¼ãƒ‰ï¼‰
   ========================= */
const drag = {
  active:false,
  card:null,
  el:null,
  offsetX:0, offsetY:0,
  originRect:null,
  lastClientX:null,
  lastClientY:null,
};

function canUseOnPlayCircle(card){
  if(card.kind !== 'instruction') return true;
  if(INSTRUCTION_NEED_TARGET.has(card.name)) return false;
  return true;
}
function canUseOnOtherPlayer(card){
  if(card.kind !== 'instruction') return false;
  return true;
}
function canStartUseCard(cardObj){
  if(!isMyTurn()) return false;
  if(getRoundPick()?.phase === 'choose') return false;
  const receivedExists = hasReceivedInstruction();
  if(!receivedExists) return true;
  const isReceived = (getMyReceivedCard()?.id === cardObj.id);
  if(isReceived) return true;

  const isIgnore = (cardObj.kind === 'instruction' && cardObj.name === 'ç„¡è¦–');
  return isIgnore;
}

let hoverOtherCircle = null;
function clearOtherCircleHint(){
  if(!hoverOtherCircle) return;
  hoverOtherCircle.classList.remove('hint-ok','hint-ng');
  hoverOtherCircle = null;
}
function updateOtherCircleHint(x,y,cardObj){
  clearOtherCircleHint();
  const el = document.elementFromPoint(x,y);
  const c = el?.closest?.('.otherplayerscircle');
  if(!c) return;

  const ok = canUseOnOtherPlayer(cardObj);
  c.classList.add(ok ? 'hint-ok' : 'hint-ng');
  hoverOtherCircle = c;
}

function getDropTarget(x,y){
  const pr = playCircleEl.getBoundingClientRect();
  const inPlay = (x>=pr.left && x<=pr.right && y>=pr.top && y<=pr.bottom);
  if(inPlay) return { type:'playCircle' };

  const el = document.elementFromPoint(x,y);
  const circle = el?.closest?.('.otherplayerscircle');
  if(circle){
    const tag = circle.querySelector('.player-tag');
    if(tag){
      const seat = Number(tag.dataset.seat);
      const uid = tag.dataset.uid;
      return { type:'otherCircle', seat, uid };
    }
  }

  const tag = el?.closest?.('.player-tag');
  if(tag){
    const seat = Number(tag.dataset.seat);
    const uid = tag.dataset.uid;
    return { type:'playerTag', seat, uid };
  }

  return { type:'none' };
}

function startDragCard(e, cardObj, cardEl){
  if(!canStartUseCard(cardObj)) return;
  e.preventDefault();

  drag.active = true;
  drag.card = cardObj;
  drag.el = cardEl;
  drag.originRect = cardEl.getBoundingClientRect();

  const r = drag.originRect;
  drag.offsetX = e.clientX - r.left;
  drag.offsetY = e.clientY - r.top;
  drag.lastClientX = e.clientX;
  drag.lastClientY = e.clientY;

  cardEl.classList.add('dragging');
  cardEl.style.left = `${r.left}px`;
  cardEl.style.top  = `${r.top}px`;

  cardEl.setPointerCapture(e.pointerId);

  playCircleEl.classList.toggle('hint-ok', canUseOnPlayCircle(cardObj));
  playCircleEl.classList.toggle('hint-ng', !canUseOnPlayCircle(cardObj));

  cardEl.addEventListener('pointermove', onDragMove);
  cardEl.addEventListener('pointerup', onDragEnd);
  cardEl.addEventListener('pointercancel', onDragEnd);
}

function onDragMove(e){
  if(!drag.active) return;
  const x = e.clientX - drag.offsetX;
  const y = e.clientY - drag.offsetY;
  drag.lastClientX = e.clientX;
  drag.lastClientY = e.clientY;
  drag.el.style.left = `${x}px`;
  drag.el.style.top  = `${y}px`;

  updateOtherCircleHint(e.clientX, e.clientY, drag.card);
}

async function onDragEnd(e){
  if(!drag.active) return;

  const cardObj = drag.card;
  const drop = getDropTarget(e.clientX, e.clientY);

  playCircleEl.classList.remove('hint-ok','hint-ng');
  clearOtherCircleHint();

  if(drop.type === 'playCircle'){
    const ok = canUseOnPlayCircle(cardObj);
    if(!ok){ snapBack(); return; }

    await playCardToCircle(cardObj);
    cleanupDrag();
    return;
  }

  if(drop.type === 'otherCircle'){
    if(cardObj.kind !== 'instruction'){ snapBack(); return; }
    await giveInstructionToPlayer(cardObj, drop.seat, drop.uid);
    cleanupDrag();
    return;
  }

  if(drop.type === 'playerTag'){
    const isSelf = (drop.uid === state.userId);
    if(cardObj.kind !== 'instruction'){ snapBack(); return; }
    if(isSelf && !INSTRUCTION_CAN_SELF.has(cardObj.name)){ snapBack(); return; }
    if(isSelf){
      await playCardToCircle(cardObj);
      cleanupDrag();
      return;
    }
    snapBack();
    return;
  }

  snapBack();
}

function snapBack(){
  const el = drag.el;
  el.animate([
    { transform:'translate(0,0) scale(1.02)' },
    { transform:'translate(0,0) scale(1.0)' }
  ], { duration: 120, easing:'ease-out' });

  el.style.left = '';
  el.style.top  = '';
  el.classList.remove('dragging');

  cleanupDrag();
}

function cleanupDrag(){
  if(!drag.el) return;
  drag.el.removeEventListener('pointermove', onDragMove);
  drag.el.removeEventListener('pointerup', onDragEnd);
  drag.el.removeEventListener('pointercancel', onDragEnd);

  drag.active = false;
  drag.card = null;
  drag.el = null;
  drag.originRect = null;
  drag.lastClientX = null;
  drag.lastClientY = null;
}

/* =========================
   â˜… ãƒ–ãƒ­ãƒƒã‚¯è§£é™¤ï¼ˆç„¡è¦–ä½¿ç”¨æ™‚ï¼‰
   ========================= */
async function consumeReceivedInstruction(){
  if(!state.roomCode) return;
  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const rec = Array.isArray(myData.received) ? myData.received : [];
  if(!rec.length) return;

  await update(myRef, { received: [] });
}

/* =========================
   ã‚«ãƒ¼ãƒ‰ä½¿ç”¨ï¼šãƒ—ãƒ¬ã‚¤ã‚µãƒ¼ã‚¯ãƒ«
   ========================= */
async function playCardToCircle(cardObj){
  if(!state.roomCode) return;
  if(!isMyTurn()) return;

  const receivedExists = hasReceivedInstruction();
  const isIgnore = (cardObj.kind === 'instruction' && cardObj.name === 'ç„¡è¦–');

  const rec = getMyReceivedCard();
  const isReceived = (rec && rec.id === cardObj.id);

  if(isReceived){
    const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
    await update(myRef, { received: [] });

    const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
    const disSnap = await get(disRef);
    const discard = disSnap.val() || [];
    await set(disRef, [...discard, cardObj]);

    await emitEvent({ type:'revealCard', card: cardObj });
    await runActionCardEffect(cardObj);

    await endTurn('playReceivedInstruction');
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const snap = await get(myRef);
  const myData = snap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const disRef = ref(db, `rooms/${state.roomCode}/discard/action`);
  const disSnap = await get(disRef);
  const discard = disSnap.val() || [];
  await set(disRef, [...discard, cardObj]);

  await emitEvent({ type:'revealCard', card: cardObj });

  if(receivedExists && isIgnore){
    await consumeReceivedInstruction();
    await endTurn('ignore_clear_received');
    updateActionDeckUI();
    updateSweetsDeckUI();
    renderMyVoteChip();
    updatePassRoundBtn();
    return;
  }

  await runActionCardEffect(cardObj);
  await endTurn('playAction');
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

async function runActionCardEffect(cardObj){
  return;
}

/* =========================
   æŒ‡ç¤ºã‚«ãƒ¼ãƒ‰ï¼šä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸æ¸¡ã™
   ========================= */
async function giveInstructionToPlayer(cardObj, targetSeat, targetUid){
  if(!state.roomCode) return;
  if(!isMyTurn()) return;

  if(!canUseOnOtherPlayer(cardObj)){
    return;
  }

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const arr = Array.isArray(myData.action) ? myData.action : [];
  const nextArr = arr.filter(c => c.id !== cardObj.id);
  await update(myRef, { action: nextArr });

  const toRef = ref(db, `rooms/${state.roomCode}/hands/${targetUid}`);
  const nextReceived = [cardObj];
  await update(toRef, { received: nextReceived });

  const fromSeat = state.turn?.activeSeat ?? state.seatedTable;
  await emitEvent({ type:'flyBackCard', fromSeat, toSeat: targetSeat });

  await runInstructionCardEffect(cardObj, targetUid);

  await endTurn('giveInstruction_received');
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}
async function runInstructionCardEffect(cardObj, targetUid){
  return;
}

/* =========================
   â˜… ã‚¹ã‚¤ãƒ¼ãƒ„ï¼šå±±æœ­ã‚¯ãƒªãƒƒã‚¯ â†’ ä¸€è¦§è¡¨ç¤º
   ========================= */
let sweetsPanelLocked = false;

function canOpenSweetsPicker(){
  if(!state.room?.gameStarted) return false;
  if(!isMyTurn()) return false;
  if(hasReceivedInstruction()) return false;
  if(hasSweets()) return false;
  const deck = state.room?.decks?.sweets;
  if(!Array.isArray(deck) || !deck.length) return false;
  return true;
}

function openSweetsPicker(){
  const deck = state.room?.decks?.sweets;
  if(!Array.isArray(deck) || !deck.length) return;

  sweetsPanelLocked = true;
  btnSweetsClose.disabled = true;

  const sorted = [...deck].sort((a,b)=> (a.value ?? 0) - (b.value ?? 0));
  const cols = Math.ceil(sorted.length / 2);
  sweetsGrid.style.gridTemplateColumns = `repeat(${cols}, 90px)`;

  sweetsGrid.innerHTML = '';
  sorted.forEach(cardObj => {
    const el = document.createElement('div');
    el.className = 'sweets-pick-card';
    el.dataset.cardId = cardObj.id;

    const img = document.createElement('img');
    img.src = cardObj.img;
    img.alt = `sweets ${cardObj.value ?? ''}`;
    img.onerror = () => { if(cardObj.fallback) img.src = cardObj.fallback; };

    el.appendChild(img);
    el.addEventListener('pointerdown', (e) => startDragSweets(e, cardObj, el));
    sweetsGrid.appendChild(el);
  });

  sweetsBackdrop.classList.remove('hidden');
}

function closeSweetsPicker(){
  if(sweetsPanelLocked) return;
  sweetsBackdrop.classList.add('hidden');
}
btnSweetsClose.addEventListener('click', closeSweetsPicker);
sweetsBackdrop.addEventListener('click', (e) => {
  if(e.target === sweetsBackdrop) closeSweetsPicker();
});

sweetsDeckUI.addEventListener('click', () => {
  if(!canOpenSweetsPicker()) return;
  openSweetsPicker();
});

/* =========================
   â˜… ã‚¹ã‚¤ãƒ¼ãƒ„ï¼šãƒ‰ãƒ©ãƒƒã‚° â†’ dropZone ã§ç²å¾—
   ========================= */
const sweetsDrag = {
  active:false,
  card:null,
  srcEl:null,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
};

function startDragSweets(e, cardObj, srcEl){
  if(!canOpenSweetsPicker()) return;
  e.preventDefault();

  sweetsDrag.active = true;
  sweetsDrag.card = cardObj;
  sweetsDrag.srcEl = srcEl;
  const r = srcEl.getBoundingClientRect();
  sweetsDrag.offsetX = e.clientX - r.left;
  sweetsDrag.offsetY = e.clientY - r.top;
  sweetsDrag.lastClientX = e.clientX;
  sweetsDrag.lastClientY = e.clientY;

  const ghost = srcEl.cloneNode(true);
  ghost.classList.add('sweets-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  sweetsDrag.ghost = ghost;
  sweetsDrag.srcEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onSweetsDragMove);
  ghost.addEventListener('pointerup', onSweetsDragEnd);
  ghost.addEventListener('pointercancel', onSweetsDragEnd);
}

function onSweetsDragMove(e){
  if(!sweetsDrag.active || !sweetsDrag.ghost) return;
  const x = e.clientX - sweetsDrag.offsetX;
  const y = e.clientY - sweetsDrag.offsetY;
  sweetsDrag.lastClientX = e.clientX;
  sweetsDrag.lastClientY = e.clientY;
  sweetsDrag.ghost.style.left = `${x}px`;
  sweetsDrag.ghost.style.top  = `${y}px`;

  if(sweetsDropZone){
    const zoneR = sweetsDropZone.getBoundingClientRect();
    const inZone = (e.clientX >= zoneR.left && e.clientX <= zoneR.right && e.clientY >= zoneR.top && e.clientY <= zoneR.bottom);
    sweetsDropZone.classList.toggle('active', inZone);
  }
}

async function onSweetsDragEnd(e){
  if(!sweetsDrag.active) return;

  const gx = e.clientX;
  const gy = e.clientY;

  const zoneR = sweetsDropZone?.getBoundingClientRect();
  const inDropZone = zoneR
    ? (gx >= zoneR.left && gx <= zoneR.right && gy >= zoneR.top && gy <= zoneR.bottom)
    : false;

  if(inDropZone){
    await acquireSweetsCard(sweetsDrag.card);
    cleanupSweetsDrag();
    return;
  }

  cleanupSweetsDrag();
}

function cleanupSweetsDrag(){
  if(sweetsDrag.ghost){
    sweetsDrag.ghost.removeEventListener('pointermove', onSweetsDragMove);
    sweetsDrag.ghost.removeEventListener('pointerup', onSweetsDragEnd);
    sweetsDrag.ghost.removeEventListener('pointercancel', onSweetsDragEnd);
    sweetsDrag.ghost.remove();
  }
  if(sweetsDrag.srcEl){
    sweetsDrag.srcEl.style.visibility = '';
  }
  sweetsDropZone?.classList.remove('active');
  sweetsDrag.active = false;
  sweetsDrag.card = null;
  sweetsDrag.srcEl = null;
  sweetsDrag.ghost = null;
  sweetsDrag.offsetX = 0;
  sweetsDrag.offsetY = 0;
  sweetsDrag.lastClientX = null;
  sweetsDrag.lastClientY = null;
}

async function acquireSweetsCard(cardObj){
  if(!state.roomCode) return;
  if(!canOpenSweetsPicker()) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const already = Array.isArray(myData.sweets) && myData.sweets.length;
  if(already) return;

  const deckRef = ref(db, `rooms/${state.roomCode}/decks/sweets`);
  const deckSnap = await get(deckRef);
  const deck = deckSnap.val() || [];
  const exists = Array.isArray(deck) && deck.some(c => c.id === cardObj.id);
  if(!exists) return;

  const nextDeck = deck.filter(c => c.id !== cardObj.id);

  await set(deckRef, nextDeck);
  await update(myRef, { sweets: [cardObj] });

  sweetsPanelLocked = false;
  btnSweetsClose.disabled = false;
  sweetsBackdrop.classList.add('hidden');

  await endTurn('drawSweets');

  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
}

/* =========================
   â˜… æŠ•ç¥¨ï¼šãƒãƒƒãƒ—ãƒ‰ãƒ©ãƒƒã‚° â†’ swarea ã¸ãƒ‰ãƒ­ãƒƒãƒ—
   ========================= */
const voteDrag = {
  active:false,
  ghost:null,
  offsetX:0,
  offsetY:0,
  lastClientX:null,
  lastClientY:null,
  sourceEl:null,
  showAllHints:false,
};
let hoverSwarea = null;

function setAllSweetsWrapHints(active){
  document.querySelectorAll('.sweets-wrap').forEach((wrap) => {
    wrap.classList.remove('hint-ok', 'hint-ng');
    if(!active) return;
    const ok = !wrap.classList.contains('empty');
    wrap.classList.add(ok ? 'hint-ok' : 'hint-ng');
  });
}

function clearSwareaHint(){
  if(!hoverSwarea) return;
  hoverSwarea.classList.remove('hint-ok','hint-ng');
  hoverSwarea = null;
}
function updateSwareaHint(x,y){
  if(voteDrag.showAllHints) return;
  clearSwareaHint();
  const el = document.elementFromPoint(x,y);
  const area = el?.closest?.('.sweets-wrap');   // â˜…å¤‰æ›´
  if(!area) return;

  const ok = !area.classList.contains('empty');
  area.classList.add(ok ? 'hint-ok' : 'hint-ng');
  hoverSwarea = area;
}
function getVoteDropTarget(x,y){
  const el = document.elementFromPoint(x,y);
  const wrap = el?.closest?.('.sweets-wrap');   // â˜…å¤‰æ›´
  if(!wrap) return { type:'none' };

  // â˜… tagã¯ç¥–å…ˆã˜ã‚ƒãªã„ã®ã§ã€otherplayerscircle ã‹ã‚‰ uid ã‚’å–ã‚‹
  const circle = wrap.closest('.otherplayerscircle');
  const tag = circle?.querySelector('.player-tag');
  const uid = tag?.dataset?.uid || null;
  if(!uid) return { type:'none' };

  const handData = state.hands?.[uid];
  const hasTheirSweets = !!(handData && Array.isArray(handData.sweets) && handData.sweets.length);

  return { type:'swwrap', uid, ok: hasTheirSweets };
}

function startDragVoteChip(e){
  if(!canVoteNow()) return;
  e.preventDefault();

  const r = myVoteChipEl.getBoundingClientRect();
  voteDrag.active = true;
  voteDrag.sourceEl = myVoteChipEl;
  voteDrag.offsetX = e.clientX - r.left;
  voteDrag.offsetY = e.clientY - r.top;
  voteDrag.lastClientX = e.clientX;
  voteDrag.lastClientY = e.clientY;

  voteDrag.showAllHints = true;
  setAllSweetsWrapHints(true);

  const ghost = myVoteChipEl.cloneNode(true);
  ghost.classList.remove('hidden');
  ghost.classList.add('vote-dragging');
  ghost.style.visibility = 'visible';
  ghost.style.left = `${r.left}px`;
  ghost.style.top  = `${r.top}px`;
  ghost.style.width = `${r.width}px`;
  ghost.style.height = `${r.height}px`;
  document.body.appendChild(ghost);
  voteDrag.ghost = ghost;
  voteDrag.sourceEl.style.visibility = 'hidden';

  ghost.setPointerCapture(e.pointerId);
  ghost.addEventListener('pointermove', onVoteDragMove);
  ghost.addEventListener('pointerup', onVoteDragEnd);
  ghost.addEventListener('pointercancel', onVoteDragEnd);
}

function onVoteDragMove(e){
  if(!voteDrag.active || !voteDrag.ghost) return;
  const x = e.clientX - voteDrag.offsetX;
  const y = e.clientY - voteDrag.offsetY;
  voteDrag.lastClientX = e.clientX;
  voteDrag.lastClientY = e.clientY;
  voteDrag.ghost.style.left = `${x}px`;
  voteDrag.ghost.style.top  = `${y}px`;
  updateSwareaHint(e.clientX, e.clientY);
}

async function onVoteDragEnd(e){
  if(!voteDrag.active) return;

  const drop = getVoteDropTarget(e.clientX, e.clientY);
  clearSwareaHint();

  if(drop.type === 'swwrap' && drop.ok){   // â˜…å¤‰æ›´
    await castVote(drop.uid);
  }

  cleanupVoteDrag();
}

function cleanupVoteDrag(){
  if(voteDrag.ghost){
    voteDrag.ghost.removeEventListener('pointermove', onVoteDragMove);
    voteDrag.ghost.removeEventListener('pointerup', onVoteDragEnd);
    voteDrag.ghost.removeEventListener('pointercancel', onVoteDragEnd);
    voteDrag.ghost.remove();
  }
if(voteDrag.sourceEl){
    voteDrag.sourceEl.style.visibility = '';
  }
  voteDrag.active = false;
  voteDrag.showAllHints = false;
  setAllSweetsWrapHints(false);
  clearSwareaHint();
  voteDrag.ghost = null;
  voteDrag.offsetX = 0;
  voteDrag.offsetY = 0;
  voteDrag.lastClientX = null;
  voteDrag.lastClientY = null;
  voteDrag.sourceEl = null;
}

function syncFloatingDragPositions(){
  if(drag.active && drag.el && drag.lastClientX !== null && drag.lastClientY !== null){
    const x = drag.lastClientX - drag.offsetX;
    const y = drag.lastClientY - drag.offsetY;
    drag.el.style.left = `${x}px`;
    drag.el.style.top  = `${y}px`;
    updateOtherCircleHint(drag.lastClientX, drag.lastClientY, drag.card);
  }

  if(sweetsDrag.active && sweetsDrag.ghost && sweetsDrag.lastClientX !== null && sweetsDrag.lastClientY !== null){
    const x = sweetsDrag.lastClientX - sweetsDrag.offsetX;
    const y = sweetsDrag.lastClientY - sweetsDrag.offsetY;
    sweetsDrag.ghost.style.left = `${x}px`;
    sweetsDrag.ghost.style.top  = `${y}px`;
  }

  if(voteDrag.active && voteDrag.ghost && voteDrag.lastClientX !== null && voteDrag.lastClientY !== null){
    const x = voteDrag.lastClientX - voteDrag.offsetX;
    const y = voteDrag.lastClientY - voteDrag.offsetY;
    voteDrag.ghost.style.left = `${x}px`;
    voteDrag.ghost.style.top  = `${y}px`;
    updateSwareaHint(voteDrag.lastClientX, voteDrag.lastClientY);
  }
}

mainEl.addEventListener('scroll', syncFloatingDragPositions, { passive: true });
window.addEventListener('resize', syncFloatingDragPositions);

async function castVote(targetUid){
  if(!state.roomCode) return;
  if(!canVoteNow()) return;

  const myRef = ref(db, `rooms/${state.roomCode}/hands/${state.userId}`);
  const mySnap = await get(myRef);
  const myData = mySnap.val() || {};
  const chips = (typeof myData.voteChips === 'number') ? myData.voteChips : 1;
  if(chips <= 0) return;

  // 1) è‡ªåˆ†ã®ãƒãƒƒãƒ—æ¶ˆè²»ï¼ˆæ‰‹å…ƒã‹ã‚‰æ¶ˆãˆã‚‹ï¼‰
  await update(myRef, { voteChips: chips - 1 });

  // 2) æŠ•ç¥¨è¨˜éŒ²ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å³å´ã«è¡¨ç¤ºã•ã‚Œã‚‹ï¼‰
  await set(ref(db, `rooms/${state.roomCode}/votes/${targetUid}/${state.userId}`), true);

  // 3) ã“ã‚Œã¯1æŠ•ç¥¨ï¼ˆæ‰‹ç•ªçµ‚äº†ï¼‰
  await endTurn('vote');

  renderMyVoteChip();
  updatePassRoundBtn();
}

/* â˜… æŠ•ç¥¨ãƒãƒƒãƒ—ï¼špointerdown */
myVoteChipEl.addEventListener('pointerdown', startDragVoteChip);

/* =========================
   Seat UIï¼ˆæ—¢å­˜ï¼‰
   ========================= */
async function syncSeatUI(){
  if (!state.roomCode) return;

  const maxPlayers = state.room.maxPlayers || null;

  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = 'äººæ•°ã‚’é¸æŠ';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = 'å¸­ã‚’é¸æŠ';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* =========================
   è¿½ã„å‡ºã—ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ï¼ˆæ—¢å­˜ï¼‰
   ========================= */
kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || 'åç„¡ã—' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

/* =========================
   ãƒ›ã‚¹ãƒˆUIï¼ˆæ—¢å­˜ï¼‰
   ========================= */
hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => {
  startPop.classList.add('hidden');
});

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  resetLocalGameEffects();
  await hostGameStart();
  startPop.classList.add('hidden');
});

btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/roles`)),
    remove(ref(db, `${base}/game`)),
    remove(ref(db, `${base}/decks`)),
    remove(ref(db, `${base}/discard`)),
    remove(ref(db, `${base}/events`)),
    remove(ref(db, `${base}/votes`)),
    remove(ref(db, `${base}/gameStarted`)),
  ]);

  resetLocalGameEffects();
  state.seatedTable = null;
  startPop.classList.add('hidden');
  await syncSeatUI();
  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
});

/* =========================
   Joinï¼ˆæ—¢å­˜ï¼‰
   ========================= */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || 'åç„¡ã—';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  await restoreSeatFromDB();

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeRoles();
  subscribeGame();
  subscribeEvents();

  syncSeatUI();

  updateActionDeckUI();
  updateSweetsDeckUI();
  renderMyVoteChip();
  updatePassRoundBtn();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„', url);
  }
});


</script>

</body>
</html>
